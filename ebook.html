<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Golang From Hero To Hero - Membangun API Mini Toko Online</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #ffffff;
            overflow-x: hidden;
        }

        html {
            scroll-behavior: smooth;
        }

        /* Header */
        .header {
            background: #ffffff;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            padding: 1rem 0;
            transition: all 0.3s ease;
        }

        .header.dark {
            background: #1f2937;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 2rem;
        }

        .logo-section {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: bold;
            color: #2c3e50;
            transition: color 0.3s ease;
        }

        .logo.dark {
            color: #f9fafb;
        }

        .logo-subtitle {
            font-size: 0.875rem;
            color: #6b7280;
            font-weight: 500;
            transition: color 0.3s ease;
        }

        .logo-subtitle.dark {
            color: #9ca3af;
        }

        .header-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .font-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn:hover {
            background: #2980b9;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: #95a5a6;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
        }

        .theme-toggle {
            background: #f8f9fa;
            color: #495057;
            border: 1px solid #dee2e6;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            box-shadow: none;
        }

        .theme-toggle:hover {
            background: #e9ecef;
            border-color: #adb5bd;
            transform: none;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .theme-toggle.dark {
            background: #343a40;
            color: #f8f9fa;
            border-color: #495057;
        }

        .theme-toggle.dark:hover {
            background: #495057;
            border-color: #6c757d;
        }

        /* Main Layout */
        .main-container {
            display: flex;
            max-width: 1200px;
            margin: 0 auto;
            margin-top: 80px;
            min-height: calc(100vh - 80px);
        }

        /* Sidebar */
        .sidebar {
            width: 250px;
            background: #f8f9fa;
            border-right: 1px solid #e9ecef;
            padding: 1.5rem 1rem;
            position: fixed;
            left: 0;
            top: 80px;
            height: calc(100vh - 80px);
            overflow-y: auto;
            transition: transform 0.3s ease;
        }

        .sidebar h3 {
            font-size: 1rem;
            margin-bottom: 1rem;
            color: #2c3e50;
            font-weight: 600;
        }

        .sidebar.hidden {
            transform: translateX(-100%);
        }

        .sidebar-toggle {
            display: none;
            position: fixed;
            top: 100px;
            left: 20px;
            z-index: 1001;
            background: #3498db;
            color: white;
            border: none;
            padding: 0.5rem;
            border-radius: 5px;
            cursor: pointer;
        }

        .chapter-list {
            list-style: none;
        }

        .chapter-item {
            margin-bottom: 0.25rem;
        }

        .chapter-link {
            display: block;
            padding: 0.5rem 0.75rem;
            color: #2c3e50;
            text-decoration: none;
            border-radius: 3px;
            transition: background 0.3s;
            font-size: 0.9rem;
            line-height: 1.3;
        }

        .chapter-link:hover,
        .chapter-link.active {
            background: #3498db;
            color: white;
        }

        /* Content Area */
        .content {
            flex: 1;
            margin-left: 250px;
            padding: 2rem;
            background: white;
        }

        .content-header {
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid #e9ecef;
        }

        .chapter-title {
            font-size: 2rem;
            color: #2c3e50;
            margin-bottom: 0.5rem;
        }

        .chapter-meta {
            color: #7f8c8d;
            font-size: 0.9rem;
        }

        .content-body {
            font-size: 1.1rem;
            line-height: 1.8;
            max-width: 800px;
            margin: 0 auto;
        }

        .content-body h1,
        .content-body h2,
        .content-body h3 {
            color: #2c3e50;
            margin: 2rem 0 1rem 0;
        }

        .content-body h1 {
            font-size: 1.8rem;
        }

        .content-body h2 {
            font-size: 1.5rem;
        }

        .content-body h3 {
            font-size: 1.3rem;
        }

        .content-body p {
            margin-bottom: 1.5rem;
            text-align: justify;
        }

        .content-body blockquote {
            border-left: 4px solid #3498db;
            padding-left: 1.5rem;
            margin: 2rem 0;
            font-style: italic;
            color: #555;
        }

        .content-body ul,
        .content-body ol {
            margin: 1rem 0 1rem 2rem;
        }

        .content-body li {
            margin-bottom: 0.5rem;
        }

        .content-body pre {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .content-body code {
            background: #f8f9fa;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            color: #e74c3c;
        }

        .content-body pre code {
            background: none;
            padding: 0;
            color: #2c3e50;
        }

        .content-body a {
            color: #3498db;
            text-decoration: none;
        }

        .content-body a:hover {
            text-decoration: underline;
        }

        /* Navigation */
        .navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid #e9ecef;
        }

        .nav-btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 1rem 2rem;
            border-radius: 5px;
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
            transition: background 0.3s;
        }

        .nav-btn:hover {
            background: #2980b9;
        }

        .nav-btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }

        /* Progress Bar */
        .progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            width: 0%;
            height: 3px;
            background: #3498db;
            z-index: 1001;
            transition: width 0.3s ease;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .sidebar {
                transform: translateX(-100%);
            }

            .sidebar.show {
                transform: translateX(0);
            }

            .sidebar-toggle {
                display: block;
            }

            .content {
                margin-left: 0;
                padding: 1rem;
            }

            .header-content {
                padding: 0 1rem;
            }

            .chapter-title {
                font-size: 1.5rem;
            }

            .content-body {
                font-size: 1rem;
            }

            .navigation {
                flex-direction: column;
                gap: 1rem;
            }

            .nav-btn {
                text-align: center;
            }
        }

        /* Dark Mode Support */
        body.dark-mode {
            background-color: #111827;
            color: #f9fafb;
        }

        body.dark-mode .header {
            background: #1f2937;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        body.dark-mode .sidebar {
            background: #1f2937;
            border-right-color: #374151;
        }

        body.dark-mode .content {
            background: #111827;
        }

        body.dark-mode .content-header {
            border-bottom-color: #374151;
        }

        body.dark-mode .chapter-title {
            color: #f9fafb;
        }

        body.dark-mode .content-body h1,
        body.dark-mode .content-body h2,
        body.dark-mode .content-body h3 {
            color: #f9fafb;
        }

        body.dark-mode .navigation {
            border-top-color: #374151;
        }

        body.dark-mode .chapter-link {
            color: #d1d5db;
        }

        body.dark-mode .chapter-link:hover,
        body.dark-mode .chapter-link.active {
            background: #3b82f6;
            color: white;
        }

        body.dark-mode .content-body {
            color: #e5e7eb;
        }

        body.dark-mode .content-body blockquote {
            border-left-color: #3b82f6;
            color: #d1d5db;
        }

        body.dark-mode .content-body pre {
            background: #1f2937;
            border-color: #374151;
            color: #f9fafb;
        }

        body.dark-mode .content-body code {
            background: #1f2937;
            color: #fbbf24;
        }

        body.dark-mode .content-body pre code {
            background: none;
            color: #f9fafb;
        }

        body.dark-mode .content-body a {
            color: #60a5fa;
        }

        body.dark-mode .nav-btn {
            background: #3b82f6;
        }

        body.dark-mode .nav-btn:hover {
            background: #2563eb;
        }

        body.dark-mode .nav-btn:disabled {
            background: #6b7280;
        }

        /* Print Styles */
        @media print {
            .header,
            .sidebar,
            .navigation,
            .sidebar-toggle {
                display: none;
            }

            .content {
                margin-left: 0;
                padding: 0;
            }

            .content-body {
                font-size: 12pt;
                line-height: 1.5;
            }
        }
    </style>
</head>
<body>
    <!-- Progress Bar -->
    <div class="progress-bar" id="progressBar"></div>

    <!-- Header -->
    <header class="header" id="header">
        <div class="header-content">
            <div class="logo-section">
                <div class="logo" id="logo">Golang From Hero To Hero</div>
                <div class="logo-subtitle" id="logoSubtitle">Membangun API Mini Toko Online</div>
            </div>
            <div class="header-controls">
                <div class="font-controls">
                    <button class="btn btn-secondary" onclick="decreaseFont()">
                        <span>A-</span>
                    </button>
                    <span id="fontSize" class="text-sm font-medium">16px</span>
                    <button class="btn btn-secondary" onclick="increaseFont()">
                        <span>A+</span>
                    </button>
                </div>
                <button class="theme-toggle" id="themeToggle" onclick="toggleDarkMode()">
                    <span id="themeIcon">🌙</span>
                    <span id="themeText">Dark</span>
                </button>
            </div>
        </div>
    </header>

    <!-- Sidebar Toggle -->
    <button class="sidebar-toggle" onclick="toggleSidebar()">☰</button>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Sidebar -->
        <nav class="sidebar" id="sidebar">
            <h3>Daftar Isi</h3>
            <ul class="chapter-list" id="chapterList">
                <!-- Chapters will be populated by JavaScript -->
            </ul>
        </nav>

        <!-- Content Area -->
        <main class="content" id="contentArea">
            <!-- Content will be populated by JavaScript -->
        </main>
    </div>

    <script>
        // Chapter data structure - Easy to add new chapters
        const chapters = [
            {
                id: 'chapter1',
                title: 'Bab 1: Pengenalan',
                meta: 'Halaman 1 dari 50 • Dibaca 8 menit',
                content: `
                    <h2>Selamat Datang di Tutorial API Mini Toko Online dengan Go</h2>
                    <p>Dalam tutorial ini, kita akan belajar membuat API mini toko online menggunakan bahasa pemrograman Go. Go adalah bahasa pemrograman yang dikembangkan oleh Google yang terkenal dengan performa tinggi, kesederhanaan, dan kemudahan dalam pengembangan aplikasi web.</p>

                    <h3>Apa yang Akan Kita Pelajari?</h3>
                    <p>Sepanjang tutorial ini, kita akan membangun API toko online yang lengkap dengan fitur-fitur berikut:</p>

                    <ul>
                        <li><strong>Setup Project:</strong> Inisialisasi project dengan Go modules</li>
                        <li><strong>HTTP Server:</strong> Membuat server HTTP dengan Go standard library</li>
                        <li><strong>API Endpoints:</strong> Endpoint untuk CRUD operations (Create, Read, Update, Delete)</li>
                        <li><strong>Database Integration:</strong> Koneksi dan operasi database</li>
                        <li><strong>Middleware:</strong> Authentication, logging, dan error handling</li>
                        <li><strong>Testing:</strong> Unit testing dan integration testing</li>
                        <li><strong>Deployment:</strong> Cara deploy aplikasi ke production</li>
                    </ul>

                    <h3>Prasyarat</h3>
                    <p>Sebelum memulai, pastikan Anda telah menginstall:</p>

                    <ul>
                        <li><strong>Go 1.19+</strong> - Download dari <a href="https://golang.org/dl/" target="_blank">golang.org</a></li>
                        <li><strong>Git</strong> - Untuk version control</li>
                        <li><strong>Text Editor/IDE</strong> - VS Code, GoLand, atau editor favorit Anda</li>
                        <li><strong>Postman/Insomnia</strong> - Untuk testing API (opsional)</li>
                    </ul>

                    <h3>Tutorial Pertama: Install Go Modules</h3>
                    <p>Langkah pertama dalam membuat API mini toko online adalah menginisialisasi project dengan Go modules. Go modules adalah sistem manajemen dependensi resmi untuk Go yang memungkinkan kita mengelola package dan versi dengan mudah.</p>

                    <h4>Langkah 1: Buat Direktori Project</h4>
                    <p>Buat direktori baru untuk project kita:</p>

                    <pre><code>mkdir tokogo
cd tokogo</code></pre>

                    <h4>Langkah 2: Inisialisasi Go Module</h4>
                    <p>Jalankan perintah berikut untuk menginisialisasi Go module:</p>

                    <pre><code>go mod init tokogo</code></pre>

                    <p>Perintah ini akan membuat file <code>go.mod</code> di direktori project. File ini berisi informasi tentang module kita, termasuk nama module dan versi Go yang digunakan.</p>

                    <h4>Struktur File go.mod</h4>
                    <p>Setelah menjalankan perintah di atas, Anda akan melihat file <code>go.mod</code> dengan isi seperti ini:</p>

                    <pre><code>module tokogo

go 1.25.1</code></pre>

                    <p>File ini menunjukkan bahwa:</p>
                    <ul>
                        <li>Nama module kita adalah <code>tokogo</code></li>
                        <li>Kita menggunakan Go versi 1.25.1</li>
                    </ul>

                    <h4>Langkah 3: Verifikasi Setup</h4>
                    <p>Untuk memastikan setup berhasil, jalankan perintah berikut:</p>

                    <pre><code>go version</code></pre>

                    <p>Anda seharusnya melihat output yang menunjukkan versi Go yang terinstall.</p>

                    <blockquote>
                        <strong>Tips:</strong> Go modules memungkinkan kita untuk mengelola dependensi dengan mudah. Ketika kita mengimport package dari repository lain, Go akan otomatis menambahkannya ke file go.mod dan membuat file go.sum untuk verifikasi checksum.
                    </blockquote>

                    <h3>Langkah Selanjutnya</h3>
                    <p>Sekarang kita telah berhasil menginisialisasi project dengan Go modules. Di bab selanjutnya, kita akan belajar tentang struktur project yang baik dan mulai membangun HTTP server pertama kita.</p>

                    <p>Pastikan Anda telah memahami konsep Go modules sebelum melanjutkan ke bab berikutnya, karena ini adalah fondasi penting untuk pengembangan aplikasi Go modern.</p>
                `
            },
            {
                id: 'chapter2',
                title: 'Bab 2: Install Dependency',
                meta: 'Halaman 2 dari 50 • Dibaca 6 menit',
                content: `
                    <h2>Menginstall Dependencies untuk API Toko Online</h2>
                    <p>Setelah berhasil menginisialisasi project dengan Go modules, langkah selanjutnya adalah menginstall dependencies (package) yang dibutuhkan untuk membangun API mini toko online. Dependencies ini akan membantu kita dalam berbagai aspek pengembangan, mulai dari HTTP server hingga database operations.</p>

                    <h3>Dependencies yang Akan Kita Install</h3>
                    <p>Berikut adalah daftar dependencies yang akan kita gunakan dalam project ini:</p>

                    <ul>
                        <li><strong>Gin Framework:</strong> HTTP web framework yang cepat dan ringan</li>
                        <li><strong>GORM:</strong> Object-Relational Mapping library untuk Go</li>
                        <li><strong>MySQL Driver:</strong> Driver untuk koneksi ke database MySQL</li>
                        <li><strong>CORS Middleware:</strong> Untuk menangani Cross-Origin Resource Sharing</li>
                        <li><strong>Godotenv:</strong> Untuk memuat environment variables dari file .env</li>
                        <li><strong>JWT:</strong> Untuk implementasi JSON Web Token authentication</li>
                    </ul>

                    <h3>Langkah-langkah Instalasi</h3>
                    <p>Jalankan perintah-perintah berikut satu per satu di terminal dalam direktori project <code>tokogo</code>:</p>

                    <h4>1. Install Gin Framework</h4>
                    <p>Gin adalah HTTP web framework yang sangat populer di Go karena performanya yang tinggi dan kemudahan penggunaannya.</p>
                    <pre><code>go get -u github.com/gin-gonic/gin</code></pre>

                    <h4>2. Install GORM</h4>
                    <p>GORM adalah ORM library yang powerful untuk Go, memudahkan kita dalam berinteraksi dengan database.</p>
                    <pre><code>go get -u gorm.io/gorm</code></pre>

                    <h4>3. Install MySQL Driver untuk GORM</h4>
                    <p>Driver ini diperlukan untuk koneksi ke database MySQL.</p>
                    <pre><code>go get -u gorm.io/driver/mysql</code></pre>

                    <h4>4. Install CORS Middleware</h4>
                    <p>CORS middleware diperlukan untuk menangani request dari frontend yang berbeda domain.</p>
                    <pre><code>go get -u github.com/gin-contrib/cors</code></pre>

                    <h4>5. Install Godotenv</h4>
                    <p>Godotenv membantu kita memuat environment variables dari file .env untuk konfigurasi aplikasi.</p>
                    <pre><code>go get -u github.com/joho/godotenv</code></pre>

                    <h4>6. Install JWT Library</h4>
                    <p>JWT library untuk implementasi authentication dan authorization.</p>
                    <pre><code>go get github.com/golang-jwt/jwt</code></pre>

                    <h4>7. Install Validator Library</h4>
                    <p>Validator library untuk validasi input data dengan binding tags.</p>
                    <pre><code>go get github.com/go-playground/validator/v10@v10.26.0</code></pre>

                    <h3>Verifikasi Instalasi</h3>
                    <p>Setelah menjalankan semua perintah di atas, periksa file <code>go.mod</code> untuk memastikan semua dependencies telah terinstall:</p>

                    <pre><code>cat go.mod</code></pre>

                    <p>File <code>go.mod</code> Anda seharusnya terlihat seperti ini:</p>

                    <pre><code>module tokogo

go 1.25.1

require (
    github.com/gin-contrib/cors v1.4.0
    github.com/gin-gonic/gin v1.9.1
    github.com/go-playground/validator/v10 v10.26.0
    github.com/golang-jwt/jwt v3.2.2+incompatible
    github.com/joho/godotenv v1.4.0
    gorm.io/driver/mysql v1.5.1
    gorm.io/gorm v1.25.2
)</code></pre>

                    <h3>Penjelasan Setiap Dependency</h3>

                    <h4>🔧 Gin Framework</h4>
                    <p><strong>Fungsi:</strong> HTTP web framework yang menyediakan routing, middleware, dan fitur-fitur web development lainnya.</p>
                    <p><strong>Keunggulan:</strong> Performa tinggi, sintaks yang sederhana, dan ekosistem yang luas.</p>

                    <h4>🗄️ GORM</h4>
                    <p><strong>Fungsi:</strong> Object-Relational Mapping yang memudahkan operasi database dengan sintaks Go yang natural.</p>
                    <p><strong>Keunggulan:</strong> Auto-migration, associations, hooks, dan dukungan untuk berbagai database.</p>

                    <h4>🐬 MySQL Driver</h4>
                    <p><strong>Fungsi:</strong> Driver resmi untuk koneksi ke database MySQL melalui GORM.</p>
                    <p><strong>Keunggulan:</strong> Optimized untuk performa dan kompatibilitas dengan MySQL.</p>

                    <h4>🌐 CORS Middleware</h4>
                    <p><strong>Fungsi:</strong> Menangani Cross-Origin Resource Sharing untuk komunikasi dengan frontend.</p>
                    <p><strong>Keunggulan:</strong> Konfigurasi yang fleksibel dan mudah digunakan.</p>

                    <h4>⚙️ Godotenv</h4>
                    <p><strong>Fungsi:</strong> Memuat environment variables dari file .env untuk konfigurasi aplikasi.</p>
                    <p><strong>Keunggulan:</strong> Memisahkan konfigurasi dari kode, meningkatkan keamanan.</p>

                    <h4>🔐 JWT Library</h4>
                    <p><strong>Fungsi:</strong> Implementasi JSON Web Token untuk authentication dan authorization.</p>
                    <p><strong>Keunggulan:</strong> Stateless authentication, aman, dan mudah diimplementasikan.</p>

                    <h4>✅ Validator Library</h4>
                    <p><strong>Fungsi:</strong> Library untuk validasi input data dengan binding tags yang powerful.</p>
                    <p><strong>Keunggulan:</strong> Validasi otomatis, fleksibel, dan terintegrasi dengan Gin framework.</p>

                    <blockquote>
                        <strong>Tips:</strong> Gunakan flag <code>-u</code> pada perintah <code>go get</code> untuk mengupdate ke versi terbaru dari dependencies yang sudah ada. Ini memastikan kita menggunakan versi yang paling up-to-date dan aman.
                    </blockquote>

                    <h3>File go.sum</h3>
                    <p>Setelah instalasi, Go akan otomatis membuat file <code>go.sum</code> yang berisi checksum untuk verifikasi integritas dependencies. File ini penting untuk memastikan konsistensi dependencies di berbagai environment.</p>

                    <h3>Langkah Selanjutnya</h3>
                    <p>Sekarang kita telah berhasil menginstall semua dependencies yang dibutuhkan. Di bab selanjutnya, kita akan belajar tentang struktur project yang baik dan mulai membuat file-file dasar untuk aplikasi kita.</p>

                    <p>Pastikan semua dependencies terinstall dengan benar sebelum melanjutkan ke bab berikutnya, karena kita akan menggunakan semua package ini dalam pengembangan API.</p>
                `
            },
            {
                id: 'chapter3',
                title: 'Bab 3: Struktur Folder',
                meta: 'Halaman 3 dari 50 • Dibaca 7 menit',
                content: `
                    <h2>Struktur Folder Project API Toko Online</h2>
                    <p>Setelah berhasil menginstall dependencies, langkah selanjutnya adalah membuat struktur folder yang baik dan terorganisir. Struktur folder yang rapi akan memudahkan pengembangan, maintenance, dan kolaborasi dalam tim.</p>

                    <h3>Struktur Folder yang Akan Kita Buat</h3>
                    <p>Berikut adalah struktur folder yang akan kita gunakan untuk project API mini toko online. <strong>File-file yang ditampilkan hanya sebagai contoh dan gambaran</strong> - yang penting adalah memahami struktur foldernya saja:</p>

                    <pre><code>tokogo/
├── config/
│   └── config.go
├── handlers/
│   ├── auth.go
│   ├── product.go
│   └── user.go
├── helpers/
│   ├── jwt.go
│   ├── response.go
│   └── validator.go
├── middlewares/
│   ├── auth.go
│   ├── cors.go
│   └── logger.go
├── models/
│   ├── product.go
│   └── user.go
├── repositories/
│   ├── product.go
│   └── user.go
├── requests/
│   ├── auth_request.go
│   ├── product_request.go
│   └── user_request.go
├── responses/
│   ├── auth_response.go
│   ├── product_response.go
│   └── user_response.go
├── services/
│   ├── auth.go
│   ├── product.go
│   └── user.go
├── main.go
├── .env
├── .gitignore
├── go.mod
├── go.sum
└── README.md</code></pre>

                    <h3>Penjelasan Setiap Folder</h3>
                    <p><em>Catatan: Nama file yang disebutkan di bawah ini hanya sebagai contoh. Yang penting adalah memahami fungsi setiap folder.</em></p>

                    <h4>📁 config/</h4>
                    <p><strong>Fungsi:</strong> Berisi konfigurasi aplikasi dan environment variables</p>
                    <p><strong>Contoh file:</strong> <code>config.go</code> - Load dan manage konfigurasi dari .env</p>

                    <h4>📁 handlers/</h4>
                    <p><strong>Fungsi:</strong> HTTP handlers (controllers) yang menangani request dari client</p>
                    <p><strong>Contoh file:</strong></p>
                    <ul>
                        <li><code>auth.go</code> - Handler untuk authentication (login, register)</li>
                        <li><code>product.go</code> - Handler untuk CRUD produk</li>
                        <li><code>user.go</code> - Handler untuk manajemen user</li>
                    </ul>

                    <h4>📁 helpers/</h4>
                    <p><strong>Fungsi:</strong> Utility functions dan helper yang bisa digunakan di seluruh aplikasi</p>
                    <p><strong>Contoh file:</strong></p>
                    <ul>
                        <li><code>jwt.go</code> - JWT token generation dan validation</li>
                        <li><code>response.go</code> - Standard response format</li>
                        <li><code>validator.go</code> - Custom validation functions</li>
                    </ul>

                    <h4>📁 middlewares/</h4>
                    <p><strong>Fungsi:</strong> Middleware functions untuk intercept request/response</p>
                    <p><strong>Contoh file:</strong></p>
                    <ul>
                        <li><code>auth.go</code> - Authentication middleware</li>
                        <li><code>cors.go</code> - CORS configuration</li>
                        <li><code>logger.go</code> - Request logging</li>
                    </ul>

                    <h4>📁 models/</h4>
                    <p><strong>Fungsi:</strong> Data models/structs yang merepresentasikan database tables</p>
                    <p><strong>Contoh file:</strong></p>
                    <ul>
                        <li><code>product.go</code> - Product model struct</li>
                        <li><code>user.go</code> - User model struct</li>
                    </ul>

                    <h4>📁 repositories/</h4>
                    <p><strong>Fungsi:</strong> Data access layer untuk berinteraksi dengan database</p>
                    <p><strong>Contoh file:</strong></p>
                    <ul>
                        <li><code>product.go</code> - Product database operations</li>
                        <li><code>user.go</code> - User database operations</li>
                    </ul>

                    <h4>📁 requests/</h4>
                    <p><strong>Fungsi:</strong> Request structs untuk validasi input dari client</p>
                    <p><strong>Contoh file:</strong></p>
                    <ul>
                        <li><code>auth_request.go</code> - Login/Register request structs</li>
                        <li><code>product_request.go</code> - Product CRUD request structs</li>
                        <li><code>user_request.go</code> - User management request structs</li>
                    </ul>

                    <h4>📁 responses/</h4>
                    <p><strong>Fungsi:</strong> Response structs untuk format output yang konsisten</p>
                    <p><strong>Contoh file:</strong></p>
                    <ul>
                        <li><code>auth_response.go</code> - Authentication response structs</li>
                        <li><code>product_response.go</code> - Product response structs</li>
                        <li><code>user_response.go</code> - User response structs</li>
                    </ul>

                    <h4>📁 services/</h4>
                    <p><strong>Fungsi:</strong> Business logic layer yang mengatur alur aplikasi</p>
                    <p><strong>Contoh file:</strong></p>
                    <ul>
                        <li><code>auth.go</code> - Authentication business logic</li>
                        <li><code>product.go</code> - Product business logic</li>
                        <li><code>user.go</code> - User business logic</li>
                    </ul>

                    <h4>📄 main.go</h4>
                    <p><strong>Fungsi:</strong> Entry point aplikasi yang menjalankan HTTP server</p>
                    <p><strong>Isi:</strong> Server setup, route configuration, dan middleware setup</p>

                    <h3>Langkah-langkah Membuat Struktur Folder</h3>

                    <h4>1. Buat Folder Utama</h4>
                    <p>Pastikan Anda sudah berada di direktori project <code>tokogo</code>:</p>
                    <pre><code>pwd
# Output: /path/to/your/project/tokogo</code></pre>

                    <h4>2. Buat Struktur Folder</h4>
                    <p>Jalankan perintah berikut untuk membuat semua folder sekaligus:</p>
                    <pre><code>mkdir -p config
mkdir -p handlers
mkdir -p helpers
mkdir -p middlewares
mkdir -p models
mkdir -p repositories
mkdir -p requests
mkdir -p responses
mkdir -p services</code></pre>

                    <h4>3. Verifikasi Struktur</h4>
                    <p>Gunakan command <code>tree</code> untuk melihat struktur folder:</p>
                    <pre><code>tree -d</code></pre>

                    <p>Jika <code>tree</code> tidak tersedia, gunakan:</p>
                    <pre><code>find . -type d | sort</code></pre>

                    <h3>File-file Konfigurasi</h3>

                    <h4>.env</h4>
                    <p>File untuk menyimpan environment variables:</p>
                    <pre><code># Database Configuration
DB_HOST=localhost
DB_PORT=3306
DB_USER=root
DB_PASSWORD=password
DB_NAME=tokogo

# Server Configuration
SERVER_PORT=8080
JWT_SECRET=your-secret-key

# Environment
ENV=development</code></pre>

                    <h4>.gitignore</h4>
                    <p>File untuk mengabaikan file tertentu dari Git:</p>
                    <pre><code># Binaries for programs and plugins
*.exe
*.exe~
*.dll
*.so
*.dylib

# Test binary, built with \`go test -c\`
*.test

# Output of the go coverage tool
*.out

# Dependency directories
vendor/

# Go workspace file
go.work

# Environment variables
.env
.env.local

# IDE files
.vscode/
.idea/
*.swp
*.swo

# OS generated files
.DS_Store
Thumbs.db</code></pre>

                    <h3>Arsitektur Pattern yang Digunakan</h3>

                    <h4>🏗️ Layered Architecture</h4>
                    <p>Struktur ini mengikuti prinsip Layered Architecture dengan pemisahan layer yang jelas:</p>
                    <ul>
                        <li><strong>Handlers:</strong> Layer presentasi (HTTP requests/responses)</li>
                        <li><strong>Services:</strong> Layer business logic</li>
                        <li><strong>Repositories:</strong> Layer data access</li>
                        <li><strong>Models:</strong> Data structures</li>
                        <li><strong>Requests/Responses:</strong> Data transfer objects</li>
                        <li><strong>Helpers:</strong> Utility functions</li>
                        <li><strong>Middlewares:</strong> Cross-cutting concerns</li>
                    </ul>

                    <h4>🔄 Dependency Flow</h4>
                    <p>Alur dependency mengalir dari luar ke dalam:</p>
                    <pre><code>Handlers → Services → Repositories → Database
    ↓         ↓         ↓
Requests  Responses  Models</code></pre>

                    <h4>📋 Request/Response Pattern</h4>
                    <p>Struktur ini menggunakan pattern Request/Response yang memisahkan:</p>
                    <ul>
                        <li><strong>Requests:</strong> Input validation dan data binding</li>
                        <li><strong>Responses:</strong> Output formatting dan serialization</li>
                        <li><strong>Models:</strong> Database entities</li>
                    </ul>

                    <blockquote>
                        <strong>Tips:</strong> Struktur folder ini mengikuti standar Go project layout yang direkomendasikan oleh komunitas Go. Ini akan memudahkan developer lain untuk memahami dan berkontribusi pada project.
                    </blockquote>

                    <h3>Langkah Selanjutnya</h3>
                    <p>Sekarang kita telah berhasil membuat struktur folder yang rapi dan terorganisir. Di bab selanjutnya, kita akan mulai membuat file-file dasar dan mengimplementasikan HTTP server pertama kita menggunakan Gin framework.</p>

                    <p><strong>Catatan Penting:</strong> File-file yang akan kita buat di bab selanjutnya mungkin memiliki nama atau struktur yang berbeda dengan contoh di atas. Yang penting adalah memahami konsep dan fungsi setiap folder. Struktur folder yang kita buat ini akan menjadi fondasi untuk pengembangan selanjutnya.</p>
                `
            },
            {
                id: 'chapter4',
                title: 'Bab 4: Konfigurasi Kode',
                meta: 'Halaman 4 dari 50 • Dibaca 8 menit',
                content: `
                    <h2>Konfigurasi Kode dan Environment Variables</h2>
                    <p>Setelah membuat struktur folder, langkah selanjutnya adalah membuat file-file konfigurasi yang akan mengatur environment variables dan koneksi database. Konfigurasi yang baik akan memudahkan deployment dan maintenance aplikasi.</p>

                    <h3>Langkah-langkah yang Akan Kita Lakukan</h3>
                    <p>Sebelum membuat file konfigurasi, kita perlu memastikan database MySQL sudah siap. Berikut urutan yang akan kita lakukan:</p>
                    <ol>
                        <li><strong>Setup Database MySQL</strong> - Membuat database dan user</li>
                        <li><strong>File .env</strong> - Environment variables</li>
                        <li><strong>config/env.go</strong> - Helper function untuk membaca environment variables</li>
                        <li><strong>config/database.go</strong> - Konfigurasi koneksi database</li>
                    </ol>

                    <h3>1. Setup Database MySQL</h3>
                    <p>Sebelum membuat konfigurasi, kita perlu memastikan database MySQL sudah berjalan dan database 'tokogo' sudah dibuat. Ada 2 cara yang bisa digunakan:</p>

                    <h4>🔧 Cara 1: Menggunakan Command Line (CMD/Terminal)</h4>
                    <p>Jika Anda sudah familiar dengan command line, cara ini lebih cepat:</p>

                    <h5>Langkah 1: Buka MySQL Command Line</h5>
                    <p>Buka Command Prompt atau Terminal, lalu login ke MySQL:</p>
                    <pre><code>mysql -u root -p</code></pre>
                    <p>Masukkan password MySQL Anda (jika ada). Jika tidak ada password, langsung tekan Enter.</p>

                    <h5>Langkah 2: Buat Database</h5>
                    <p>Setelah berhasil login, buat database 'tokogo':</p>
                    <pre><code>CREATE DATABASE tokogo;</code></pre>

                    <h5>Langkah 3: Verifikasi Database</h5>
                    <p>Pastikan database berhasil dibuat:</p>
                    <pre><code>SHOW DATABASES;</code></pre>
                    <p>Anda seharusnya melihat 'tokogo' dalam daftar database.</p>

                    <h5>Langkah 4: Keluar dari MySQL</h5>
                    <pre><code>EXIT;</code></pre>

                    <h4>🌐 Cara 2: Menggunakan phpMyAdmin (Lebih Mudah untuk Pemula)</h4>
                    <p>Jika Anda menggunakan XAMPP, WAMP, atau Laragon, cara ini lebih mudah:</p>

                    <h5>Langkah 1: Buka phpMyAdmin</h5>
                    <p>Buka browser dan akses: <code>http://localhost/phpmyadmin</code></p>

                    <h5>Langkah 2: Buat Database Baru</h5>
                    <p>Klik tab "Databases" di bagian atas, lalu:</p>
                    <ol>
                        <li>Masukkan nama database: <code>tokogo</code></li>
                        <li>Pilih Collation: <code>utf8mb4_unicode_ci</code> (opsional)</li>
                        <li>Klik tombol "Create"</li>
                    </ol>

                    <h5>Langkah 3: Verifikasi</h5>
                    <p>Database 'tokogo' akan muncul di sidebar kiri, klik untuk memastikan database kosong dan siap digunakan.</p>

                    <h4>⚠️ Troubleshooting</h4>
                    <p>Jika mengalami masalah:</p>
                    <ul>
                        <li><strong>MySQL tidak berjalan:</strong> Pastikan XAMPP/WAMP/Laragon sudah di-start</li>
                        <li><strong>Access denied:</strong> Coba tanpa password atau reset password MySQL</li>
                        <li><strong>Database sudah ada:</strong> Tidak masalah, bisa langsung digunakan</li>
                    </ul>

                    <blockquote>
                        <strong>Tips untuk Pemula:</strong> Jika Anda baru belajar, gunakan phpMyAdmin karena lebih visual dan mudah. Command line bisa dipelajari nanti setelah familiar dengan database.
                    </blockquote>

                    <h3>2. Membuat File .env</h3>
                    <p>File .env berisi environment variables yang akan digunakan oleh aplikasi. Buat file ini di root directory project:</p>

                    <pre><code># Database Configuration
DB_HOST=localhost
DB_PORT=3306
DB_USER=root
DB_PASSWORD=
DB_NAME=tokogo

# Server Configuration
SERVER_PORT=8080
JWT_SECRET=your-super-secret-jwt-key-here

# Environment
ENV=development</code></pre>

                    <h4>Penjelasan Environment Variables:</h4>
                    <ul>
                        <li><strong>DB_HOST:</strong> Host database (localhost untuk development)</li>
                        <li><strong>DB_PORT:</strong> Port database MySQL (default 3306)</li>
                        <li><strong>DB_USER:</strong> Username database</li>
                        <li><strong>DB_PASSWORD:</strong> Password database (kosong jika tidak ada)</li>
                        <li><strong>DB_NAME:</strong> Nama database yang akan digunakan</li>
                        <li><strong>SERVER_PORT:</strong> Port untuk HTTP server</li>
                        <li><strong>JWT_SECRET:</strong> Secret key untuk JWT token (ganti dengan key yang aman)</li>
                        <li><strong>ENV:</strong> Environment aplikasi (development/production)</li>
                    </ul>

                    <h3>3. Membuat File config/env.go</h3>
                    <p>File ini berisi helper function untuk membaca environment variables dengan default value:</p>

                    <pre><code>package config

import "os"

func GetEnv(key, defaultVal string) string {
    if value, exists := os.LookupEnv(key); exists && value != "" {
        return value
    }
    return defaultVal
}</code></pre>

                    <h4>Penjelasan Function GetEnv:</h4>
                    <ul>
                        <li><strong>Parameter key:</strong> Nama environment variable</li>
                        <li><strong>Parameter defaultVal:</strong> Nilai default jika environment variable tidak ditemukan</li>
                        <li><strong>Return:</strong> Nilai environment variable atau default value</li>
                    </ul>

                    <h3>4. Membuat File config/database.go</h3>
                    <p>File ini berisi konfigurasi koneksi database menggunakan GORM:</p>

                    <pre><code>package config

import (
    "fmt"
    "time"

    "tokogo/models"

    "gorm.io/driver/mysql"
    "gorm.io/gorm"
    "gorm.io/gorm/schema"
)

var DB *gorm.DB

func InitDB() {
    // Ambil konfigurasi database dari environment variables
    dbUser := GetEnv("DB_USER", "root")
    dbPassword := GetEnv("DB_PASSWORD", "")
    dbHost := GetEnv("DB_HOST", "localhost")
    dbPort := GetEnv("DB_PORT", "3306")
    dbName := GetEnv("DB_NAME", "tokogo")

    // Buat DSN (Data Source Name) untuk koneksi MySQL
    dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local",
        dbUser, dbPassword, dbHost, dbPort, dbName)

    var err error

    // Buka koneksi database menggunakan GORM
    DB, err = gorm.Open(mysql.Open(dsn), &gorm.Config{
        NamingStrategy: schema.NamingStrategy{
            SingularTable: true, // Gunakan nama table singular
        },
    })
    if err != nil {
        panic(fmt.Sprintf("Failed to connect to database: %v", err))
    }

    // Konfigurasi connection pool
    sqlDB, err := DB.DB()
    if err != nil {
        panic("Failed to get database instance!")
    }

    // Set connection pool settings
    sqlDB.SetMaxOpenConns(10)    // Maksimal 10 koneksi terbuka
    sqlDB.SetMaxIdleConns(5)     // Maksimal 5 koneksi idle
    sqlDB.SetConnMaxLifetime(time.Hour) // Maksimal 1 jam lifetime

    // Auto migrate model User (akan kita buat di bab selanjutnya)
    if err := DB.AutoMigrate(&models.User{}); err != nil {
        panic(fmt.Sprintf("AutoMigrate failed: %v", err))
    }
}</code></pre>

                    <h4>Penjelasan Konfigurasi Database:</h4>
                    <ul>
                        <li><strong>DSN:</strong> Data Source Name untuk koneksi MySQL</li>
                        <li><strong>SingularTable:</strong> Menggunakan nama table singular (user bukan users)</li>
                        <li><strong>Connection Pool:</strong> Mengatur jumlah koneksi maksimal</li>
                        <li><strong>AutoMigrate:</strong> Otomatis membuat/update table berdasarkan model</li>
                    </ul>

                    <h3>5. Membuat File .gitignore</h3>
                    <p>Pastikan file .env tidak di-commit ke Git untuk keamanan:</p>

                    <pre><code># Environment variables
.env
.env.local
.env.production

# Binaries
*.exe
*.exe~
*.dll
*.so
*.dylib

# Test binary
*.test

# Go workspace file
go.work

# IDE files
.vscode/
.idea/
*.swp
*.swo

# OS generated files
.DS_Store
Thumbs.db</code></pre>

                    <h3>6. Load Environment Variables di main.go</h3>
                    <p>Untuk menggunakan godotenv, kita perlu memuat file .env di awal aplikasi:</p>

                    <pre><code>package main

import (
    "log"

    "github.com/joho/godotenv"
    "tokogo/config"
)

func main() {
    // Load environment variables dari file .env
    if err := godotenv.Load(); err != nil {
        log.Println("No .env file found, using system environment variables")
    }

    // Initialize database connection
    config.InitDB()
    
    // Rest of your application code...
}</code></pre>

                    <h3>Keunggulan Konfigurasi Ini</h3>

                    <h4>🔒 Keamanan</h4>
                    <ul>
                        <li>Environment variables tidak di-commit ke Git</li>
                        <li>Konfigurasi berbeda untuk development dan production</li>
                        <li>Secret keys tidak ter-expose di kode</li>
                    </ul>

                    <h4>⚙️ Fleksibilitas</h4>
                    <ul>
                        <li>Mudah mengubah konfigurasi tanpa mengubah kode</li>
                        <li>Default values untuk development</li>
                        <li>Support multiple environments</li>
                    </ul>

                    <h4>🚀 Deployment</h4>
                    <ul>
                        <li>Mudah deploy ke server dengan environment variables</li>
                        <li>Konfigurasi database yang optimal</li>
                        <li>Connection pooling untuk performa</li>
                    </ul>

                    <blockquote>
                        <strong>Tips:</strong> Selalu gunakan environment variables untuk konfigurasi yang sensitif seperti database credentials dan JWT secret. Jangan pernah hardcode nilai-nilai ini di kode.
                    </blockquote>

                    <h3>7. Verifikasi Setup Database</h3>
                    <p>Setelah membuat semua file konfigurasi, mari kita verifikasi bahwa setup database sudah benar:</p>

                    <h4>✅ Checklist Verifikasi:</h4>
                    <ul>
                        <li>✅ MySQL server sudah berjalan (XAMPP/WAMP/Laragon sudah di-start)</li>
                        <li>✅ Database 'tokogo' sudah dibuat</li>
                        <li>✅ File .env sudah dibuat dengan konfigurasi yang benar</li>
                        <li>✅ File config/env.go sudah dibuat</li>
                        <li>✅ File config/database.go sudah dibuat</li>
                        <li>✅ File .gitignore sudah dibuat</li>
                    </ul>

                    <h4>🧪 Test Koneksi Database (Opsional)</h4>
                    <p>Jika ingin memastikan koneksi database berfungsi, buat file test sederhana:</p>

                    <pre><code>package main

import (
    "fmt"
    "log"

    "github.com/joho/godotenv"
    "tokogo/config"
)

func main() {
    // Load environment variables
    if err := godotenv.Load(); err != nil {
        log.Println("No .env file found, using system environment variables")
    }

    // Test database connection
    fmt.Println("Testing database connection...")
    config.InitDB()
    fmt.Println("✅ Database connection successful!")
}</code></pre>

                    <p>Jalankan dengan: <code>go run main.go</code></p>

                    <h3>Langkah Selanjutnya</h3>
                    <p>Sekarang kita telah berhasil membuat konfigurasi dasar untuk aplikasi. Di bab selanjutnya, kita akan membuat model User dan mulai mengimplementasikan HTTP server dengan Gin framework.</p>

                    <p><strong>Catatan Penting:</strong> Pastikan semua checklist di atas sudah terpenuhi sebelum melanjutkan ke bab selanjutnya. Jika ada error saat test koneksi database, periksa kembali konfigurasi MySQL dan file .env Anda.</p>
                `
            },
            {
                id: 'chapter5',
                title: 'Bab 5: Relaksasi & Review',
                meta: 'Halaman 5 dari 50 • Dibaca 12 menit',
                content: `
                    <h2>Bab Relaksasi & Review Pembelajaran</h2>
                    <p>Selamat! Anda telah menyelesaikan 4 bab pertama dari tutorial API Mini Toko Online dengan Go. Sekarang saatnya untuk beristirahat sejenak dan mengulas kembali semua yang telah dipelajari. Bab ini dirancang untuk membantu otak Anda mengkonsolidasikan pengetahuan yang baru saja diperoleh.</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">🧠 Mengapa Review Penting?</h3>
                        <p style="color: #495057; margin-bottom: 0;">Penelitian menunjukkan bahwa mengulang materi dalam 24 jam pertama dapat meningkatkan retensi memori hingga 80%. Mari kita manfaatkan momen ini untuk memperkuat pemahaman Anda!</p>
                    </div>

                    <h3>Ringkasan Pembelajaran Bab 1-4</h3>
                    <p>Sebelum masuk ke pertanyaan review, mari kita ingat kembali perjalanan pembelajaran yang telah kita lalui:</p>

                    <h4>Bab 1: Pengenalan Go Modules</h4>
                    <ul>
                        <li>✅ Memahami konsep Go modules dan manajemen dependensi</li>
                        <li>✅ Inisialisasi project dengan <code>go mod init tokogo</code></li>
                        <li>✅ Struktur file <code>go.mod</code> dan <code>go.sum</code></li>
                        <li>✅ Prasyarat pengembangan Go (Go 1.19+, Git, IDE)</li>
                    </ul>

                    <h4>Bab 2: Install Dependencies</h4>
                    <ul>
                        <li>✅ Gin Framework untuk HTTP web framework</li>
                        <li>✅ GORM untuk Object-Relational Mapping</li>
                        <li>✅ MySQL Driver untuk koneksi database</li>
                        <li>✅ CORS Middleware untuk Cross-Origin Resource Sharing</li>
                        <li>✅ Godotenv untuk environment variables</li>
                        <li>✅ JWT Library untuk authentication</li>
                    </ul>

                    <h4>Bab 3: Struktur Folder</h4>
                    <ul>
                        <li>✅ Layered Architecture pattern</li>
                        <li>✅ Pemisahan concerns (handlers, services, repositories)</li>
                        <li>✅ Request/Response pattern</li>
                        <li>✅ Dependency flow yang jelas</li>
                        <li>✅ Struktur folder yang scalable</li>
                    </ul>

                    <h4>Bab 4: Konfigurasi Kode</h4>
                    <ul>
                        <li>✅ Setup database MySQL</li>
                        <li>✅ Environment variables dengan file .env</li>
                        <li>✅ Konfigurasi koneksi database dengan GORM</li>
                        <li>✅ Connection pooling untuk performa</li>
                        <li>✅ Auto-migration untuk database schema</li>
                    </ul>

                    <h3>Pertanyaan Review Interaktif</h3>
                    <p>Mari kita uji pemahaman Anda dengan pertanyaan-pertanyaan yang dirancang untuk mengaktifkan kembali memori dan memperkuat pembelajaran:</p>

                    <div style="background: #f8f9fa; border-left: 4px solid #3498db; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Bagian A: Konsep Dasar Go Modules</h4>
                        
                        <p><strong>1. Apa fungsi utama dari file go.mod dalam project Go?</strong></p>
                        <p style="color: #666; font-style: italic;">💡 Petunjuk: Pikirkan tentang manajemen dependensi dan versi...</p>
                        
                        <p><strong>2. Mengapa kita menggunakan flag -u pada perintah go get?</strong></p>
                        <p style="color: #666; font-style: italic;">💡 Petunjuk: Apa yang terjadi jika kita tidak menggunakan flag ini?</p>
                        
                        <p><strong>3. Apa perbedaan antara go.mod dan go.sum?</strong></p>
                        <p style="color: #666; font-style: italic;">💡 Petunjuk: Satu untuk metadata, satu untuk keamanan...</p>
                    </div>

                    <div style="background: #f8f9fa; border-left: 4px solid #e74c3c; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Bagian B: Dependencies & Framework</h4>
                        
                        <p><strong>4. Mengapa kita memilih Gin Framework dibanding HTTP server bawaan Go?</strong></p>
                        <p style="color: #666; font-style: italic;">💡 Petunjuk: Pikirkan tentang routing, middleware, dan kemudahan...</p>
                        
                        <p><strong>5. Apa keunggulan GORM dibanding menulis SQL query manual?</strong></p>
                        <p style="color: #666; font-style: italic;">💡 Petunjuk: Auto-migration, associations, hooks...</p>
                        
                        <p><strong>6. Kapan kita membutuhkan CORS middleware?</strong></p>
                        <p style="color: #666; font-style: italic;">💡 Petunjuk: Frontend dan backend di domain berbeda...</p>
                        
                        <p><strong>7. Mengapa JWT lebih baik dari session-based authentication untuk API?</strong></p>
                        <p style="color: #666; font-style: italic;">💡 Petunjuk: Stateless, scalable, cross-domain...</p>
                    </div>

                    <div style="background: #f8f9fa; border-left: 4px solid #f39c12; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Bagian C: Arsitektur & Struktur</h4>
                        
                        <p><strong>8. Jelaskan alur dependency flow dalam arsitektur yang kita buat!</strong></p>
                        <p style="color: #666; font-style: italic;">💡 Petunjuk: Handlers → Services → Repositories → Database</p>
                        
                        <p><strong>9. Mengapa kita memisahkan requests dan responses dari models?</strong></p>
                        <p style="color: #666; font-style: italic;">💡 Petunjuk: Validasi input, format output, keamanan...</p>
                        
                        <p><strong>10. Apa fungsi dari folder helpers dan middlewares?</strong></p>
                        <p style="color: #666; font-style: italic;">💡 Petunjuk: Satu untuk utility, satu untuk intercept...</p>
                        
                        <p><strong>11. Bagaimana Layered Architecture membantu dalam maintenance code?</strong></p>
                        <p style="color: #666; font-style: italic;">💡 Petunjuk: Separation of concerns, testability...</p>
                    </div>

                    <div style="background: #f8f9fa; border-left: 4px solid #27ae60; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Bagian D: Konfigurasi & Database</h4>
                        
                        <p><strong>12. Mengapa kita menggunakan environment variables untuk konfigurasi?</strong></p>
                        <p style="color: #666; font-style: italic;">💡 Petunjuk: Keamanan, fleksibilitas, deployment...</p>
                        
                        <p><strong>13. Apa fungsi dari connection pooling dalam database?</strong></p>
                        <p style="color: #666; font-style: italic;">💡 Petunjuk: Performa, resource management...</p>
                        
                        <p><strong>14. Mengapa kita menggunakan AutoMigrate di GORM?</strong></p>
                        <p style="color: #666; font-style: italic;">💡 Petunjuk: Schema management, development speed...</p>
                        
                        <p><strong>15. Apa yang terjadi jika file .env tidak ditemukan saat aplikasi berjalan?</strong></p>
                        <p style="color: #666; font-style: italic;">💡 Petunjuk: Fallback ke system environment variables...</p>
                    </div>

                    <h3>🎯 Latihan Praktis</h3>
                    <p>Sekarang mari kita praktikkan dengan beberapa latihan yang akan memperkuat pemahaman Anda:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>💻 Latihan 1: Membuat Project Baru</h4>
                        <p><strong>Tantangan:</strong> Buat project Go baru dengan nama "my-shop-api" dan install minimal 3 dependencies yang berbeda dari yang sudah kita pelajari.</p>
                        <p><strong>Langkah:</strong></p>
                        <ol>
                            <li>Buat direktori baru</li>
                            <li>Inisialisasi Go module</li>
                            <li>Install 3 dependencies baru (bisa dari <a href="https://pkg.go.dev/" target="_blank">pkg.go.dev</a>)</li>
                            <li>Verifikasi file go.mod dan go.sum</li>
                        </ol>
                    </div>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>🏗️ Latihan 2: Merancang Struktur Folder</h4>
                        <p><strong>Tantangan:</strong> Rancang struktur folder untuk aplikasi "blog-api" yang memiliki fitur artikel, komentar, dan user management.</p>
                        <p><strong>Pertimbangkan:</strong></p>
                        <ul>
                            <li>Berapa banyak folder yang dibutuhkan?</li>
                            <li>Bagaimana dependency flow-nya?</li>
                            <li>File apa saja yang ada di setiap folder?</li>
                        </ul>
                    </div>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>⚙️ Latihan 3: Konfigurasi Environment</h4>
                        <p><strong>Tantangan:</strong> Buat file .env untuk aplikasi production dengan konfigurasi yang aman.</p>
                        <p><strong>Include:</strong></p>
                        <ul>
                            <li>Database configuration (production)</li>
                            <li>Server configuration</li>
                            <li>Security keys</li>
                            <li>External API keys</li>
                        </ul>
                    </div>

                    <h3>🧠 Teknik Memori untuk Developer</h3>
                    <p>Sebagai bonus, berikut beberapa teknik yang bisa membantu Anda mengingat konsep-konsep programming:</p>

                    <h4>🔗 Association Technique</h4>
                    <p>Hubungkan konsep baru dengan yang sudah familiar:</p>
                    <ul>
                        <li><strong>Go Modules</strong> → seperti <strong>package.json</strong> di Node.js</li>
                        <li><strong>GORM</strong> → seperti <strong>Eloquent</strong> di Laravel</li>
                        <li><strong>Gin Framework</strong> → seperti <strong>Express.js</strong> di Node.js</li>
                        <li><strong>Environment Variables</strong> → seperti <strong>config files</strong> di framework lain</li>
                    </ul>

                    <h4>🎯 Spaced Repetition</h4>
                    <p>Jadwal review yang optimal:</p>
                    <ul>
                        <li><strong>Hari 1:</strong> Review setelah 24 jam (sekarang!)</li>
                        <li><strong>Hari 3:</strong> Review singkat konsep utama</li>
                        <li><strong>Minggu 1:</strong> Praktik dengan project kecil</li>
                        <li><strong>Bulan 1:</strong> Implementasi dalam project real</li>
                    </ul>

                    <h4>💡 Active Recall</h4>
                    <p>Coba jawab pertanyaan tanpa melihat materi:</p>
                    <ul>
                        <li>Tutup ebook dan coba jelaskan Go modules</li>
                        <li>Gambarkan struktur folder tanpa melihat</li>
                        <li>List dependencies yang sudah diinstall</li>
                    </ul>

                    <h3>🎉 Refleksi Pembelajaran</h3>
                    <p>Mari kita refleksikan apa yang telah dipelajari:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #2c3e50;">📊 Self-Assessment</h4>
                        <p><strong>Rate pemahaman Anda (1-5):</strong></p>
                        <ul style="color: #495057;">
                            <li>Go Modules: ___/5</li>
                            <li>Dependencies Management: ___/5</li>
                            <li>Project Structure: ___/5</li>
                            <li>Database Configuration: ___/5</li>
                        </ul>
                        <p style="color: #495057;"><strong>Area yang perlu diperkuat:</strong> _________________</p>
                    </div>

                    <h3>🚀 Persiapan Bab Selanjutnya</h3>
                    <p>Setelah beristirahat dan review, kita akan melanjutkan ke bab yang lebih menarik:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>🎯 Preview Bab 6: Model & Database Schema</h4>
                        <p>Di bab selanjutnya, kita akan:</p>
                        <ul>
                            <li>✅ Membuat model User dengan GORM</li>
                            <li>✅ Implementasi database schema</li>
                            <li>✅ Validasi data dengan struct tags</li>
                            <li>✅ Relationship antar model</li>
                        </ul>
                    </div>

                    <blockquote style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 1rem; margin: 2rem 0;">
                        <strong>💡 Tips untuk Bab Selanjutnya:</strong> Pastikan Anda sudah memahami konsep struct di Go dan basic database operations. Jika belum, luangkan waktu 10 menit untuk review materi Go fundamentals tentang struct dan interface.
                    </blockquote>

                    <h3>🎊 Selamat!</h3>
                    <p>Anda telah berhasil menyelesaikan review bab 1-4! Otak Anda sekarang telah mengkonsolidasikan pengetahuan tentang Go modules, dependencies, project structure, dan database configuration. Ini adalah fondasi yang kuat untuk melanjutkan perjalanan pengembangan API.</p>

                  
                `
            },
            {
                id: 'chapter6',
                title: 'Bab 6: Modul Authentication - Register',
                meta: 'Halaman 6 dari 50 • Dibaca 8 menit',
                content: `
                    <h2>🔐 Bab 6: Modul Authentication - Register</h2>
                    <p>Selamat! Sekarang kita akan mulai membangun fitur authentication yang merupakan fondasi keamanan untuk API toko online. Kita akan mulai dengan modul Register terlebih dahulu, kemudian dilanjutkan dengan Login dan Logout di bab-bab selanjutnya.</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">🎯 Apa yang Akan Kita Buat di Bab Ini?</h3>
                        <p style="color: #495057; margin-bottom: 0;">Kita akan membuat sistem register user baru dengan validasi, password hashing, dan JWT token generation. Setelah selesai, kita akan test menggunakan Postman.</p>
                    </div>

                    <h3>📋 Database Schema User</h3>
                    <p>Berikut adalah struktur database untuk user:</p>

                    <pre><code>CREATE TABLE user (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    role ENUM('customer', 'admin') DEFAULT 'customer',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL
);</code></pre>

                    <h3>🏗️ Struktur File yang Akan Kita Buat</h3>
                    <p>Kita akan mengikuti struktur pattern folder yang sudah ada. Berikut file-file yang akan kita buat:</p>

                    <pre><code>tokogo/
├── models/
│   └── user.go                    # User model struct
├── requests/
│   └── auth_request.go           # Request structs untuk auth
├── responses/
│   └── auth_response.go          # Response structs untuk auth
├── repositories/
│   └── auth_repository.go        # Database operations
├── services/
│   └── auth_service.go           # Business logic
├── handlers/
│   └── auth_handler.go           # HTTP handlers
├── helpers/
│   └── jwt.go                    # JWT helper functions
└── middlewares/
    └── auth.go                   # Authentication middleware</code></pre>

                    <h3>📝 Langkah 1: Membuat User Model</h3>
                    <p>Pertama, kita buat model User di file <code>models/user.go</code>:</p>

                    <pre><code>package models

import (
    "time"
    "gorm.io/gorm"
)

type User struct {
    ID        uint           \`gorm:"primaryKey;column:id;type:BIGINT UNSIGNED AUTO_INCREMENT" json:"id"\`
    Name      string         \`gorm:"column:name;type:VARCHAR(255);not null" json:"name"\`
    Email     string         \`gorm:"column:email;type:VARCHAR(255);uniqueIndex;not null" json:"email"\`
    Password  string         \`gorm:"column:password;type:VARCHAR(255);not null" json:"-"\` // Hidden dari JSON response
    Role      string         \`gorm:"column:role;type:ENUM('customer','admin');default:'customer'" json:"role"\`
    CreatedAt time.Time      \`gorm:"column:created_at;type:TIMESTAMP DEFAULT CURRENT_TIMESTAMP" json:"created_at"\`
    UpdatedAt time.Time      \`gorm:"column:updated_at;type:TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP" json:"updated_at"\`
    DeletedAt gorm.DeletedAt \`gorm:"column:deleted_at;type:TIMESTAMP NULL;index" json:"-"\`
}

// TableName mengembalikan nama tabel untuk model User
func (User) TableName() string {
    return "user"
}</code></pre>

                    <h4>Penjelasan Model User:</h4>
                    <ul>
                        <li><strong>ID:</strong> Primary key dengan auto increment</li>
                        <li><strong>Name:</strong> Nama user (required)</li>
                        <li><strong>Email:</strong> Email unik (required)</li>
                        <li><strong>Password:</strong> Password yang di-hash (hidden dari JSON)</li>
                        <li><strong>Role:</strong> Enum dengan nilai 'customer' atau 'admin'</li>
                        <li><strong>Timestamps:</strong> created_at, updated_at, deleted_at</li>
                    </ul>

                    <h3>📝 Langkah 2: Membuat Request Struct untuk Register</h3>
                    <p>Buat file <code>requests/auth_request.go</code> untuk validasi input register:</p>

                    <pre><code>package requests

import (
    "errors"
    "github.com/go-playground/validator/v10"
)

// RegisterRequest represents the request structure for user registration
type RegisterRequest struct {
    Username        string \`json:"username" validate:"required,min=3,max=50"\`
    Email           string \`json:"email" validate:"required,email"\`
    Password        string \`json:"password" validate:"required,min=6"\`
    ConfirmPassword string \`json:"confirm_password" validate:"required,min=6"\`
}

// Validate validates the RegisterRequest using the validator
func (r *RegisterRequest) Validate() error {
    validate := validator.New()
    
    // Validasi struct fields
    if err := validate.Struct(r); err != nil {
        return err
    }
    
    // Validasi custom: password dan confirm_password harus sama
    if r.Password != r.ConfirmPassword {
        return errors.New("password and confirm_password must match")
    }
    
    return nil
}</code></pre>

                    <h4>Penjelasan RegisterRequest:</h4>
                    <ul>
                        <li><strong>Username:</strong> Nama pengguna dengan validasi min 3, max 50 karakter</li>
                        <li><strong>Email:</strong> Email dengan format yang valid</li>
                        <li><strong>Password:</strong> Password minimal 6 karakter</li>
                        <li><strong>ConfirmPassword:</strong> Konfirmasi password yang harus sama dengan password</li>
                        <li><strong>Validate():</strong> Method untuk memvalidasi struct dan memastikan password sama dengan confirm_password</li>
                    </ul>

                    <h4>Validasi yang Digunakan:</h4>
                    <ul>
                        <li><strong>required:</strong> Field wajib diisi</li>
                        <li><strong>email:</strong> Format email yang valid</li>
                        <li><strong>min=3,max=50:</strong> Username minimal 3, maksimal 50 karakter</li>
                        <li><strong>min=6:</strong> Password dan ConfirmPassword minimal 6 karakter</li>
                        <li><strong>Custom Validation:</strong> Password dan ConfirmPassword harus sama</li>
                    </ul>

                    <h3>📝 Langkah 3: Membuat Response Struct untuk Register</h3>
                    <p>Buat file <code>responses/auth_response.go</code> untuk format response register:</p>

                    <pre><code>package responses

import "tokogo/models"

// RegisterResponse struct untuk response register
type RegisterResponse struct {
    User  UserResponse \`json:"user"\`
    Token string       \`json:"token"\`
}

// UserResponse struct untuk response user (tanpa password)
type UserResponse struct {
    ID        uint   \`json:"id"\`
    Name      string \`json:"name"\`
    Email     string \`json:"email"\`
    Role      string \`json:"role"\`
    CreatedAt string \`json:"created_at"\`
}

// ErrorResponse struct untuk response error
type ErrorResponse struct {
    Error   string \`json:"error"\`
    Message string \`json:"message"\`
}

// SuccessResponse struct untuk response sukses
type SuccessResponse struct {
    Message string      \`json:"message"\`
    Data    interface{} \`json:"data,omitempty"\`
}

// ConvertUserToResponse mengkonversi User model ke UserResponse
func ConvertUserToResponse(user models.User) UserResponse {
    return UserResponse{
        ID:        user.ID,
        Name:      user.Name,
        Email:     user.Email,
        Role:      user.Role,
        CreatedAt: user.CreatedAt.Format("2006-01-02 15:04:05"),
    }
}</code></pre>

                    <h4>Penjelasan Response Structs:</h4>
                    <ul>
                        <li><strong>RegisterResponse:</strong> Response khusus untuk register yang berisi user data dan JWT token</li>
                        <li><strong>UserResponse:</strong> Data user tanpa password untuk keamanan</li>
                        <li><strong>ErrorResponse:</strong> Format response untuk error</li>
                        <li><strong>SuccessResponse:</strong> Format response untuk sukses</li>
                        <li><strong>ConvertUserToResponse:</strong> Helper function untuk konversi model ke response</li>
                    </ul>

                    <h3>📝 Langkah 4: Membuat JWT Helper untuk Register</h3>
                    <p>Buat file <code>helpers/jwt.go</code> untuk JWT operations:</p>

                    <pre><code>package helpers

import (
    "time"

    "github.com/golang-jwt/jwt"
    "tokogo/models"
)

var jwtSecret = []byte("your-secret-key") // Gunakan dari environment variable

// Claims struct untuk JWT claims
type Claims struct {
    UserID uint   \`json:"user_id"\`
    Email  string \`json:"email"\`
    Role   string \`json:"role"\`
    jwt.StandardClaims
}

// GenerateToken menghasilkan JWT token untuk user
func GenerateToken(user models.User) (string, error) {
    expirationTime := time.Now().Add(24 * time.Hour) // Token berlaku 24 jam
    
    claims := &Claims{
        UserID: user.ID,
        Email:  user.Email,
        Role:   user.Role,
        StandardClaims: jwt.StandardClaims{
            ExpiresAt: expirationTime.Unix(),
            IssuedAt:  time.Now().Unix(),
        },
    }

    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    tokenString, err := token.SignedString(jwtSecret)
    
    if err != nil {
        return "", err
    }

    return tokenString, nil
}</code></pre>

                    <h4>Penjelasan JWT Helper:</h4>
                    <ul>
                        <li><strong>Claims:</strong> Struct yang berisi data user dalam JWT token</li>
                        <li><strong>GenerateToken:</strong> Function untuk membuat JWT token setelah user berhasil register</li>
                        <li><strong>ExpirationTime:</strong> Token berlaku selama 24 jam</li>
                        <li><strong>jwtSecret:</strong> Secret key untuk signing token (sebaiknya dari environment variable)</li>
                    </ul>

                    <h3>📝 Langkah 5: Membuat Auth Repository untuk Register</h3>
                    <p>Buat file <code>repositories/auth_repository.go</code> untuk database operations register:</p>

                    <pre><code>package repositories

import (
    "errors"
    "tokogo/config"
    "tokogo/models"
    "gorm.io/gorm"
)

type AuthRepository struct {
    db *gorm.DB
}

// NewAuthRepository membuat instance baru AuthRepository
func NewAuthRepository() *AuthRepository {
    return &AuthRepository{
        db: config.DB,
    }
}

// CreateUser membuat user baru
func (r *AuthRepository) CreateUser(user *models.User) error {
    return r.db.Create(user).Error
}

// GetUserByEmail mengambil user berdasarkan email (untuk cek duplikasi)
func (r *AuthRepository) GetUserByEmail(email string) (*models.User, error) {
    var user models.User
    err := r.db.Where("email = ?", email).First(&user).Error
    
    if err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, errors.New("user not found")
        }
        return nil, err
    }
    
    return &user, nil
}</code></pre>

                    <h4>Penjelasan Auth Repository:</h4>
                    <ul>
                        <li><strong>CreateUser:</strong> Function untuk menyimpan user baru ke database</li>
                        <li><strong>GetUserByEmail:</strong> Function untuk mengecek apakah email sudah terdaftar</li>
                        <li><strong>NewAuthRepository:</strong> Constructor untuk membuat instance repository</li>
                        <li><strong>Error Handling:</strong> Menangani error jika user tidak ditemukan</li>
                    </ul>

                    <h3>📝 Langkah 6: Membuat Auth Service untuk Register</h3>
                    <p>Buat file <code>services/auth_service.go</code> untuk business logic register:</p>

                    <pre><code>package services

import (
    "errors"
    "tokogo/helpers"
    "tokogo/models"
    "tokogo/repositories"
    "tokogo/requests"
    "tokogo/responses"
    "golang.org/x/crypto/bcrypt"
)

type AuthService struct {
    authRepo *repositories.AuthRepository
}

// NewAuthService membuat instance baru AuthService
func NewAuthService() *AuthService {
    return &AuthService{
        authRepo: repositories.NewAuthRepository(),
    }
}

// Register mendaftarkan user baru
func (s *AuthService) Register(req requests.RegisterRequest) (*responses.RegisterResponse, error) {
    // Cek apakah email sudah terdaftar
    existingUser, _ := s.authRepo.GetUserByEmail(req.Email)
    if existingUser != nil {
        return nil, errors.New("email already registered")
    }

    // Hash password
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
    if err != nil {
        return nil, errors.New("failed to hash password")
    }

    // Buat user baru
    user := &models.User{
        Name:     req.Username, // Menggunakan Username dari request
        Email:    req.Email,
        Password: string(hashedPassword),
        Role:     "customer", // Default role
    }

    // Simpan ke database
    if err := s.authRepo.CreateUser(user); err != nil {
        return nil, errors.New("failed to create user")
    }

    // Generate JWT token
    token, err := helpers.GenerateToken(*user)
    if err != nil {
        return nil, errors.New("failed to generate token")
    }

    // Return response
    return &responses.RegisterResponse{
        User:  responses.ConvertUserToResponse(*user),
        Token: token,
    }, nil
}</code></pre>

                    <h4>Penjelasan Auth Service Register:</h4>
                    <ul>
                        <li><strong>Register Function:</strong> Business logic untuk registrasi user baru</li>
                        <li><strong>Email Check:</strong> Mengecek apakah email sudah terdaftar</li>
                        <li><strong>Password Hashing:</strong> Menggunakan bcrypt untuk hash password</li>
                        <li><strong>User Creation:</strong> Membuat user baru dengan role default "customer"</li>
                        <li><strong>JWT Generation:</strong> Membuat JWT token setelah user berhasil dibuat</li>
                        <li><strong>Response:</strong> Mengembalikan user data dan token</li>
                    </ul>

                    <h3>📝 Langkah 7: Membuat Auth Handler untuk Register</h3>
                    <p>Buat file <code>handlers/auth_handler.go</code> untuk HTTP handler register:</p>

                    <pre><code>package handlers

import (
    "net/http"
    "tokogo/requests"
    "tokogo/responses"
    "tokogo/services"
    "github.com/gin-gonic/gin"
)

type AuthHandler struct {
    authService *services.AuthService
}

// NewAuthHandler membuat instance baru AuthHandler
func NewAuthHandler() *AuthHandler {
    return &AuthHandler{
        authService: services.NewAuthService(),
    }
}

// Register handler untuk registrasi user baru
func (h *AuthHandler) Register(c *gin.Context) {
    var req requests.RegisterRequest
    
    // Bind dan validasi request
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Validasi menggunakan method Validate()
    if err := req.Validate(); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Panggil service untuk register
    registerResponse, err := h.authService.Register(req)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "register_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusCreated, responses.SuccessResponse{
        Message: "User registered successfully",
        Data:    registerResponse,
    })
}</code></pre>

                    <h4>Penjelasan Auth Handler Register:</h4>
                    <ul>
                        <li><strong>Register Function:</strong> HTTP handler untuk endpoint register</li>
                        <li><strong>ShouldBindJSON:</strong> Binding JSON request ke struct</li>
                        <li><strong>Validate():</strong> Validasi menggunakan go-playground/validator</li>
                        <li><strong>Service Call:</strong> Memanggil business logic di service layer</li>
                        <li><strong>Response:</strong> Mengembalikan response sukses atau error</li>
                        <li><strong>Status Code:</strong> 201 Created untuk sukses, 400 Bad Request untuk error</li>
                    </ul>

                    <h3>📝 Langkah 8: Update Main.go untuk Register</h3>
                    <p>Update file <code>main.go</code> untuk setup route register:</p>

                    <pre><code>package main

import (
    "log"
    "tokogo/config"
    "tokogo/handlers"
    "github.com/gin-contrib/cors"
    "github.com/gin-gonic/gin"
    "github.com/joho/godotenv"
)

func main() {
    // Load environment variables
    if err := godotenv.Load(); err != nil {
        log.Println("No .env file found, using system environment variables")
    }

    // Initialize database
    config.InitDB()

    // Setup Gin router
    r := gin.Default()

    // CORS middleware
    r.Use(cors.New(cors.Config{
        AllowOrigins:     []string{"*"},
        AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
        AllowHeaders:     []string{"*"},
        ExposeHeaders:    []string{"Content-Length"},
        AllowCredentials: true,
    }))

    // Initialize handlers
    authHandler := handlers.NewAuthHandler()

    // Public routes (tidak perlu authentication)
    api := r.Group("/api/v1")
    {
        // Auth routes
        auth := api.Group("/auth")
        {
            auth.POST("/register", authHandler.Register)
        }
    }

    // Start server
    port := config.GetEnv("SERVER_PORT", "8080")
    log.Printf("Server starting on port %s", port)
    r.Run(":" + port)
}</code></pre>

                    <h4>Penjelasan Main.go:</h4>
                    <ul>
                        <li><strong>Database Init:</strong> Menginisialisasi koneksi database</li>
                        <li><strong>CORS Setup:</strong> Konfigurasi CORS untuk frontend</li>
                        <li><strong>Route Setup:</strong> Setup route untuk register endpoint</li>
                        <li><strong>Server Start:</strong> Menjalankan server di port yang ditentukan</li>
                    </ul>

                    <h3>📝 Langkah 9: Update Database Configuration</h3>
                    <p>Update file <code>config/database.go</code> untuk include User model:</p>

                    <pre><code>// Auto migrate model User
if err := DB.AutoMigrate(&models.User{}); err != nil {
    panic(fmt.Sprintf("AutoMigrate failed: %v", err))
}</code></pre>

                    <h4>Penjelasan Database Configuration:</h4>
                    <ul>
                        <li><strong>AutoMigrate:</strong> Otomatis membuat/update table user berdasarkan model</li>
                        <li><strong>Error Handling:</strong> Panic jika migration gagal</li>
                    </ul>

                    <h3>🧪 Testing API Register</h3>
                    <p>Sekarang mari kita test API register yang sudah kita buat:</p>

                    <h4>1. Register User Baru</h4>
                    <pre><code>POST http://localhost:8080/api/v1/auth/register
Content-Type: application/json

{
    "username": "johndoe",
    "email": "john@example.com",
    "password": "password123",
    "confirm_password": "password123"
}</code></pre>

                    <h4>Response Sukses (201 Created):</h4>
                    <pre><code>{
    "message": "User registered successfully",
    "data": {
        "user": {
            "id": 1,
            "name": "johndoe",
            "email": "john@example.com",
            "role": "customer",
            "created_at": "2024-01-15 10:30:00"
        },
        "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
    }
}</code></pre>

                    <h4>Response Error (400 Bad Request):</h4>
                    <pre><code>{
    "error": "validation_error",
    "message": "Key: 'RegisterRequest.Email' Error:Field validation for 'Email' failed on the 'email' tag"
}</code></pre>

                    <h4>Response Error - Password Tidak Sama:</h4>
                    <pre><code>{
    "error": "validation_error",
    "message": "password and confirm_password must match"
}</code></pre>

                    <h4>Response Error - Email Sudah Terdaftar:</h4>
                    <pre><code>{
    "error": "register_failed",
    "message": "email already registered"
}</code></pre>

                    <h3>🔧 Environment Variables</h3>
                    <p>Pastikan file <code>.env</code> Anda memiliki konfigurasi berikut:</p>

                    <pre><code># Database Configuration
DB_HOST=localhost
DB_PORT=3306
DB_USER=root
DB_PASSWORD=
DB_NAME=tokogo

# Server Configuration
SERVER_PORT=8080
JWT_SECRET=your-super-secret-jwt-key-here

# Environment
ENV=development</code></pre>

                    <h3>📦 Dependencies yang Dibutuhkan</h3>
                    <p>Pastikan Anda sudah menginstall dependencies berikut:</p>

                    <pre><code>go get golang.org/x/crypto/bcrypt</code></pre>

                    <h3>✅ Checklist Implementasi Register</h3>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>File yang Harus Dibuat:</h4>
                        <ul>
                            <li>✅ models/user.go</li>
                            <li>✅ requests/auth_request.go (RegisterRequest)</li>
                            <li>✅ responses/auth_response.go (RegisterResponse)</li>
                            <li>✅ helpers/jwt.go (GenerateToken)</li>
                            <li>✅ repositories/auth_repository.go (CreateUser, GetUserByEmail)</li>
                            <li>✅ services/auth_service.go (Register)</li>
                            <li>✅ handlers/auth_handler.go (Register)</li>
                        </ul>
                        
                        <h4>File yang Harus Diupdate:</h4>
                        <ul>
                            <li>✅ config/database.go (AutoMigrate User)</li>
                            <li>✅ main.go (Register route)</li>
                            <li>✅ .env (JWT_SECRET)</li>
                        </ul>
                    </div>

                    <h3>🚀 Cara Menjalankan</h3>
                    <ol>
                        <li>Pastikan MySQL sudah berjalan</li>
                        <li>Pastikan database 'tokogo' sudah dibuat</li>
                        <li>Jalankan: <code>go run main.go</code></li>
                        <li>Test dengan Postman atau curl</li>
                    </ol>

                    <h3>🎯 Fitur Register yang Sudah Diimplementasikan</h3>
                    <ul>
                        <li>✅ User Registration dengan validasi</li>
                        <li>✅ Password hashing dengan bcrypt</li>
                        <li>✅ JWT token generation</li>
                        <li>✅ Email uniqueness check</li>
                        <li>✅ Input validation dengan go-playground/validator</li>
                        <li>✅ Error handling yang proper</li>
                        <li>✅ Response format yang konsisten</li>
                    </ul>

                    <h3>🔒 Keamanan yang Sudah Diimplementasikan</h3>
                    <ul>
                        <li>✅ Password hashing dengan bcrypt</li>
                        <li>✅ JWT token dengan expiration</li>
                        <li>✅ Input validation dengan go-playground/validator</li>
                        <li>✅ SQL injection protection (GORM)</li>
                        <li>✅ CORS configuration</li>
                        <li>✅ Environment variables untuk secret keys</li>
                    </ul>

                    <h3>🎉 Selamat!</h3>
                    <p>Anda telah berhasil mengimplementasikan modul Register yang lengkap! Sistem register sudah siap untuk digunakan dan dapat diintegrasikan dengan frontend aplikasi.</p>

                    <div style="text-align: center; margin: 3rem 0;">
                        <div style="background: #f8f9fa; border: 1px solid #dee2e6; color: #2c3e50; padding: 2rem; border-radius: 5px; display: inline-block;">
                            <h3 style="color: #2c3e50; margin-bottom: 1rem;">🎯 Siap untuk Bab Selanjutnya?</h3>
                            <p style="color: #495057; margin-bottom: 0;">Di bab selanjutnya, kita akan membuat modul Login untuk melengkapi sistem authentication!</p>
                        </div>
                    </div>
                `
            },
            {
                id: 'chapter7',
                title: 'Bab 7: Modul Authentication - Login',
                meta: 'Halaman 7 dari 50 • Dibaca 8 menit',
                content: `
                    <h2>🔐 Bab 7: Modul Authentication - Login</h2>
                    <p>Selamat! Sekarang kita akan melanjutkan dengan modul Login untuk melengkapi sistem authentication. Di bab ini, kita akan mengimplementasikan fitur login user yang sudah terdaftar dengan validasi email dan password.</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">🎯 Apa yang Akan Kita Buat di Bab Ini?</h3>
                        <p style="color: #495057; margin-bottom: 0;">Kita akan membuat sistem login user dengan validasi email/password, password verification, dan JWT token generation. Setelah selesai, kita akan test menggunakan Postman.</p>
                    </div>

                    <h3>📋 Prasyarat</h3>
                    <p>Sebelum memulai, pastikan Anda sudah menyelesaikan:</p>
                    <ul>
                        <li>✅ Bab 6: Modul Authentication - Register</li>
                        <li>✅ User sudah terdaftar di database</li>
                        <li>✅ File-file authentication sudah dibuat</li>
                    </ul>

                    <h3>📝 Langkah 1: Update Request Struct untuk Login</h3>
                    <p>Update file <code>requests/auth_request.go</code> untuk menambahkan LoginRequest:</p>

                    <pre><code>package requests

import "github.com/go-playground/validator/v10"

// RegisterRequest represents the request structure for user registration
type RegisterRequest struct {
    Username string \`json:"username" validate:"required,min=3,max=50"\`
    Email    string \`json:"email" validate:"required,email"\`
    Password string \`json:"password" validate:"required,min=6"\`
}

// LoginRequest represents the request structure for user login
type LoginRequest struct {
    Email    string \`json:"email" validate:"required,email"\`
    Password string \`json:"password" validate:"required"\`
}

// Validate validates the RegisterRequest using the validator
func (r *RegisterRequest) Validate() error {
    validate := validator.New()
    return validate.Struct(r)
}

// Validate validates the LoginRequest using the validator
func (r *LoginRequest) Validate() error {
    validate := validator.New()
    return validate.Struct(r)
}</code></pre>

                    <h4>Penjelasan LoginRequest:</h4>
                    <ul>
                        <li><strong>Email:</strong> Email user yang akan login (required, format email valid)</li>
                        <li><strong>Password:</strong> Password user (required)</li>
                        <li><strong>Validate():</strong> Method untuk memvalidasi struct LoginRequest</li>
                    </ul>

                    <h3>📝 Langkah 2: Update Response Struct untuk Login</h3>
                    <p>Update file <code>responses/auth_response.go</code> untuk menambahkan LoginResponse:</p>

                    <pre><code>package responses

import "tokogo/models"

// RegisterResponse struct untuk response register
type RegisterResponse struct {
    User  UserResponse \`json:"user"\`
    Token string       \`json:"token"\`
}

// LoginResponse struct untuk response login
type LoginResponse struct {
    User  UserResponse \`json:"user"\`
    Token string       \`json:"token"\`
}

// UserResponse struct untuk response user (tanpa password)
type UserResponse struct {
    ID        uint   \`json:"id"\`
    Name      string \`json:"name"\`
    Email     string \`json:"email"\`
    Role      string \`json:"role"\`
    CreatedAt string \`json:"created_at"\`
}

// ErrorResponse struct untuk response error
type ErrorResponse struct {
    Error   string \`json:"error"\`
    Message string \`json:"message"\`
}

// SuccessResponse struct untuk response sukses
type SuccessResponse struct {
    Message string      \`json:"message"\`
    Data    interface{} \`json:"data,omitempty"\`
}

// ConvertUserToResponse mengkonversi User model ke UserResponse
func ConvertUserToResponse(user models.User) UserResponse {
    return UserResponse{
        ID:        user.ID,
        Name:      user.Name,
        Email:     user.Email,
        Role:      user.Role,
        CreatedAt: user.CreatedAt.Format("2006-01-02 15:04:05"),
    }
}</code></pre>

                    <h4>Penjelasan LoginResponse:</h4>
                    <ul>
                        <li><strong>LoginResponse:</strong> Response khusus untuk login yang berisi user data dan JWT token</li>
                        <li><strong>User:</strong> Data user tanpa password untuk keamanan</li>
                        <li><strong>Token:</strong> JWT token untuk authentication</li>
                    </ul>

                    <h3>📝 Langkah 3: Update JWT Helper untuk Login</h3>
                    <p>Update file <code>helpers/jwt.go</code> untuk menambahkan ValidateToken:</p>

                    <pre><code>package helpers

import (
    "errors"
    "time"

    "github.com/golang-jwt/jwt"
    "tokogo/models"
)

var jwtSecret = []byte("your-secret-key") // Gunakan dari environment variable

// Claims struct untuk JWT claims
type Claims struct {
    UserID uint   \`json:"user_id"\`
    Email  string \`json:"email"\`
    Role   string \`json:"role"\`
    jwt.StandardClaims
}

// GenerateToken menghasilkan JWT token untuk user
func GenerateToken(user models.User) (string, error) {
    expirationTime := time.Now().Add(24 * time.Hour) // Token berlaku 24 jam
    
    claims := &Claims{
        UserID: user.ID,
        Email:  user.Email,
        Role:   user.Role,
        StandardClaims: jwt.StandardClaims{
            ExpiresAt: expirationTime.Unix(),
            IssuedAt:  time.Now().Unix(),
        },
    }

    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    tokenString, err := token.SignedString(jwtSecret)
    
    if err != nil {
        return "", err
    }

    return tokenString, nil
}

// ValidateToken memvalidasi JWT token
func ValidateToken(tokenString string) (*Claims, error) {
    claims := &Claims{}

    token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
        return jwtSecret, nil
    })

    if err != nil {
        return nil, err
    }

    if !token.Valid {
        return nil, errors.New("invalid token")
    }

    return claims, nil
}</code></pre>

                    <h4>Penjelasan ValidateToken:</h4>
                    <ul>
                        <li><strong>ValidateToken:</strong> Function untuk memvalidasi JWT token yang akan digunakan di middleware</li>
                        <li><strong>Claims:</strong> Mengembalikan data user dari token</li>
                        <li><strong>Error Handling:</strong> Menangani token yang invalid atau expired</li>
                    </ul>

                    <h3>📝 Langkah 4: Update Auth Service untuk Login</h3>
                    <p>Update file <code>services/auth_service.go</code> untuk menambahkan Login function:</p>

                    <pre><code>package services

import (
    "errors"
    "tokogo/helpers"
    "tokogo/models"
    "tokogo/repositories"
    "tokogo/requests"
    "tokogo/responses"
    "golang.org/x/crypto/bcrypt"
)

type AuthService struct {
    authRepo *repositories.AuthRepository
}

// NewAuthService membuat instance baru AuthService
func NewAuthService() *AuthService {
    return &AuthService{
        authRepo: repositories.NewAuthRepository(),
    }
}

// Register mendaftarkan user baru
func (s *AuthService) Register(req requests.RegisterRequest) (*responses.RegisterResponse, error) {
    // Cek apakah email sudah terdaftar
    existingUser, _ := s.authRepo.GetUserByEmail(req.Email)
    if existingUser != nil {
        return nil, errors.New("email already registered")
    }

    // Hash password
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
    if err != nil {
        return nil, errors.New("failed to hash password")
    }

    // Buat user baru
    user := &models.User{
        Name:     req.Username, // Menggunakan Username dari request
        Email:    req.Email,
        Password: string(hashedPassword),
        Role:     "customer", // Default role
    }

    // Simpan ke database
    if err := s.authRepo.CreateUser(user); err != nil {
        return nil, errors.New("failed to create user")
    }

    // Generate JWT token
    token, err := helpers.GenerateToken(*user)
    if err != nil {
        return nil, errors.New("failed to generate token")
    }

    // Return response
    return &responses.RegisterResponse{
        User:  responses.ConvertUserToResponse(*user),
        Token: token,
    }, nil
}

// Login melakukan login user
func (s *AuthService) Login(req requests.LoginRequest) (*responses.LoginResponse, error) {
    // Cari user berdasarkan email
    user, err := s.authRepo.GetUserByEmail(req.Email)
    if err != nil {
        return nil, errors.New("invalid email or password")
    }

    // Verifikasi password
    err = bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(req.Password))
    if err != nil {
        return nil, errors.New("invalid email or password")
    }

    // Generate JWT token
    token, err := helpers.GenerateToken(*user)
    if err != nil {
        return nil, errors.New("failed to generate token")
    }

    // Return response
    return &responses.LoginResponse{
        User:  responses.ConvertUserToResponse(*user),
        Token: token,
    }, nil
}</code></pre>

                    <h4>Penjelasan Login Function:</h4>
                    <ul>
                        <li><strong>Email Lookup:</strong> Mencari user berdasarkan email</li>
                        <li><strong>Password Verification:</strong> Membandingkan password dengan bcrypt</li>
                        <li><strong>JWT Generation:</strong> Membuat JWT token setelah login sukses</li>
                        <li><strong>Error Handling:</strong> Mengembalikan error yang sama untuk keamanan</li>
                    </ul>

                    <h3>📝 Langkah 5: Update Auth Handler untuk Login</h3>
                    <p>Update file <code>handlers/auth_handler.go</code> untuk menambahkan Login handler:</p>

                    <pre><code>package handlers

import (
    "net/http"
    "tokogo/requests"
    "tokogo/responses"
    "tokogo/services"

    "github.com/gin-gonic/gin"
)

type AuthHandler struct {
    authService *services.AuthService
}

// NewAuthHandler membuat instance baru AuthHandler
func NewAuthHandler() *AuthHandler {
    return &AuthHandler{
        authService: services.NewAuthService(),
    }
}

// Register handler untuk registrasi user baru
func (h *AuthHandler) Register(c *gin.Context) {
    var req requests.RegisterRequest

    // Bind dan validasi request
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Validasi menggunakan method Validate()
    if err := req.Validate(); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Panggil service untuk register
    registerResponse, err := h.authService.Register(req)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "register_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusCreated, responses.SuccessResponse{
        Message: "User registered successfully",
        Data:    registerResponse,
    })
}

// Login handler untuk login user
func (h *AuthHandler) Login(c *gin.Context) {
    var req requests.LoginRequest

    // Bind dan validasi request
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Validasi menggunakan method Validate()
    if err := req.Validate(); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Panggil service untuk login
    loginResponse, err := h.authService.Login(req)
    if err != nil {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "login_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Login successful",
        Data:    loginResponse,
    })
}</code></pre>

                    <h4>Penjelasan Login Handler:</h4>
                    <ul>
                        <li><strong>Login Function:</strong> HTTP handler untuk endpoint login</li>
                        <li><strong>Request Binding:</strong> Binding JSON request ke LoginRequest struct</li>
                        <li><strong>Validation:</strong> Validasi menggunakan go-playground/validator</li>
                        <li><strong>Service Call:</strong> Memanggil business logic di service layer</li>
                        <li><strong>Status Code:</strong> 200 OK untuk sukses, 401 Unauthorized untuk error</li>
                    </ul>

                    <h3>📝 Langkah 6: Update Main.go untuk Login</h3>
                    <p>Update file <code>main.go</code> untuk menambahkan route login:</p>

                    <pre><code>package main

import (
    "log"
    "tokogo/config"
    "tokogo/handlers"

    "github.com/gin-contrib/cors"
    "github.com/gin-gonic/gin"
    "github.com/joho/godotenv"
)

func main() {
    // Load environment variables
    if err := godotenv.Load(); err != nil {
        log.Println("No .env file found, using system environment variables")
    }

    // Initialize database
    config.InitDB()

    // Setup Gin router
    r := gin.Default()

    // CORS middleware
    r.Use(cors.New(cors.Config{
        AllowOrigins:     []string{"*"},
        AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
        AllowHeaders:     []string{"*"},
        ExposeHeaders:    []string{"Content-Length"},
        AllowCredentials: true,
    }))

    // Initialize handlers
    authHandler := handlers.NewAuthHandler()

    // Public routes (tidak perlu authentication)
    api := r.Group("/api/v1")
    {
        // Auth routes
        auth := api.Group("/auth")
        {
            auth.POST("/register", authHandler.Register)
            auth.POST("/login", authHandler.Login)
        }
    }

    // Start server
    port := config.GetEnv("SERVER_PORT", "8080")
    log.Printf("Server starting on port %s", port)
    r.Run(":" + port)
}</code></pre>

                    <h4>Penjelasan Main.go Update:</h4>
                    <ul>
                        <li><strong>Login Route:</strong> Menambahkan POST /api/v1/auth/login</li>
                        <li><strong>Handler:</strong> Menggunakan authHandler.Login</li>
                        <li><strong>Public Route:</strong> Login tidak memerlukan authentication</li>
                    </ul>

                    <h3>🧪 Testing API Login</h3>
                    <p>Sekarang mari kita test API login yang sudah kita buat:</p>

                    <h4>1. Login User</h4>
                    <pre><code>POST http://localhost:8080/api/v1/auth/login
Content-Type: application/json

{
    "email": "john@example.com",
    "password": "password123"
}</code></pre>

                    <h4>Response Sukses (200 OK):</h4>
                    <pre><code>{
    "message": "Login successful",
    "data": {
        "user": {
            "id": 1,
            "name": "johndoe",
            "email": "john@example.com",
            "role": "customer",
            "created_at": "2024-01-15 10:30:00"
        },
        "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
    }
}</code></pre>

                    <h4>Response Error - Invalid Credentials (401 Unauthorized):</h4>
                    <pre><code>{
    "error": "login_failed",
    "message": "invalid email or password"
}</code></pre>

                    <h4>Response Error - Validation Error (400 Bad Request):</h4>
                    <pre><code>{
    "error": "validation_error",
    "message": "Key: 'LoginRequest.Email' Error:Field validation for 'Email' failed on the 'email' tag"
}</code></pre>

                    <h3>✅ Checklist Implementasi Login</h3>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>File yang Harus Diupdate:</h4>
                        <ul>
                            <li>✅ requests/auth_request.go (LoginRequest)</li>
                            <li>✅ responses/auth_response.go (LoginResponse)</li>
                            <li>✅ helpers/jwt.go (ValidateToken)</li>
                            <li>✅ services/auth_service.go (Login)</li>
                            <li>✅ handlers/auth_handler.go (Login)</li>
                            <li>✅ main.go (Login route)</li>
                        </ul>
                    </div>

                    <h3>🚀 Cara Menjalankan</h3>
                    <ol>
                        <li>Pastikan MySQL sudah berjalan</li>
                        <li>Pastikan database 'tokogo' sudah dibuat</li>
                        <li>Pastikan ada user yang sudah terdaftar (dari Bab 6)</li>
                        <li>Jalankan: <code>go run main.go</code></li>
                        <li>Test dengan Postman atau curl</li>
                    </ol>

                    <h3>🎯 Fitur Login yang Sudah Diimplementasikan</h3>
                    <ul>
                        <li>✅ User Login dengan validasi email/password</li>
                        <li>✅ Password verification dengan bcrypt</li>
                        <li>✅ JWT token generation setelah login sukses</li>
                        <li>✅ Input validation dengan go-playground/validator</li>
                        <li>✅ Error handling yang proper</li>
                        <li>✅ Response format yang konsisten</li>
                        <li>✅ Security: Error message yang sama untuk keamanan</li>
                    </ul>

                    <h3>🔒 Keamanan yang Diimplementasikan</h3>
                    <ul>
                        <li>✅ Password verification dengan bcrypt</li>
                        <li>✅ JWT token dengan expiration</li>
                        <li>✅ Input validation dengan go-playground/validator</li>
                        <li>✅ SQL injection protection (GORM)</li>
                        <li>✅ CORS configuration</li>
                        <li>✅ Environment variables untuk secret keys</li>
                        <li>✅ Generic error messages untuk keamanan</li>
                    </ul>

                    <h3>🎉 Selamat!</h3>
                    <p>Anda telah berhasil mengimplementasikan modul Login yang lengkap! Sistem login sudah siap untuk digunakan dan dapat diintegrasikan dengan frontend aplikasi.</p>

                    <div style="text-align: center; margin: 3rem 0;">
                        <div style="background: #f8f9fa; border: 1px solid #dee2e6; color: #2c3e50; padding: 2rem; border-radius: 5px; display: inline-block;">
                            <h3 style="color: #2c3e50; margin-bottom: 1rem;">🎯 Siap untuk Bab Selanjutnya?</h3>
                            <p style="color: #495057; margin-bottom: 0;">Di bab selanjutnya, kita akan membuat modul Logout dan middleware authentication untuk melengkapi sistem authentication!</p>
                        </div>
                    </div>
                `
            },
            {
                id: 'chapter8',
                title: 'Bab 8: Modul Authentication - Logout',
                meta: 'Halaman 8 dari 50 • Dibaca 10 menit',
                content: `
                    <h2>🚪 Bab 8: Modul Authentication - Logout</h2>
                    <p>Selamat! Sekarang kita akan menyelesaikan sistem authentication dengan membuat modul Logout dan middleware authentication. Di bab ini, kita akan mengimplementasikan fitur logout user dan middleware untuk melindungi endpoint yang memerlukan authentication.</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">🎯 Apa yang Akan Kita Buat di Bab Ini?</h3>
                        <p style="color: #495057; margin-bottom: 0;">Kita akan membuat sistem logout user, middleware authentication untuk melindungi endpoint, dan endpoint protected yang memerlukan JWT token. Setelah selesai, kita akan test menggunakan Postman.</p>
                    </div>

                    <h3>📋 Prasyarat</h3>
                    <p>Sebelum memulai, pastikan Anda sudah menyelesaikan:</p>
                    <ul>
                        <li>✅ Bab 6: Modul Authentication - Register</li>
                        <li>✅ Bab 7: Modul Authentication - Login</li>
                        <li>✅ User sudah terdaftar dan bisa login</li>
                        <li>✅ JWT token sudah bisa di-generate</li>
                    </ul>

                    <h3>📝 Langkah 1: Buat Middleware Authentication</h3>
                    <p>Buat file <code>middlewares/auth_middleware.go</code> untuk melindungi endpoint yang memerlukan authentication:</p>

                    <pre><code>package middlewares

import (
    "net/http"
    "strings"
    "tokogo/helpers"
    "tokogo/responses"

    "github.com/gin-gonic/gin"
)

// AuthMiddleware middleware untuk memvalidasi JWT token
func AuthMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // Ambil token dari header Authorization
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
                Error:   "unauthorized",
                Message: "Authorization header is required",
            })
            c.Abort()
            return
        }

        // Cek format Bearer token
        tokenParts := strings.Split(authHeader, " ")
        if len(tokenParts) != 2 || tokenParts[0] != "Bearer" {
            c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
                Error:   "unauthorized",
                Message: "Invalid authorization header format",
            })
            c.Abort()
            return
        }

        token := tokenParts[1]

        // Validasi token
        claims, err := helpers.ValidateToken(token)
        if err != nil {
            c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
                Error:   "unauthorized",
                Message: "Invalid or expired token",
            })
            c.Abort()
            return
        }

        // Set user info ke context untuk digunakan di handler
        c.Set("user_id", claims.UserID)
        c.Set("user_email", claims.Email)
        c.Set("user_role", claims.Role)

        c.Next()
    }
}

// AdminMiddleware middleware untuk memvalidasi admin role
func AdminMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // Cek apakah user sudah login (AuthMiddleware harus dipanggil dulu)
        userRole, exists := c.Get("user_role")
        if !exists {
            c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
                Error:   "unauthorized",
                Message: "User not authenticated",
            })
            c.Abort()
            return
        }

        // Cek apakah user adalah admin
        if userRole != "admin" {
            c.JSON(http.StatusForbidden, responses.ErrorResponse{
                Error:   "forbidden",
                Message: "Admin access required",
            })
            c.Abort()
            return
        }

        c.Next()
    }
}</code></pre>

                    <h4>Penjelasan Middleware:</h4>
                    <ul>
                        <li><strong>AuthMiddleware:</strong> Memvalidasi JWT token dan set user info ke context</li>
                        <li><strong>AdminMiddleware:</strong> Memvalidasi apakah user memiliki role admin</li>
                        <li><strong>Authorization Header:</strong> Menggunakan format "Bearer {token}"</li>
                        <li><strong>Context:</strong> Menyimpan user info untuk digunakan di handler</li>
                    </ul>

                    <h3>📝 Langkah 2: Update Auth Service untuk Logout</h3>
                    <p>Update file <code>services/auth_service.go</code> untuk menambahkan Logout function:</p>

                    <pre><code>package services

import (
    "errors"
    "tokogo/helpers"
    "tokogo/models"
    "tokogo/repositories"
    "tokogo/requests"
    "tokogo/responses"
    "golang.org/x/crypto/bcrypt"
)

type AuthService struct {
    authRepo *repositories.AuthRepository
}

// NewAuthService membuat instance baru AuthService
func NewAuthService() *AuthService {
    return &AuthService{
        authRepo: repositories.NewAuthRepository(),
    }
}

// Register mendaftarkan user baru
func (s *AuthService) Register(req requests.RegisterRequest) (*responses.RegisterResponse, error) {
    // Cek apakah email sudah terdaftar
    existingUser, _ := s.authRepo.GetUserByEmail(req.Email)
    if existingUser != nil {
        return nil, errors.New("email already registered")
    }

    // Hash password
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
    if err != nil {
        return nil, errors.New("failed to hash password")
    }

    // Buat user baru
    user := &models.User{
        Name:     req.Username, // Menggunakan Username dari request
        Email:    req.Email,
        Password: string(hashedPassword),
        Role:     "customer", // Default role
    }

    // Simpan ke database
    if err := s.authRepo.CreateUser(user); err != nil {
        return nil, errors.New("failed to create user")
    }

    // Generate JWT token
    token, err := helpers.GenerateToken(*user)
    if err != nil {
        return nil, errors.New("failed to generate token")
    }

    // Return response
    return &responses.RegisterResponse{
        User:  responses.ConvertUserToResponse(*user),
        Token: token,
    }, nil
}

// Login melakukan login user
func (s *AuthService) Login(req requests.LoginRequest) (*responses.LoginResponse, error) {
    // Cari user berdasarkan email
    user, err := s.authRepo.GetUserByEmail(req.Email)
    if err != nil {
        return nil, errors.New("invalid email or password")
    }

    // Verifikasi password
    err = bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(req.Password))
    if err != nil {
        return nil, errors.New("invalid email or password")
    }

    // Generate JWT token
    token, err := helpers.GenerateToken(*user)
    if err != nil {
        return nil, errors.New("failed to generate token")
    }

    // Return response
    return &responses.LoginResponse{
        User:  responses.ConvertUserToResponse(*user),
        Token: token,
    }, nil
}

// Logout melakukan logout user (client-side token removal)
func (s *AuthService) Logout(userID uint) (*responses.LogoutResponse, error) {
    // Untuk stateless JWT, logout dilakukan di client side
    // Server hanya memberikan response sukses
    // Di production, bisa implementasi token blacklist jika diperlukan
    
    return &responses.LogoutResponse{
        Message: "Logout successful",
    }, nil
}

// GetProfile mengambil profile user berdasarkan ID
func (s *AuthService) GetProfile(userID uint) (*responses.UserResponse, error) {
    user, err := s.authRepo.GetUserByID(userID)
    if err != nil {
        return nil, errors.New("user not found")
    }

    return &responses.UserResponse{
        ID:        user.ID,
        Name:      user.Name,
        Email:     user.Email,
        Role:      user.Role,
        CreatedAt: user.CreatedAt.Format("2006-01-02 15:04:05"),
    }, nil
}</code></pre>

                    <h4>Penjelasan Logout Function:</h4>
                    <ul>
                        <li><strong>Stateless Logout:</strong> Untuk JWT stateless, logout dilakukan di client side</li>
                        <li><strong>Token Removal:</strong> Client menghapus token dari storage</li>
                        <li><strong>Server Response:</strong> Server memberikan konfirmasi logout sukses</li>
                        <li><strong>GetProfile:</strong> Function tambahan untuk mengambil profile user</li>
                    </ul>

                    <h3>📝 Langkah 3: Update Response Struct untuk Logout</h3>
                    <p>Update file <code>responses/auth_response.go</code> untuk menambahkan LogoutResponse:</p>

                    <pre><code>package responses

import "tokogo/models"

// RegisterResponse struct untuk response register
type RegisterResponse struct {
    User  UserResponse \`json:"user"\`
    Token string       \`json:"token"\`
}

// LoginResponse struct untuk response login
type LoginResponse struct {
    User  UserResponse \`json:"user"\`
    Token string       \`json:"token"\`
}

// LogoutResponse struct untuk response logout
type LogoutResponse struct {
    Message string \`json:"message"\`
}

// UserResponse struct untuk response user (tanpa password)
type UserResponse struct {
    ID        uint   \`json:"id"\`
    Name      string \`json:"name"\`
    Email     string \`json:"email"\`
    Role      string \`json:"role"\`
    CreatedAt string \`json:"created_at"\`
}

// ErrorResponse struct untuk response error
type ErrorResponse struct {
    Error   string \`json:"error"\`
    Message string \`json:"message"\`
}

// SuccessResponse struct untuk response sukses
type SuccessResponse struct {
    Message string      \`json:"message"\`
    Data    interface{} \`json:"data,omitempty"\`
}

// ConvertUserToResponse mengkonversi User model ke UserResponse
func ConvertUserToResponse(user models.User) UserResponse {
    return UserResponse{
        ID:        user.ID,
        Name:      user.Name,
        Email:     user.Email,
        Role:      user.Role,
        CreatedAt: user.CreatedAt.Format("2006-01-02 15:04:05"),
    }
}</code></pre>

                    <h4>Penjelasan LogoutResponse:</h4>
                    <ul>
                        <li><strong>LogoutResponse:</strong> Response sederhana untuk logout yang berisi message sukses</li>
                        <li><strong>Stateless Design:</strong> Tidak menyimpan state logout di server</li>
                        <li><strong>Client Responsibility:</strong> Client bertanggung jawab menghapus token</li>
                    </ul>

                    <h3>📝 Langkah 4: Update Auth Repository untuk GetUserByID</h3>
                    <p>Update file <code>repositories/auth_repository.go</code> untuk menambahkan GetUserByID:</p>

                    <pre><code>package repositories

import (
    "errors"
    "tokogo/config"
    "tokogo/models"

    "gorm.io/gorm"
)

type AuthRepository struct {
    db *gorm.DB
}

// NewAuthRepository membuat instance baru AuthRepository
func NewAuthRepository() *AuthRepository {
    return &AuthRepository{
        db: config.GetDB(),
    }
}

// CreateUser menyimpan user baru ke database
func (r *AuthRepository) CreateUser(user *models.User) error {
    return r.db.Create(user).Error
}

// GetUserByEmail mengambil user berdasarkan email (untuk cek duplikasi)
func (r *AuthRepository) GetUserByEmail(email string) (*models.User, error) {
    var user models.User
    err := r.db.Where("email = ?", email).First(&user).Error
    
    if err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, errors.New("user not found")
        }
        return nil, err
    }
    
    return &user, nil
}

// GetUserByID mengambil user berdasarkan ID
func (r *AuthRepository) GetUserByID(id uint) (*models.User, error) {
    var user models.User
    err := r.db.Where("id = ?", id).First(&user).Error
    
    if err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, errors.New("user not found")
        }
        return nil, err
    }
    
    return &user, nil
}</code></pre>

                    <h4>Penjelasan GetUserByID:</h4>
                    <ul>
                        <li><strong>GetUserByID:</strong> Function untuk mengambil user berdasarkan ID</li>
                        <li><strong>Error Handling:</strong> Menangani error jika user tidak ditemukan</li>
                        <li><strong>GORM Query:</strong> Menggunakan Where clause untuk mencari berdasarkan ID</li>
                    </ul>

                    <h3>📝 Langkah 5: Update Auth Handler untuk Logout dan GetProfile</h3>
                    <p>Update file <code>handlers/auth_handler.go</code> untuk menambahkan Logout dan GetProfile handler:</p>

                    <pre><code>package handlers

import (
    "net/http"
    "strconv"
    "tokogo/requests"
    "tokogo/responses"
    "tokogo/services"

    "github.com/gin-gonic/gin"
)

type AuthHandler struct {
    authService *services.AuthService
}

// NewAuthHandler membuat instance baru AuthHandler
func NewAuthHandler() *AuthHandler {
    return &AuthHandler{
        authService: services.NewAuthService(),
    }
}

// Register handler untuk registrasi user baru
func (h *AuthHandler) Register(c *gin.Context) {
    var req requests.RegisterRequest

    // Bind dan validasi request
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Validasi menggunakan method Validate()
    if err := req.Validate(); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Panggil service untuk register
    registerResponse, err := h.authService.Register(req)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "register_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusCreated, responses.SuccessResponse{
        Message: "User registered successfully",
        Data:    registerResponse,
    })
}

// Login handler untuk login user
func (h *AuthHandler) Login(c *gin.Context) {
    var req requests.LoginRequest

    // Bind dan validasi request
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Validasi menggunakan method Validate()
    if err := req.Validate(); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Panggil service untuk login
    loginResponse, err := h.authService.Login(req)
    if err != nil {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "login_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Login successful",
        Data:    loginResponse,
    })
}

// Logout handler untuk logout user
func (h *AuthHandler) Logout(c *gin.Context) {
    // Ambil user ID dari context (setelah AuthMiddleware)
    userID, exists := c.Get("user_id")
    if !exists {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "unauthorized",
            Message: "User not authenticated",
        })
        return
    }

    // Panggil service untuk logout
    logoutResponse, err := h.authService.Logout(userID.(uint))
    if err != nil {
        c.JSON(http.StatusInternalServerError, responses.ErrorResponse{
            Error:   "logout_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, logoutResponse)
}

// GetProfile handler untuk mengambil profile user
func (h *AuthHandler) GetProfile(c *gin.Context) {
    // Ambil user ID dari context (setelah AuthMiddleware)
    userID, exists := c.Get("user_id")
    if !exists {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "unauthorized",
            Message: "User not authenticated",
        })
        return
    }

    // Panggil service untuk get profile
    userResponse, err := h.authService.GetProfile(userID.(uint))
    if err != nil {
        c.JSON(http.StatusNotFound, responses.ErrorResponse{
            Error:   "user_not_found",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Profile retrieved successfully",
        Data:    userResponse,
    })
}</code></pre>

                    <h4>Penjelasan Handler Baru:</h4>
                    <ul>
                        <li><strong>Logout Handler:</strong> Menggunakan user_id dari context untuk logout</li>
                        <li><strong>GetProfile Handler:</strong> Mengambil profile user berdasarkan ID dari context</li>
                        <li><strong>Context Usage:</strong> Menggunakan data user yang sudah di-set oleh middleware</li>
                        <li><strong>Error Handling:</strong> Menangani error jika user tidak authenticated</li>
                    </ul>

                    <h3>📝 Langkah 6: Update Main.go untuk Logout dan Protected Routes</h3>
                    <p>Update file <code>main.go</code> untuk menambahkan route logout dan protected routes:</p>

                    <pre><code>package main

import (
    "log"
    "tokogo/config"
    "tokogo/handlers"
    "tokogo/middlewares"

    "github.com/gin-contrib/cors"
    "github.com/gin-gonic/gin"
    "github.com/joho/godotenv"
)

func main() {
    // Load environment variables
    if err := godotenv.Load(); err != nil {
        log.Println("No .env file found, using system environment variables")
    }

    // Initialize database
    config.InitDB()

    // Setup Gin router
    r := gin.Default()

    // CORS middleware
    r.Use(cors.New(cors.Config{
        AllowOrigins:     []string{"*"},
        AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
        AllowHeaders:     []string{"*"},
        ExposeHeaders:    []string{"Content-Length"},
        AllowCredentials: true,
    }))

    // Initialize handlers
    authHandler := handlers.NewAuthHandler()

    // Public routes (tidak perlu authentication)
    api := r.Group("/api/v1")
    {
        // Auth routes
        auth := api.Group("/auth")
        {
            auth.POST("/register", authHandler.Register)
            auth.POST("/login", authHandler.Login)
        }
    }

    // Protected routes (perlu authentication)
    protected := r.Group("/api/v1")
    protected.Use(middlewares.AuthMiddleware())
    {
        // Auth protected routes
        auth := protected.Group("/auth")
        {
            auth.POST("/logout", authHandler.Logout)
            auth.GET("/profile", authHandler.GetProfile)
        }

        // Admin routes (perlu admin role)
        admin := protected.Group("/admin")
        admin.Use(middlewares.AdminMiddleware())
        {
            admin.GET("/dashboard", func(c *gin.Context) {
                c.JSON(200, gin.H{
                    "message": "Welcome to admin dashboard",
                    "user_id": c.GetUint("user_id"),
                })
            })
        }
    }

    // Start server
    port := config.GetEnv("SERVER_PORT", "8080")
    log.Printf("Server starting on port %s", port)
    r.Run(":" + port)
}</code></pre>

                    <h4>Penjelasan Main.go Update:</h4>
                    <ul>
                        <li><strong>Protected Routes:</strong> Menggunakan AuthMiddleware untuk melindungi endpoint</li>
                        <li><strong>Logout Route:</strong> POST /api/v1/auth/logout (protected)</li>
                        <li><strong>Profile Route:</strong> GET /api/v1/auth/profile (protected)</li>
                        <li><strong>Admin Routes:</strong> Menggunakan AdminMiddleware untuk role admin</li>
                        <li><strong>Middleware Chain:</strong> AuthMiddleware -> AdminMiddleware untuk admin routes</li>
                    </ul>

                    <h3>🧪 Testing API Logout dan Protected Routes</h3>
                    <p>Sekarang mari kita test API logout dan protected routes yang sudah kita buat:</p>

                    <h4>1. Login User (untuk mendapatkan token)</h4>
                    <pre><code>POST http://localhost:8080/api/v1/auth/login
Content-Type: application/json

{
    "email": "john@example.com",
    "password": "password123"
}</code></pre>

                    <h4>2. Get Profile (Protected Route)</h4>
                    <pre><code>GET http://localhost:8080/api/v1/auth/profile
Authorization: Bearer {your_jwt_token}</code></pre>

                    <h4>Response Sukses (200 OK):</h4>
                    <pre><code>{
    "message": "Profile retrieved successfully",
    "data": {
        "id": 1,
        "name": "johndoe",
        "email": "john@example.com",
        "role": "customer",
        "created_at": "2024-01-15 10:30:00"
    }
}</code></pre>

                    <h4>3. Logout User</h4>
                    <pre><code>POST http://localhost:8080/api/v1/auth/logout
Authorization: Bearer {your_jwt_token}</code></pre>

                    <h4>Response Sukses (200 OK):</h4>
                    <pre><code>{
    "message": "Logout successful"
}</code></pre>

                    <h4>4. Test Protected Route tanpa Token</h4>
                    <pre><code>GET http://localhost:8080/api/v1/auth/profile</code></pre>

                    <h4>Response Error (401 Unauthorized):</h4>
                    <pre><code>{
    "error": "unauthorized",
    "message": "Authorization header is required"
}</code></pre>

                    <h4>5. Test Admin Route (Customer Role)</h4>
                    <pre><code>GET http://localhost:8080/api/v1/admin/dashboard
Authorization: Bearer {customer_jwt_token}</code></pre>

                    <h4>Response Error (403 Forbidden):</h4>
                    <pre><code>{
    "error": "forbidden",
    "message": "Admin access required"
}</code></pre>

                    <h3>✅ Checklist Implementasi Logout</h3>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>File yang Harus Dibuat:</h4>
                        <ul>
                            <li>✅ middlewares/auth_middleware.go (AuthMiddleware, AdminMiddleware)</li>
                        </ul>
                        
                        <h4>File yang Harus Diupdate:</h4>
                        <ul>
                            <li>✅ responses/auth_response.go (LogoutResponse)</li>
                            <li>✅ repositories/auth_repository.go (GetUserByID)</li>
                            <li>✅ services/auth_service.go (Logout, GetProfile)</li>
                            <li>✅ handlers/auth_handler.go (Logout, GetProfile)</li>
                            <li>✅ main.go (Protected routes, middleware)</li>
                        </ul>
                    </div>

                    <h3>🚀 Cara Menjalankan</h3>
                    <ol>
                        <li>Pastikan MySQL sudah berjalan</li>
                        <li>Pastikan database 'tokogo' sudah dibuat</li>
                        <li>Pastikan ada user yang sudah terdaftar dan bisa login</li>
                        <li>Jalankan: <code>go run main.go</code></li>
                        <li>Test dengan Postman atau curl</li>
                    </ol>

                    <h3>🎯 Fitur Logout yang Sudah Diimplementasikan</h3>
                    <ul>
                        <li>✅ User Logout dengan JWT token validation</li>
                        <li>✅ Middleware Authentication untuk protected routes</li>
                        <li>✅ Middleware Admin untuk admin-only routes</li>
                        <li>✅ Get Profile endpoint yang protected</li>
                        <li>✅ Admin Dashboard endpoint</li>
                        <li>✅ Error handling yang proper</li>
                        <li>✅ Response format yang konsisten</li>
                    </ul>

                    <h3>🔒 Keamanan yang Diimplementasikan</h3>
                    <ul>
                        <li>✅ JWT token validation di middleware</li>
                        <li>✅ Authorization header validation</li>
                        <li>✅ Role-based access control (AdminMiddleware)</li>
                        <li>✅ Protected routes dengan authentication</li>
                        <li>✅ Context-based user information</li>
                        <li>✅ Stateless logout design</li>
                        <li>✅ Proper error messages untuk security</li>
                    </ul>

                    <h3>🎉 Selamat!</h3>
                    <p>Anda telah berhasil mengimplementasikan modul Logout yang lengkap! Sistem authentication sudah lengkap dengan Register, Login, Logout, dan middleware protection. Sistem sudah siap untuk digunakan dan dapat diintegrasikan dengan frontend aplikasi.</p>

                    <div style="text-align: center; margin: 3rem 0;">
                        <div style="background: #f8f9fa; border: 1px solid #dee2e6; color: #2c3e50; padding: 2rem; border-radius: 5px; display: inline-block;">
                            <h3 style="color: #2c3e50; margin-bottom: 1rem;">🎯 Sistem Authentication Lengkap!</h3>
                            <p style="color: #495057; margin-bottom: 0;">Sekarang Anda memiliki sistem authentication yang lengkap dengan Register, Login, Logout, dan middleware protection. Siap untuk melanjutkan ke modul berikutnya!</p>
                        </div>
                    </div>
                `
            },
            {
                id: 'chapter9',
                title: 'Bab 9: Relaksasi & Review Pembelajaran - Modul Authentication',
                meta: 'Halaman 9 dari 50 • Dibaca 15 menit',
                content: `
                    <h2>Bab 9: Relaksasi & Review Pembelajaran - Modul Authentication</h2>
                    <p>Selamat! Anda telah berhasil menyelesaikan modul Authentication yang lengkap (Bab 6-8). Sekarang saatnya untuk beristirahat sejenak dan mengulas kembali semua yang telah dipelajari tentang sistem authentication. Bab ini dirancang untuk membantu otak Anda mengkonsolidasikan pengetahuan authentication yang baru saja diperoleh.</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">🎯 Pencapaian yang Luar Biasa!</h3>
                        <p style="color: #495057; margin-bottom: 0;">Anda telah berhasil membangun sistem authentication yang lengkap dengan Register, Login, Logout, dan middleware protection. Ini adalah pencapaian yang sangat membanggakan!</p>
                    </div>

                    <h3>Ringkasan Pembelajaran Bab 6-8</h3>
                    <p>Sebelum masuk ke pertanyaan review, mari kita ingat kembali perjalanan pembelajaran authentication yang telah kita lalui:</p>

                    <h4>Bab 6: Modul Authentication - Register</h4>
                    <ul>
                        <li>✅ User registration dengan validasi input</li>
                        <li>✅ Password hashing dengan bcrypt</li>
                        <li>✅ Email uniqueness validation</li>
                        <li>✅ Konfirmasi password untuk keamanan</li>
                        <li>✅ JWT token generation setelah registrasi</li>
                        <li>✅ Response format yang konsisten</li>
                        <li>✅ Error handling yang proper</li>
                    </ul>

                    <h4>Bab 7: Modul Authentication - Login</h4>
                    <ul>
                        <li>✅ User login dengan validasi email/password</li>
                        <li>✅ Password verification dengan bcrypt</li>
                        <li>✅ JWT token generation setelah login sukses</li>
                        <li>✅ Input validation dengan go-playground/validator</li>
                        <li>✅ Error handling untuk invalid credentials</li>
                        <li>✅ Security: Error message yang sama untuk keamanan</li>
                        <li>✅ Response format yang konsisten</li>
                    </ul>

                    <h4>Bab 8: Modul Authentication - Logout</h4>
                    <ul>
                        <li>✅ User logout dengan JWT token validation</li>
                        <li>✅ Middleware Authentication untuk protected routes</li>
                        <li>✅ Middleware Admin untuk role-based access control</li>
                        <li>✅ Get Profile endpoint yang protected</li>
                        <li>✅ Admin Dashboard endpoint</li>
                        <li>✅ Authorization header validation</li>
                        <li>✅ Context-based user information</li>
                    </ul>

                    <h3>Pertanyaan Review Interaktif</h3>
                    <p>Mari kita uji pemahaman Anda dengan pertanyaan-pertanyaan yang dirancang untuk mengaktifkan kembali memori dan memperkuat pembelajaran authentication:</p>

                    <div style="background: #f8f9fa; border-left: 4px solid #3498db; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Bagian A: Konsep Dasar Authentication</h4>
                        
                        <p><strong>1. Mengapa kita menggunakan bcrypt untuk hashing password?</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: bcrypt adalah algoritma hashing yang aman dan slow, membuat brute force attack menjadi sangat sulit dan memakan waktu lama.</p>
                        
                        <p><strong>2. Apa perbedaan antara JWT token dan session-based authentication?</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: JWT adalah stateless (tidak menyimpan state di server), sementara session-based menyimpan state di server. JWT lebih scalable untuk distributed systems.</p>
                        
                        <p><strong>3. Mengapa kita memvalidasi konfirmasi password di sisi server?</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: Validasi di server memastikan keamanan dan mencegah user salah ketik password, meskipun sudah ada validasi di client side.</p>
                    </div>

                    <div style="background: #f8f9fa; border-left: 4px solid #e74c3c; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Bagian B: Middleware & Security</h4>
                        
                        <p><strong>4. Bagaimana cara kerja AuthMiddleware dalam melindungi endpoint?</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: AuthMiddleware memvalidasi JWT token dari Authorization header, mengekstrak user info, dan menyimpannya di context untuk digunakan di handler.</p>
                        
                        <p><strong>5. Apa perbedaan antara AuthMiddleware dan AdminMiddleware?</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: AuthMiddleware memvalidasi token dan set user info, sementara AdminMiddleware memvalidasi apakah user memiliki role admin.</p>
                        
                        <p><strong>6. Mengapa kita menggunakan format "Bearer {token}" untuk Authorization header?</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: Ini adalah standar OAuth 2.0 yang memisahkan tipe authentication (Bearer) dengan token, memudahkan parsing dan validasi.</p>
                    </div>

                    <div style="background: #f8f9fa; border-left: 4px solid #f39c12; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Bagian C: Arsitektur & Best Practices</h4>
                        
                        <p><strong>7. Jelaskan alur authentication flow dari register sampai logout!</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: Register → Hash password → Save user → Generate JWT → Login → Validate credentials → Generate JWT → Access protected routes → Logout → Remove token (client-side).</p>
                        
                        <p><strong>8. Mengapa kita menggunakan layered architecture untuk authentication?</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: Separation of concerns, maintainability, testability, dan scalability. Setiap layer memiliki tanggung jawab yang jelas.</p>
                        
                        <p><strong>9. Bagaimana cara implementasi stateless logout dengan JWT?</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: Server memberikan response sukses, client menghapus token dari storage. Untuk production, bisa implementasi token blacklist.</p>
                    </div>

                    <div style="background: #f8f9fa; border-left: 4px solid #27ae60; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Bagian D: Error Handling & Security</h4>
                        
                        <p><strong>10. Mengapa kita memberikan error message yang sama untuk "invalid email or password"?</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: Untuk keamanan, mencegah attacker mengetahui apakah email terdaftar atau tidak, menghindari user enumeration attack.</p>
                        
                        <p><strong>11. Apa yang terjadi jika JWT token expired?</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: ValidateToken akan return error, middleware akan mengembalikan 401 Unauthorized, client harus login ulang.</p>
                        
                        <p><strong>12. Bagaimana cara mengimplementasikan role-based access control?</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: Menggunakan AdminMiddleware yang memvalidasi role dari JWT claims, memberikan akses berbeda berdasarkan role user.</p>
                    </div>

                    <h3>Latihan Praktis</h3>
                    <p>Mari kita lakukan beberapa latihan praktis untuk memperkuat pemahaman:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Latihan 1: Analisis Security</h4>
                        <p>Analisis kode authentication yang sudah dibuat dan identifikasi:</p>
                        <ul>
                            <li>✅ Password hashing dengan bcrypt</li>
                            <li>✅ JWT token dengan expiration</li>
                            <li>✅ Input validation</li>
                            <li>✅ SQL injection protection (GORM)</li>
                            <li>✅ CORS configuration</li>
                            <li>✅ Generic error messages</li>
                        </ul>
                    </div>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Latihan 2: Testing Scenarios</h4>
                        <p>Test berbagai skenario authentication:</p>
                        <ul>
                            <li>✅ Register dengan email yang sudah ada</li>
                            <li>✅ Login dengan password yang salah</li>
                            <li>✅ Akses protected route tanpa token</li>
                            <li>✅ Akses admin route dengan customer role</li>
                            <li>✅ Logout dengan token yang valid</li>
                        </ul>
                    </div>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Latihan 3: Code Review</h4>
                        <p>Review kode authentication dan identifikasi:</p>
                        <ul>
                            <li>✅ Error handling yang konsisten</li>
                            <li>✅ Response format yang seragam</li>
                            <li>✅ Middleware yang reusable</li>
                            <li>✅ Separation of concerns</li>
                            <li>✅ Security best practices</li>
                        </ul>
                    </div>

                    <h3>Teknik Memori untuk Authentication</h3>
                    <p>Berikut adalah teknik memori untuk mengingat konsep-konsep authentication:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Akronim: AUTH-FLOW</h4>
                        <ul>
                            <li><strong>A</strong>uthentication - Verifikasi identitas user</li>
                            <li><strong>U</strong>ser Registration - Pendaftaran user baru</li>
                            <li><strong>T</strong>oken Generation - Pembuatan JWT token</li>
                            <li><strong>H</strong>ashing - Password hashing dengan bcrypt</li>
                            <li><strong>F</strong>low Control - Middleware untuk kontrol akses</li>
                            <li><strong>L</strong>ogin/Logout - Proses masuk dan keluar</li>
                            <li><strong>O</strong>wnership - User ownership data</li>
                            <li><strong>W</strong>eb Security - Keamanan web application</li>
                        </ul>
                    </div>

                    <h3>Self-Assessment</h3>
                    <p>Evaluasi pemahaman Anda tentang modul Authentication:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Kemampuan yang Harus Dikuasai:</h4>
                        <ul>
                            <li>✅ Memahami konsep authentication dan authorization</li>
                            <li>✅ Mampu implementasi user registration dengan validasi</li>
                            <li>✅ Mampu implementasi user login dengan JWT</li>
                            <li>✅ Mampu implementasi user logout</li>
                            <li>✅ Mampu membuat middleware authentication</li>
                            <li>✅ Mampu implementasi role-based access control</li>
                            <li>✅ Mampu testing API authentication</li>
                            <li>✅ Memahami security best practices</li>
                        </ul>
                    </div>

                    <h3>Tips untuk Pengembangan Selanjutnya</h3>
                    <p>Berikut adalah tips untuk mengembangkan sistem authentication lebih lanjut:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Fitur Tambahan yang Bisa Dikembangkan:</h4>
                        <ul>
                            <li>🔐 Password reset functionality</li>
                            <li>🔐 Email verification</li>
                            <li>🔐 Two-factor authentication (2FA)</li>
                            <li>🔐 Refresh token mechanism</li>
                            <li>🔐 Rate limiting untuk login attempts</li>
                            <li>🔐 Account lockout setelah failed attempts</li>
                            <li>🔐 Audit logging untuk security</li>
                            <li>🔐 OAuth integration (Google, Facebook)</li>
                        </ul>
                    </div>

                    <h3>Refleksi Pembelajaran</h3>
                    <p>Mari kita refleksikan apa yang telah dipelajari:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Pencapaian yang Membanggakan:</h4>
                        <ul>
                            <li>🎯 Berhasil membangun sistem authentication yang lengkap</li>
                            <li>🎯 Memahami konsep JWT dan stateless authentication</li>
                            <li>🎯 Mampu implementasi middleware untuk security</li>
                            <li>🎯 Memahami role-based access control</li>
                            <li>🎯 Mampu testing API dengan Postman</li>
                            <li>🎯 Memahami security best practices</li>
                        </ul>
                    </div>

                 

                    <h3>Kata-kata Motivasi</h3>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; margin: 2rem 0; border-radius: 5px; text-align: center;">
                        <p style="font-size: 1.1rem; color: #2c3e50; font-style: italic; margin-bottom: 0;">
                            "Authentication adalah fondasi keamanan aplikasi. Dengan menguasai konsep ini, Anda telah membangun dasar yang kuat untuk mengembangkan aplikasi yang aman dan terpercaya. Teruslah belajar dan eksplorasi fitur-fitur keamanan yang lebih advanced!"
                        </p>
                    </div>

                    <h3>Selamat!</h3>
                    <p>Anda telah berhasil menyelesaikan modul Authentication yang lengkap! Ini adalah pencapaian yang luar biasa. Sistem authentication yang Anda buat sudah siap untuk production dan dapat diintegrasikan dengan frontend aplikasi.</p>

                    <div style="text-align: center; margin: 3rem 0;">
                        <div style="background: #f8f9fa; border: 1px solid #dee2e6; color: #2c3e50; padding: 2rem; border-radius: 5px; display: inline-block;">
                            <h3 style="color: #2c3e50; margin-bottom: 1rem;">🎯 Siap untuk Modul Selanjutnya?</h3>
                            <p style="color: #495057; margin-bottom: 0;">Dengan sistem authentication yang lengkap, Anda siap untuk melanjutkan ke modul berikutnya seperti Product Management atau Shopping Cart!</p>
                        </div>
                    </div>
                `
            },
            {
                id: 'chapter10',
                title: 'Bab 10: Modul CRUD Kategori - Role Admin',
                meta: 'Halaman 10 dari 50 • Dibaca 12 menit',
                content: `
                    <h2>📂 Bab 10: Modul CRUD Kategori - Role Admin</h2>
                    <p>Selamat! Sekarang kita akan membuat modul CRUD (Create, Read, Update, Delete) untuk Kategori yang hanya bisa diakses oleh admin. Di bab ini, kita akan mengimplementasikan sistem manajemen kategori dengan role-based access control.</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">🎯 Apa yang Akan Kita Buat di Bab Ini?</h3>
                        <p style="color: #495057; margin-bottom: 0;">Kita akan membuat sistem CRUD kategori yang lengkap dengan Create, Read, Update, Delete operations. Semua endpoint hanya bisa diakses oleh admin. Setelah selesai, kita akan test menggunakan Postman.</p>
                    </div>

                    <h3>📋 Prasyarat</h3>
                    <p>Sebelum memulai, pastikan Anda sudah menyelesaikan:</p>
                    <ul>
                        <li>✅ Bab 6-8: Modul Authentication (Register, Login, Logout)</li>
                        <li>✅ Bab 9: Review Pembelajaran Authentication</li>
                        <li>✅ Middleware authentication sudah berfungsi</li>
                        <li>✅ AdminMiddleware sudah diimplementasikan</li>
                    </ul>

                    <h3>📊 Database Schema Kategori</h3>
                    <p>Berdasarkan requirement yang diberikan, berikut adalah struktur tabel kategori:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Table: categories</h4>
                        <table style="width: 100%; border-collapse: collapse; margin-top: 1rem;">
                            <thead>
                                <tr style="background: #e9ecef;">
                                    <th style="border: 1px solid #dee2e6; padding: 0.75rem; text-align: left;">Field</th>
                                    <th style="border: 1px solid #dee2e6; padding: 0.75rem; text-align: left;">Type</th>
                                    <th style="border: 1px solid #dee2e6; padding: 0.75rem; text-align: left;">Notes</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">id</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">BIGINT PK</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Auto Increment</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">name</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">VARCHAR</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Nama kategori</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">slug</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">VARCHAR</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">URL-friendly identifier</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">created_at</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">TIMESTAMP</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Waktu dibuat</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">updated_at</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">TIMESTAMP</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Waktu diupdate</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">deleted_at</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">TIMESTAMP</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Soft delete</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <h3>📝 Langkah 1: Buat Model Category</h3>
                    <p>Buat file <code>models/category.go</code> untuk model kategori:</p>

                    <pre><code>package models

import (
    "time"
    "strings"
    "gorm.io/gorm"
)

type Category struct {
    ID        uint           \`gorm:"primaryKey;column:id;type:BIGINT UNSIGNED AUTO_INCREMENT" json:"id"\`
    Name      string         \`gorm:"column:name;type:VARCHAR(255);not null" json:"name"\`
    Slug      string         \`gorm:"column:slug;type:VARCHAR(255);uniqueIndex;not null" json:"slug"\`
    CreatedAt time.Time      \`gorm:"column:created_at;type:TIMESTAMP DEFAULT CURRENT_TIMESTAMP" json:"created_at"\`
    UpdatedAt time.Time      \`gorm:"column:updated_at;type:TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP" json:"updated_at"\`
    DeletedAt gorm.DeletedAt \`gorm:"column:deleted_at;type:TIMESTAMP NULL;index" json:"-"\`
}

// TableName mengembalikan nama tabel untuk model Category
func (Category) TableName() string {
    return "categories"
}

// GenerateSlug menghasilkan slug dari nama kategori
func (c *Category) GenerateSlug() {
    slug := strings.ToLower(c.Name)
    slug = strings.ReplaceAll(slug, " ", "-")
    slug = strings.ReplaceAll(slug, "_", "-")
    c.Slug = slug
}

// BeforeCreate hook untuk generate slug sebelum create
func (c *Category) BeforeCreate(tx *gorm.DB) error {
    c.GenerateSlug()
    return nil
}

// BeforeUpdate hook untuk generate slug sebelum update
func (c *Category) BeforeUpdate(tx *gorm.DB) error {
    c.GenerateSlug()
    return nil
}</code></pre>

                    <h4>Penjelasan Model Category:</h4>
                    <ul>
                        <li><strong>Struct Fields:</strong> Sesuai dengan database schema yang diberikan</li>
                        <li><strong>GORM Tags:</strong> Mapping ke database dengan tipe data yang tepat</li>
                        <li><strong>GenerateSlug:</strong> Function untuk membuat slug dari nama kategori</li>
                        <li><strong>Hooks:</strong> BeforeCreate dan BeforeUpdate untuk auto-generate slug</li>
                        <li><strong>Soft Delete:</strong> Menggunakan gorm.DeletedAt untuk soft delete</li>
                    </ul>

                    <h3>📝 Langkah 2: Buat Request Struct untuk Category</h3>
                    <p>Buat file <code>requests/category_request.go</code> untuk validasi input kategori:</p>

                    <pre><code>package requests

import (
    "errors"
    "github.com/go-playground/validator/v10"
)

// CreateCategoryRequest represents the request structure for creating category
type CreateCategoryRequest struct {
    Name string \`json:"name" validate:"required,min=2,max=100"\`
}

// UpdateCategoryRequest represents the request structure for updating category
type UpdateCategoryRequest struct {
    Name string \`json:"name" validate:"required,min=2,max=100"\`
}

// Validate validates the CreateCategoryRequest using the validator
func (r *CreateCategoryRequest) Validate() error {
    validate := validator.New()
    
    // Validasi struct fields
    if err := validate.Struct(r); err != nil {
        return err
    }
    
    // Validasi custom: nama tidak boleh kosong setelah trim
    if strings.TrimSpace(r.Name) == "" {
        return errors.New("name cannot be empty")
    }
    
    return nil
}

// Validate validates the UpdateCategoryRequest using the validator
func (r *UpdateCategoryRequest) Validate() error {
    validate := validator.New()
    
    // Validasi struct fields
    if err := validate.Struct(r); err != nil {
        return err
    }
    
    // Validasi custom: nama tidak boleh kosong setelah trim
    if strings.TrimSpace(r.Name) == "" {
        return errors.New("name cannot be empty")
    }
    
    return nil
}</code></pre>

                    <h4>Penjelasan Request Struct:</h4>
                    <ul>
                        <li><strong>CreateCategoryRequest:</strong> Untuk membuat kategori baru</li>
                        <li><strong>UpdateCategoryRequest:</strong> Untuk update kategori yang sudah ada</li>
                        <li><strong>Validation:</strong> Nama minimal 2 karakter, maksimal 100 karakter</li>
                        <li><strong>Custom Validation:</strong> Nama tidak boleh kosong setelah trim</li>
                    </ul>

                    <h3>📝 Langkah 3: Buat Response Struct untuk Category</h3>
                    <p>Buat file <code>responses/category_response.go</code> untuk format response kategori:</p>

                    <pre><code>package responses

import "tokogo/models"

// CategoryResponse struct untuk response category
type CategoryResponse struct {
    ID        uint   \`json:"id"\`
    Name      string \`json:"name"\`
    Slug      string \`json:"slug"\`
    CreatedAt string \`json:"created_at"\`
    UpdatedAt string \`json:"updated_at"\`
}

// CategoryListResponse struct untuk response list category
type CategoryListResponse struct {
    Categories []CategoryResponse \`json:"categories"\`
    Total      int                \`json:"total"\`
    Page       int                \`json:"page"\`
    Limit      int                \`json:"limit"\`
}

// ConvertCategoryToResponse mengkonversi Category model ke CategoryResponse
func ConvertCategoryToResponse(category models.Category) CategoryResponse {
    return CategoryResponse{
        ID:        category.ID,
        Name:      category.Name,
        Slug:      category.Slug,
        CreatedAt: category.CreatedAt.Format("2006-01-02 15:04:05"),
        UpdatedAt: category.UpdatedAt.Format("2006-01-02 15:04:05"),
    }
}

// ConvertCategoriesToResponse mengkonversi slice Category ke slice CategoryResponse
func ConvertCategoriesToResponse(categories []models.Category) []CategoryResponse {
    var responses []CategoryResponse
    for _, category := range categories {
        responses = append(responses, ConvertCategoryToResponse(category))
    }
    return responses
}</code></pre>

                    <h4>Penjelasan Response Struct:</h4>
                    <ul>
                        <li><strong>CategoryResponse:</strong> Response untuk single category</li>
                        <li><strong>CategoryListResponse:</strong> Response untuk list category dengan pagination</li>
                        <li><strong>Convert Functions:</strong> Helper functions untuk konversi model ke response</li>
                        <li><strong>Date Formatting:</strong> Format tanggal yang konsisten</li>
                    </ul>

                    <h3>📝 Langkah 4: Buat Category Repository</h3>
                    <p>Buat file <code>repositories/category_repository.go</code> untuk database operations:</p>

                    <pre><code>package repositories

import (
    "errors"
    "tokogo/config"
    "tokogo/models"

    "gorm.io/gorm"
)

type CategoryRepository struct {
    db *gorm.DB
}

// NewCategoryRepository membuat instance baru CategoryRepository
func NewCategoryRepository() *CategoryRepository {
    return &CategoryRepository{
        db: config.GetDB(),
    }
}

// CreateCategory menyimpan category baru ke database
func (r *CategoryRepository) CreateCategory(category *models.Category) error {
    return r.db.Create(category).Error
}

// GetCategoryByID mengambil category berdasarkan ID
func (r *CategoryRepository) GetCategoryByID(id uint) (*models.Category, error) {
    var category models.Category
    err := r.db.Where("id = ?", id).First(&category).Error
    
    if err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, errors.New("category not found")
        }
        return nil, err
    }
    
    return &category, nil
}

// GetCategoryBySlug mengambil category berdasarkan slug
func (r *CategoryRepository) GetCategoryBySlug(slug string) (*models.Category, error) {
    var category models.Category
    err := r.db.Where("slug = ?", slug).First(&category).Error
    
    if err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, errors.New("category not found")
        }
        return nil, err
    }
    
    return &category, nil
}

// GetAllCategories mengambil semua categories dengan pagination
func (r *CategoryRepository) GetAllCategories(page, limit int) ([]models.Category, int64, error) {
    var categories []models.Category
    var total int64

    // Hitung total records
    if err := r.db.Model(&models.Category{}).Count(&total).Error; err != nil {
        return nil, 0, err
    }

    // Ambil data dengan pagination
    offset := (page - 1) * limit
    err := r.db.Offset(offset).Limit(limit).Order("created_at DESC").Find(&categories).Error
    
    return categories, total, err
}

// UpdateCategory mengupdate category berdasarkan ID
func (r *CategoryRepository) UpdateCategory(id uint, category *models.Category) error {
    return r.db.Where("id = ?", id).Updates(category).Error
}

// DeleteCategory menghapus category berdasarkan ID (soft delete)
func (r *CategoryRepository) DeleteCategory(id uint) error {
    return r.db.Where("id = ?", id).Delete(&models.Category{}).Error
}

// CheckCategoryExists mengecek apakah category dengan nama tertentu sudah ada
func (r *CategoryRepository) CheckCategoryExists(name string, excludeID uint) (bool, error) {
    var count int64
    query := r.db.Model(&models.Category{}).Where("name = ?", name)
    
    if excludeID > 0 {
        query = query.Where("id != ?", excludeID)
    }
    
    err := query.Count(&count).Error
    return count > 0, err
}</code></pre>

                    <h4>Penjelasan Category Repository:</h4>
                    <ul>
                        <li><strong>CRUD Operations:</strong> Create, Read, Update, Delete category</li>
                        <li><strong>Pagination:</strong> GetAllCategories dengan pagination support</li>
                        <li><strong>Soft Delete:</strong> DeleteCategory menggunakan soft delete</li>
                        <li><strong>Validation:</strong> CheckCategoryExists untuk cek duplikasi nama</li>
                        <li><strong>Error Handling:</strong> Proper error handling untuk setiap operation</li>
                    </ul>

                    <h3>📝 Langkah 5: Buat Category Service</h3>
                    <p>Buat file <code>services/category_service.go</code> untuk business logic kategori:</p>

                    <pre><code>package services

import (
    "errors"
    "tokogo/models"
    "tokogo/repositories"
    "tokogo/requests"
    "tokogo/responses"
)

type CategoryService struct {
    categoryRepo *repositories.CategoryRepository
}

// NewCategoryService membuat instance baru CategoryService
func NewCategoryService() *CategoryService {
    return &CategoryService{
        categoryRepo: repositories.NewCategoryRepository(),
    }
}

// CreateCategory membuat category baru
func (s *CategoryService) CreateCategory(req requests.CreateCategoryRequest) (*responses.CategoryResponse, error) {
    // Cek apakah nama category sudah ada
    exists, err := s.categoryRepo.CheckCategoryExists(req.Name, 0)
    if err != nil {
        return nil, errors.New("failed to check category existence")
    }
    if exists {
        return nil, errors.New("category name already exists")
    }

    // Buat category baru
    category := &models.Category{
        Name: req.Name,
    }

    // Simpan ke database
    if err := s.categoryRepo.CreateCategory(category); err != nil {
        return nil, errors.New("failed to create category")
    }

    // Return response
    return &responses.CategoryResponse{
        ID:        category.ID,
        Name:      category.Name,
        Slug:      category.Slug,
        CreatedAt: category.CreatedAt.Format("2006-01-02 15:04:05"),
        UpdatedAt: category.UpdatedAt.Format("2006-01-02 15:04:05"),
    }, nil
}

// GetCategoryByID mengambil category berdasarkan ID
func (s *CategoryService) GetCategoryByID(id uint) (*responses.CategoryResponse, error) {
    category, err := s.categoryRepo.GetCategoryByID(id)
    if err != nil {
        return nil, err
    }

    return &responses.CategoryResponse{
        ID:        category.ID,
        Name:      category.Name,
        Slug:      category.Slug,
        CreatedAt: category.CreatedAt.Format("2006-01-02 15:04:05"),
        UpdatedAt: category.UpdatedAt.Format("2006-01-02 15:04:05"),
    }, nil
}

// GetAllCategories mengambil semua categories dengan pagination
func (s *CategoryService) GetAllCategories(page, limit int) (*responses.CategoryListResponse, error) {
    categories, total, err := s.categoryRepo.GetAllCategories(page, limit)
    if err != nil {
        return nil, errors.New("failed to get categories")
    }

    return &responses.CategoryListResponse{
        Categories: responses.ConvertCategoriesToResponse(categories),
        Total:      int(total),
        Page:       page,
        Limit:      limit,
    }, nil
}

// UpdateCategory mengupdate category berdasarkan ID
func (s *CategoryService) UpdateCategory(id uint, req requests.UpdateCategoryRequest) (*responses.CategoryResponse, error) {
    // Cek apakah category ada
    existingCategory, err := s.categoryRepo.GetCategoryByID(id)
    if err != nil {
        return nil, err
    }

    // Cek apakah nama category sudah ada (exclude current category)
    exists, err := s.categoryRepo.CheckCategoryExists(req.Name, id)
    if err != nil {
        return nil, errors.New("failed to check category existence")
    }
    if exists {
        return nil, errors.New("category name already exists")
    }

    // Update category
    existingCategory.Name = req.Name
    if err := s.categoryRepo.UpdateCategory(id, existingCategory); err != nil {
        return nil, errors.New("failed to update category")
    }

    // Get updated category
    updatedCategory, err := s.categoryRepo.GetCategoryByID(id)
    if err != nil {
        return nil, errors.New("failed to get updated category")
    }

    return &responses.CategoryResponse{
        ID:        updatedCategory.ID,
        Name:      updatedCategory.Name,
        Slug:      updatedCategory.Slug,
        CreatedAt: updatedCategory.CreatedAt.Format("2006-01-02 15:04:05"),
        UpdatedAt: updatedCategory.UpdatedAt.Format("2006-01-02 15:04:05"),
    }, nil
}

// DeleteCategory menghapus category berdasarkan ID
func (s *CategoryService) DeleteCategory(id uint) error {
    // Cek apakah category ada
    _, err := s.categoryRepo.GetCategoryByID(id)
    if err != nil {
        return err
    }

    // Hapus category
    if err := s.categoryRepo.DeleteCategory(id); err != nil {
        return errors.New("failed to delete category")
    }

    return nil
}</code></pre>

                    <h4>Penjelasan Category Service:</h4>
                    <ul>
                        <li><strong>CreateCategory:</strong> Business logic untuk membuat kategori baru</li>
                        <li><strong>GetCategoryByID:</strong> Mengambil kategori berdasarkan ID</li>
                        <li><strong>GetAllCategories:</strong> Mengambil semua kategori dengan pagination</li>
                        <li><strong>UpdateCategory:</strong> Business logic untuk update kategori</li>
                        <li><strong>DeleteCategory:</strong> Business logic untuk hapus kategori</li>
                        <li><strong>Validation:</strong> Cek duplikasi nama kategori</li>
                    </ul>

                    <h3>📝 Langkah 6: Buat Category Handler</h3>
                    <p>Buat file <code>handlers/category_handler.go</code> untuk HTTP handlers:</p>

                    <pre><code>package handlers

import (
    "net/http"
    "strconv"
    "tokogo/requests"
    "tokogo/responses"
    "tokogo/services"

    "github.com/gin-gonic/gin"
)

type CategoryHandler struct {
    categoryService *services.CategoryService
}

// NewCategoryHandler membuat instance baru CategoryHandler
func NewCategoryHandler() *CategoryHandler {
    return &CategoryHandler{
        categoryService: services.NewCategoryService(),
    }
}

// CreateCategory handler untuk membuat category baru
func (h *CategoryHandler) CreateCategory(c *gin.Context) {
    var req requests.CreateCategoryRequest

    // Bind dan validasi request
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Validasi menggunakan method Validate()
    if err := req.Validate(); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Panggil service untuk create category
    categoryResponse, err := h.categoryService.CreateCategory(req)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "create_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusCreated, responses.SuccessResponse{
        Message: "Category created successfully",
        Data:    categoryResponse,
    })
}

// GetCategoryByID handler untuk mengambil category berdasarkan ID
func (h *CategoryHandler) GetCategoryByID(c *gin.Context) {
    // Ambil ID dari URL parameter
    idStr := c.Param("id")
    id, err := strconv.ParseUint(idStr, 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "invalid_id",
            Message: "Invalid category ID",
        })
        return
    }

    // Panggil service untuk get category
    categoryResponse, err := h.categoryService.GetCategoryByID(uint(id))
    if err != nil {
        c.JSON(http.StatusNotFound, responses.ErrorResponse{
            Error:   "category_not_found",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Category retrieved successfully",
        Data:    categoryResponse,
    })
}

// GetAllCategories handler untuk mengambil semua categories
func (h *CategoryHandler) GetAllCategories(c *gin.Context) {
    // Ambil query parameters untuk pagination
    pageStr := c.DefaultQuery("page", "1")
    limitStr := c.DefaultQuery("limit", "10")

    page, err := strconv.Atoi(pageStr)
    if err != nil || page < 1 {
        page = 1
    }

    limit, err := strconv.Atoi(limitStr)
    if err != nil || limit < 1 || limit > 100 {
        limit = 10
    }

    // Panggil service untuk get all categories
    categoriesResponse, err := h.categoryService.GetAllCategories(page, limit)
    if err != nil {
        c.JSON(http.StatusInternalServerError, responses.ErrorResponse{
            Error:   "get_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Categories retrieved successfully",
        Data:    categoriesResponse,
    })
}

// UpdateCategory handler untuk mengupdate category
func (h *CategoryHandler) UpdateCategory(c *gin.Context) {
    // Ambil ID dari URL parameter
    idStr := c.Param("id")
    id, err := strconv.ParseUint(idStr, 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "invalid_id",
            Message: "Invalid category ID",
        })
        return
    }

    var req requests.UpdateCategoryRequest

    // Bind dan validasi request
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Validasi menggunakan method Validate()
    if err := req.Validate(); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Panggil service untuk update category
    categoryResponse, err := h.categoryService.UpdateCategory(uint(id), req)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "update_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Category updated successfully",
        Data:    categoryResponse,
    })
}

// DeleteCategory handler untuk menghapus category
func (h *CategoryHandler) DeleteCategory(c *gin.Context) {
    // Ambil ID dari URL parameter
    idStr := c.Param("id")
    id, err := strconv.ParseUint(idStr, 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "invalid_id",
            Message: "Invalid category ID",
        })
        return
    }

    // Panggil service untuk delete category
    err = h.categoryService.DeleteCategory(uint(id))
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "delete_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Category deleted successfully",
        Data:    nil,
    })
}</code></pre>

                    <h4>Penjelasan Category Handler:</h4>
                    <ul>
                        <li><strong>CreateCategory:</strong> HTTP handler untuk membuat kategori baru</li>
                        <li><strong>GetCategoryByID:</strong> HTTP handler untuk mengambil kategori berdasarkan ID</li>
                        <li><strong>GetAllCategories:</strong> HTTP handler untuk mengambil semua kategori dengan pagination</li>
                        <li><strong>UpdateCategory:</strong> HTTP handler untuk update kategori</li>
                        <li><strong>DeleteCategory:</strong> HTTP handler untuk hapus kategori</li>
                        <li><strong>Error Handling:</strong> Proper error handling untuk setiap endpoint</li>
                    </ul>

                    <h3>📝 Langkah 7: Update Main.go untuk Category Routes</h3>
                    <p>Update file <code>main.go</code> untuk menambahkan category routes:</p>

                    <pre><code>package main

import (
    "log"
    "tokogo/config"
    "tokogo/handlers"
    "tokogo/middlewares"

    "github.com/gin-contrib/cors"
    "github.com/gin-gonic/gin"
    "github.com/joho/godotenv"
)

func main() {
    // Load environment variables
    if err := godotenv.Load(); err != nil {
        log.Println("No .env file found, using system environment variables")
    }

    // Initialize database
    config.InitDB()

    // Setup Gin router
    r := gin.Default()

    // CORS middleware
    r.Use(cors.New(cors.Config{
        AllowOrigins:     []string{"*"},
        AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
        AllowHeaders:     []string{"*"},
        ExposeHeaders:    []string{"Content-Length"},
        AllowCredentials: true,
    }))

    // Initialize handlers
    authHandler := handlers.NewAuthHandler()
    categoryHandler := handlers.NewCategoryHandler()

    // Public routes (tidak perlu authentication)
    api := r.Group("/api/v1")
    {
        // Auth routes
        auth := api.Group("/auth")
        {
            auth.POST("/register", authHandler.Register)
            auth.POST("/login", authHandler.Login)
        }
    }

    // Protected routes (perlu authentication)
    protected := r.Group("/api/v1")
    protected.Use(middlewares.AuthMiddleware())
    {
        // Auth protected routes
        auth := protected.Group("/auth")
        {
            auth.POST("/logout", authHandler.Logout)
            auth.GET("/profile", authHandler.GetProfile)
        }

        // Admin routes (perlu admin role)
        admin := protected.Group("/admin")
        admin.Use(middlewares.AdminMiddleware())
        {
            admin.GET("/dashboard", func(c *gin.Context) {
                c.JSON(200, gin.H{
                    "message": "Welcome to admin dashboard",
                    "user_id": c.GetUint("user_id"),
                })
            })

            // Category CRUD routes (admin only)
            categories := admin.Group("/categories")
            {
                categories.POST("", categoryHandler.CreateCategory)
                categories.GET("", categoryHandler.GetAllCategories)
                categories.GET("/:id", categoryHandler.GetCategoryByID)
                categories.PUT("/:id", categoryHandler.UpdateCategory)
                categories.DELETE("/:id", categoryHandler.DeleteCategory)
            }
        }
    }

    // Start server
    port := config.GetEnv("SERVER_PORT", "8080")
    log.Printf("Server starting on port %s", port)
    r.Run(":" + port)
}</code></pre>

                    <h4>Penjelasan Main.go Update:</h4>
                    <ul>
                        <li><strong>Category Handler:</strong> Initialize categoryHandler</li>
                        <li><strong>Admin Routes:</strong> Category routes dalam admin group</li>
                        <li><strong>CRUD Endpoints:</strong> POST, GET, PUT, DELETE untuk categories</li>
                        <li><strong>Middleware Chain:</strong> AuthMiddleware -> AdminMiddleware</li>
                        <li><strong>Route Structure:</strong> /api/v1/admin/categories</li>
                    </ul>

                    <h3>📝 Langkah 8: Update Database Config untuk AutoMigrate</h3>
                    <p>Update file <code>config/database.go</code> untuk menambahkan Category model:</p>

                    <pre><code>package config

import (
    "fmt"
    "log"
    "os"
    "tokogo/models"

    "gorm.io/driver/mysql"
    "gorm.io/gorm"
)

var DB *gorm.DB

// InitDB menginisialisasi koneksi database
func InitDB() {
    var err error

    // Konfigurasi database dari environment variables
    dbHost := GetEnv("DB_HOST", "localhost")
    dbPort := GetEnv("DB_PORT", "3306")
    dbUser := GetEnv("DB_USER", "root")
    dbPassword := GetEnv("DB_PASSWORD", "")
    dbName := GetEnv("DB_NAME", "tokogo")

    // Buat DSN (Data Source Name)
    dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local",
        dbUser, dbPassword, dbHost, dbPort, dbName)

    // Koneksi ke database
    DB, err = gorm.Open(mysql.Open(dsn), &gorm.Config{})
    if err != nil {
        log.Fatal("Failed to connect to database:", err)
    }

    log.Println("Database connected successfully")

    // Auto migrate models
    err = DB.AutoMigrate(
        &models.User{},
        &models.Category{},
    )
    if err != nil {
        log.Fatal("Failed to migrate database:", err)
    }

    log.Println("Database migrated successfully")
}
</code></pre>

                    <h4>Penjelasan Database Config Update:</h4>
                    <ul>
                        <li><strong>AutoMigrate:</strong> Menambahkan &models.Category{} ke AutoMigrate</li>
                        <li><strong>Table Creation:</strong> GORM akan membuat tabel categories otomatis</li>
                        <li><strong>Schema Sync:</strong> Database schema akan sync dengan model</li>
                    </ul>

                    <h3>🧪 Testing API Category CRUD</h3>
                    <p>Sekarang mari kita test API category CRUD yang sudah kita buat:</p>

                    <h4>1. Login sebagai Admin (untuk mendapatkan token)</h4>
                    <pre><code>POST http://localhost:8080/api/v1/auth/login
Content-Type: application/json

{
    "email": "admin@example.com",
    "password": "adminpassword"
}</code></pre>

                    <h4>2. Create Category</h4>
                    <pre><code>POST http://localhost:8080/api/v1/admin/categories
Authorization: Bearer {admin_jwt_token}
Content-Type: application/json

{
    "name": "Electronics"
}</code></pre>

                    <h4>Response Sukses (201 Created):</h4>
                    <pre><code>{
    "message": "Category created successfully",
    "data": {
        "id": 1,
        "name": "Electronics",
        "slug": "electronics",
        "created_at": "2024-01-15 10:30:00",
        "updated_at": "2024-01-15 10:30:00"
    }
}</code></pre>

                    <h4>3. Get All Categories</h4>
                    <pre><code>GET http://localhost:8080/api/v1/admin/categories?page=1&limit=10
Authorization: Bearer {admin_jwt_token}</code></pre>

                    <h4>4. Get Category by ID</h4>
                    <pre><code>GET http://localhost:8080/api/v1/admin/categories/1
Authorization: Bearer {admin_jwt_token}</code></pre>

                    <h4>5. Update Category</h4>
                    <pre><code>PUT http://localhost:8080/api/v1/admin/categories/1
Authorization: Bearer {admin_jwt_token}
Content-Type: application/json

{
    "name": "Electronic Devices"
}</code></pre>

                    <h4>6. Delete Category</h4>
                    <pre><code>DELETE http://localhost:8080/api/v1/admin/categories/1
Authorization: Bearer {admin_jwt_token}</code></pre>

                    <h4>Response Sukses (200 OK):</h4>
                    <pre><code>{
    "message": "Category deleted successfully",
    "data": null
}</code></pre>

                    <h4>7. Test dengan Customer Role (403 Forbidden)</h4>
                    <pre><code>POST http://localhost:8080/api/v1/admin/categories
Authorization: Bearer {customer_jwt_token}
Content-Type: application/json

{
    "name": "Test Category"
}</code></pre>

                    <h4>Response Error (403 Forbidden):</h4>
                    <pre><code>{
    "error": "forbidden",
    "message": "Admin access required"
}</code></pre>

                    <h3>✅ Checklist Implementasi Category CRUD</h3>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>File yang Harus Dibuat:</h4>
                        <ul>
                            <li>✅ models/category.go (Category model)</li>
                            <li>✅ requests/category_request.go (Request structs)</li>
                            <li>✅ responses/category_response.go (Response structs)</li>
                            <li>✅ repositories/category_repository.go (Database operations)</li>
                            <li>✅ services/category_service.go (Business logic)</li>
                            <li>✅ handlers/category_handler.go (HTTP handlers)</li>
                        </ul>
                        
                        <h4>File yang Harus Diupdate:</h4>
                        <ul>
                            <li>✅ config/database.go (AutoMigrate Category)</li>
                            <li>✅ main.go (Category routes)</li>
                        </ul>
                    </div>

                    <h3>🚀 Cara Menjalankan</h3>
                    <ol>
                        <li>Pastikan MySQL sudah berjalan</li>
                        <li>Pastikan database 'tokogo' sudah dibuat</li>
                        <li>Pastikan ada user dengan role admin</li>
                        <li>Jalankan: <code>go run main.go</code></li>
                        <li>Test dengan Postman atau curl</li>
                    </ol>

                    <h3>🎯 Fitur Category CRUD yang Sudah Diimplementasikan</h3>
                    <ul>
                        <li>✅ Create Category dengan validasi nama</li>
                        <li>✅ Read Category (Get by ID, Get All dengan pagination)</li>
                        <li>✅ Update Category dengan validasi nama</li>
                        <li>✅ Delete Category (soft delete)</li>
                        <li>✅ Auto-generate slug dari nama</li>
                        <li>✅ Duplicate name validation</li>
                        <li>✅ Admin-only access control</li>
                        <li>✅ Pagination support</li>
                    </ul>

                    <h3>🔒 Keamanan yang Diimplementasikan</h3>
                    <ul>
                        <li>✅ Admin-only access dengan AdminMiddleware</li>
                        <li>✅ JWT token validation</li>
                        <li>✅ Input validation dengan go-playground/validator</li>
                        <li>✅ SQL injection protection (GORM)</li>
                        <li>✅ Soft delete untuk data integrity</li>
                        <li>✅ Duplicate name prevention</li>
                        <li>✅ Proper error handling</li>
                    </ul>

                    <h3>🎉 Selamat!</h3>
                    <p>Anda telah berhasil mengimplementasikan modul CRUD Kategori yang lengkap! Sistem manajemen kategori sudah siap untuk digunakan dan hanya bisa diakses oleh admin. Fitur ini dapat diintegrasikan dengan modul Product Management di bab selanjutnya.</p>

                    <div style="text-align: center; margin: 3rem 0;">
                        <div style="background: #f8f9fa; border: 1px solid #dee2e6; color: #2c3e50; padding: 2rem; border-radius: 5px; display: inline-block;">
                            <h3 style="color: #2c3e50; margin-bottom: 1rem;">🎯 Siap untuk Modul Selanjutnya?</h3>
                            <p style="color: #495057; margin-bottom: 0;">Dengan sistem CRUD Kategori yang lengkap, Anda siap untuk melanjutkan ke modul Product Management yang akan menggunakan kategori ini!</p>
                        </div>
                    </div>
                `
            },
            {
                id: 'chapter11',
                title: 'Bab 11: Modul CRUD Product - Role Admin',
                meta: 'Halaman 11 dari 50 • Dibaca 15 menit',
                content: `
                    <h2>📦 Bab 11: Modul CRUD Product - Role Admin</h2>
                    <p>Selamat! Sekarang kita akan membuat modul CRUD (Create, Read, Update, Delete) untuk Product yang hanya bisa diakses oleh admin. Di bab ini, kita akan mengimplementasikan sistem manajemen produk dengan role-based access control dan relasi dengan kategori.</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">🎯 Apa yang Akan Kita Buat di Bab Ini?</h3>
                        <p style="color: #495057; margin-bottom: 0;">Kita akan membuat sistem CRUD produk yang lengkap dengan Create, Read, Update, Delete operations. Semua endpoint hanya bisa diakses oleh admin. Produk akan memiliki relasi dengan kategori dan fitur manajemen stok.</p>
                    </div>

                    <h3>📋 Prasyarat</h3>
                    <p>Sebelum memulai, pastikan Anda sudah menyelesaikan:</p>
                    <ul>
                        <li>✅ Bab 6-8: Modul Authentication (Register, Login, Logout)</li>
                        <li>✅ Bab 9: Review Pembelajaran Authentication</li>
                        <li>✅ Bab 10: Modul CRUD Kategori - Role Admin</li>
                        <li>✅ Middleware authentication sudah berfungsi</li>
                        <li>✅ AdminMiddleware sudah diimplementasikan</li>
                        <li>✅ Tabel categories sudah ada di database</li>
                    </ul>

                    <h3>🗄️ Database Schema - Tabel Products</h3>
                    <p>Pertama, kita perlu membuat tabel products dengan struktur sebagai berikut:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>📊 Struktur Tabel Products</h4>
                        <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                            <thead>
                                <tr style="background-color: #e9ecef;">
                                    <th style="border: 1px solid #dee2e6; padding: 0.75rem; text-align: left;">Field</th>
                                    <th style="border: 1px solid #dee2e6; padding: 0.75rem; text-align: left;">Type</th>
                                    <th style="border: 1px solid #dee2e6; padding: 0.75rem; text-align: left;">Constraint</th>
                                    <th style="border: 1px solid #dee2e6; padding: 0.75rem; text-align: left;">Description</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">id</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">BIGINT</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">PK, Auto Increment</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Primary key</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">name</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">VARCHAR</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">NOT NULL</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Nama produk</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">description</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">TEXT</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">NULL</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Deskripsi produk</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">purchase_price</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">DECIMAL(10,2)</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">NOT NULL</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Harga beli</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">selling_price</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">DECIMAL(10,2)</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">NOT NULL</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Harga jual</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">stock</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">INT</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">NOT NULL, DEFAULT 0</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Stok produk</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">category_id</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">BIGINT</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">FK → Categories(id)</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">ID kategori</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">image_url</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">VARCHAR(255)</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">NULL</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">URL gambar produk (opsional)</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">created_at</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">TIMESTAMP</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">DEFAULT CURRENT_TIMESTAMP</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Waktu dibuat</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">updated_at</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">TIMESTAMP</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Waktu diupdate</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <h4>🔧 SQL untuk Membuat Tabel Products</h4>
                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>CREATE TABLE products (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    purchase_price DECIMAL(10,2) NOT NULL,
    selling_price DECIMAL(10,2) NOT NULL,
    stock INT NOT NULL DEFAULT 0,
    category_id BIGINT NOT NULL,
    image_url VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (category_id) REFERENCES categories(id) ON DELETE CASCADE
);</code></pre>

                    <h3>📁 Struktur File yang Akan Dibuat</h3>
                    <p>Kita akan membuat file-file berikut untuk modul Product:</p>
                    <ul>
                        <li><code>models/product.go</code> - Model Product</li>
                        <li><code>requests/product_request.go</code> - Request structs</li>
                        <li><code>responses/product_response.go</code> - Response structs</li>
                        <li><code>repositories/product_repository.go</code> - Database operations</li>
                        <li><code>services/product_service.go</code> - Business logic</li>
                        <li><code>handlers/product_handler.go</code> - HTTP handlers</li>
                    </ul>

                    <h3>🏗️ Langkah 1: Membuat Model Product</h3>
                    <p>Buat file <code>models/product.go</code>:</p>

                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>package models

import "time"

type Product struct {
    ID            uint      \`json:"id" gorm:"primaryKey"\`
    Name          string    \`json:"name" gorm:"not null"\`
    Description   string    \`json:"description"\`
    PurchasePrice float64   \`json:"purchase_price" gorm:"not null;type:decimal(10,2)"\`
    SellingPrice  float64   \`json:"selling_price" gorm:"not null;type:decimal(10,2)"\`
    Stock         int       \`json:"stock" gorm:"not null;default:0"\`
    CategoryID    uint      \`json:"category_id" gorm:"not null"\`
    Category      Category  \`json:"category" gorm:"foreignKey:CategoryID"\`
    ImageURL      string    \`json:"image_url"\`
    CreatedAt     time.Time \`json:"created_at"\`
    UpdatedAt     time.Time \`json:"updated_at"\`
}

func (Product) TableName() string {
    return "products"
}</code></pre>

                    <h4>📝 Penjelasan Model Product:</h4>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h5 style="color: #2c3e50; margin-bottom: 1rem;">🔍 Struktur Model yang Diimplementasikan</h5>
                        
                        <p><strong>1. Product Struct Fields:</strong></p>
                        <ul>
                            <li><code>ID</code> - Primary key dengan auto increment (uint)</li>
                            <li><code>Name</code> - Nama produk (string, required)</li>
                            <li><code>Description</code> - Deskripsi produk (string, optional)</li>
                            <li><code>PurchasePrice</code> - Harga beli dengan 2 desimal (float64, required)</li>
                            <li><code>SellingPrice</code> - Harga jual dengan 2 desimal (float64, required)</li>
                            <li><code>Stock</code> - Jumlah stok dengan default 0 (int, required)</li>
                            <li><code>CategoryID</code> - Foreign key ke tabel categories (uint, required)</li>
                            <li><code>Category</code> - Relasi ke model Category (struct, optional)</li>
                            <li><code>ImageURL</code> - URL gambar produk (string, optional)</li>
                            <li><code>CreatedAt</code> - Timestamp pembuatan (time.Time)</li>
                            <li><code>UpdatedAt</code> - Timestamp update (time.Time)</li>
                        </ul>

                        <p><strong>2. GORM Tags:</strong></p>
                        <ul>
                            <li><code>primaryKey</code> - Menandai field sebagai primary key</li>
                            <li><code>not null</code> - Field wajib diisi</li>
                            <li><code>type:decimal(10,2)</code> - Tipe data decimal dengan 10 digit, 2 desimal</li>
                            <li><code>default:0</code> - Nilai default untuk stok</li>
                            <li><code>foreignKey:CategoryID</code> - Menentukan foreign key untuk relasi</li>
                        </ul>

                        <p><strong>3. TableName Method:</strong></p>
                        <ul>
                            <li>Mengembalikan nama tabel "products" secara eksplisit</li>
                            <li>Memastikan GORM menggunakan nama tabel yang benar</li>
                        </ul>

                        <p style="color: #495057; margin-bottom: 0;"><strong>💡 Keuntungan:</strong> Model ini mendefinisikan struktur data yang konsisten dengan database dan menyediakan relasi yang jelas dengan Category.</p>
                    </div>

                    <h3>📝 Langkah 2: Membuat Request Structs</h3>
                    <p>Buat file <code>requests/product_request.go</code>:</p>
                    
                    <div style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 1rem; margin: 2rem 0;">
                        <strong>💡 Perubahan Penting:</strong> Untuk image, kita akan menggunakan file upload instead of URL. Field ImageURL sudah dihapus dari request struct karena akan ditangani secara terpisah melalui file upload.
                    </div>

                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>package requests

import (
    "errors"
    "strings"

    "github.com/go-playground/validator/v10"
)

// CreateProductRequest represents the request structure for creating product
type CreateProductRequest struct {
    Name          string  \`json:"name" validate:"required,min=3,max=255"\`
    Description   string  \`json:"description"\`
    PurchasePrice float64 \`json:"purchase_price" validate:"required,min=0"\`
    SellingPrice  float64 \`json:"selling_price" validate:"required,min=0"\`
    Stock         int     \`json:"stock" validate:"min=0"\`
    CategoryID    uint    \`json:"category_id" validate:"required"\`
}

// UpdateProductRequest represents the request structure for updating product
type UpdateProductRequest struct {
    Name          string  \`json:"name" validate:"required,min=3,max=255"\`
    Description   string  \`json:"description"\`
    PurchasePrice float64 \`json:"purchase_price" validate:"required,min=0"\`
    SellingPrice  float64 \`json:"selling_price" validate:"required,min=0"\`
    Stock         int     \`json:"stock" validate:"min=0"\`
    CategoryID    uint    \`json:"category_id" validate:"required"\`
}

// Validate validates the CreateProductRequest using the validator
func (r *CreateProductRequest) Validate() error {
    validate := validator.New()

    // Validasi struct fields
    if err := validate.Struct(r); err != nil {
        return err
    }

    // Validasi custom: nama tidak boleh kosong setelah trim
    if strings.TrimSpace(r.Name) == "" {
        return errors.New("name cannot be empty")
    }

    // Validasi custom: selling price harus lebih besar dari purchase price
    if r.SellingPrice <= r.PurchasePrice {
        return errors.New("selling price must be greater than purchase price")
    }

    return nil
}

// Validate validates the UpdateProductRequest using the validator
func (r *UpdateProductRequest) Validate() error {
    validate := validator.New()

    // Validasi struct fields
    if err := validate.Struct(r); err != nil {
        return err
    }

    // Validasi custom: nama tidak boleh kosong setelah trim
    if strings.TrimSpace(r.Name) == "" {
        return errors.New("name cannot be empty")
    }

    // Validasi custom: selling price harus lebih besar dari purchase price
    if r.SellingPrice <= r.PurchasePrice {
        return errors.New("selling price must be greater than purchase price")
    }

    return nil
}</code></pre>

                    <h4>📝 Penjelasan Request Structs:</h4>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h5 style="color: #2c3e50; margin-bottom: 1rem;">🔍 Struktur Request yang Diimplementasikan</h5>
                        
                        <p><strong>1. CreateProductRequest Struct:</strong></p>
                        <ul>
                            <li><code>Name</code> - Nama produk (required, min 3, max 255 karakter)</li>
                            <li><code>Description</code> - Deskripsi produk (optional)</li>
                            <li><code>PurchasePrice</code> - Harga beli (required, minimal 0)</li>
                            <li><code>SellingPrice</code> - Harga jual (required, minimal 0)</li>
                            <li><code>Stock</code> - Jumlah stok (minimal 0)</li>
                            <li><code>CategoryID</code> - ID kategori (required)</li>
                            <li><strong>Image:</strong> File gambar produk akan diupload secara terpisah (tidak termasuk dalam request struct)</li>
                        </ul>

                        <p><strong>2. UpdateProductRequest Struct:</strong></p>
                        <ul>
                            <li>Struktur yang sama dengan CreateProductRequest</li>
                            <li>Digunakan untuk update data produk yang sudah ada</li>
                            <li>Validasi yang sama untuk memastikan data konsisten</li>
                        </ul>

                        <p><strong>3. Validator Tags:</strong></p>
                        <ul>
                            <li><code>validate:"required"</code> - Field wajib diisi</li>
                            <li><code>validate:"min=3,max=255"</code> - Panjang string minimal 3, maksimal 255</li>
                            <li><code>validate:"min=0"</code> - Nilai numerik minimal 0</li>
                            <li>Validasi menggunakan go-playground/validator</li>
                        </ul>

                        <p><strong>4. Custom Validation Methods:</strong></p>
                        <ul>
                            <li><code>Validate()</code> - Method untuk validasi custom</li>
                            <li>Validasi nama tidak boleh kosong setelah trim</li>
                            <li>Validasi selling price harus lebih besar dari purchase price</li>
                            <li>Konsisten dengan pattern category</li>
                        </ul>

                        <p style="color: #495057; margin-bottom: 0;"><strong>💡 Keuntungan:</strong> Request structs dengan method Validate() memisahkan input validation dari business logic, memastikan data yang masuk sudah valid, dan mengikuti pattern yang konsisten dengan category.</p>
                    </div>

                    <h3>📤 Langkah 3: Membuat Response Structs</h3>
                    <p>Buat file <code>responses/product_response.go</code>:</p>

                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>package responses

import "tokogo/models"

type ProductResponse struct {
    ID            uint    \`json:"id"\`
    Name          string  \`json:"name"\`
    Description   string  \`json:"description"\`
    PurchasePrice float64 \`json:"purchase_price"\`
    SellingPrice  float64 \`json:"selling_price"\`
    Stock         int     \`json:"stock"\`
    CategoryID    uint    \`json:"category_id"\`
    CategoryName  string  \`json:"category_name"\`
    ImagePath     string  \`json:"image_path"\`
    CreatedAt     string  \`json:"created_at"\`
    UpdatedAt     string  \`json:"updated_at"\`
}

type ProductListResponse struct {
    Products []ProductResponse \`json:"products"\`
    Total    int64             \`json:"total"\`
    Page     int               \`json:"page"\`
    Limit    int               \`json:"limit"\`
}

func ConvertProductToResponse(product models.Product) ProductResponse {
    return ProductResponse{
        ID:            product.ID,
        Name:          product.Name,
        Description:   product.Description,
        PurchasePrice: product.PurchasePrice,
        SellingPrice:  product.SellingPrice,
        Stock:         product.Stock,
        CategoryID:    product.CategoryID,
        CategoryName:  product.Category.Name,
        ImagePath:     product.ImagePath,
        CreatedAt:     product.CreatedAt.Format("2006-01-02 15:04:05"),
        UpdatedAt:     product.UpdatedAt.Format("2006-01-02 15:04:05"),
    }
}

func ConvertProductsToResponse(products []models.Product) []ProductResponse {
    var responses []ProductResponse
    for _, product := range products {
        responses = append(responses, ConvertProductToResponse(product))
    }
    return responses
}</code></pre>

                    <h4>📝 Penjelasan Response Structs:</h4>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h5 style="color: #2c3e50; margin-bottom: 1rem;">🔍 Struktur Response yang Diimplementasikan</h5>
                        
                        <p><strong>1. ProductResponse Struct:</strong></p>
                        <ul>
                            <li><code>ID</code> - ID unik produk (uint)</li>
                            <li><code>Name</code> - Nama produk</li>
                            <li><code>Description</code> - Deskripsi produk</li>
                            <li><code>PurchasePrice</code> - Harga beli (float64)</li>
                            <li><code>SellingPrice</code> - Harga jual (float64)</li>
                            <li><code>Stock</code> - Jumlah stok (int)</li>
                            <li><code>CategoryID</code> - ID kategori (uint)</li>
                            <li><code>CategoryName</code> - Nama kategori (string) - diambil dari relasi</li>
                            <li><code>ImagePath</code> - Path file gambar produk (untuk file upload)</li>
                            <li><code>CreatedAt</code> - Waktu dibuat (format string "2006-01-02 15:04:05")</li>
                            <li><code>UpdatedAt</code> - Waktu diupdate (format string "2006-01-02 15:04:05")</li>
                        </ul>

                        <p><strong>2. ProductListResponse Struct:</strong></p>
                        <ul>
                            <li><code>Products</code> - Array dari ProductResponse</li>
                            <li><code>Total</code> - Total jumlah produk (int64)</li>
                            <li><code>Page</code> - Halaman saat ini (int)</li>
                            <li><code>Limit</code> - Jumlah item per halaman (int)</li>
                        </ul>

                        <p><strong>3. Helper Functions:</strong></p>
                        <ul>
                            <li><code>ConvertProductToResponse()</code> - Mengkonversi model Product ke ProductResponse</li>
                            <li><code>ConvertProductsToResponse()</code> - Mengkonversi array model Product ke array ProductResponse</li>
                            <li>Format tanggal menggunakan "2006-01-02 15:04:05" untuk konsistensi</li>
                            <li>Konsisten dengan pattern category response</li>
                        </ul>

                        <p style="color: #495057; margin-bottom: 0;"><strong>💡 Keuntungan:</strong> Helper functions memudahkan konversi data, memastikan konsistensi response format di seluruh aplikasi, dan mengikuti pattern yang sama dengan category untuk maintainability yang lebih baik.</p>
                    </div>

                    <h3>📁 Langkah 4: Membuat File Upload Helper</h3>
                    <p>Buat file <code>helpers/file_upload.go</code> untuk menangani file upload:</p>
                    
                  
                    
                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>package helpers

import (
    "fmt"
    "io"
    "mime/multipart"
    "os"
    "path/filepath"
    "strings"
    "time"
)

// UploadFile handles file upload and returns the file path
func UploadFile(file *multipart.FileHeader, uploadDir string) (string, error) {
    // Create upload directory if it doesn't exist
    if err := os.MkdirAll(uploadDir, 0755); err != nil {
        return "", fmt.Errorf("failed to create upload directory: %v", err)
    }

    // Validate file type
    allowedTypes := []string{"image/jpeg", "image/jpg", "image/png", "image/gif"}
    contentType := file.Header.Get("Content-Type")
    if !isAllowedType(contentType, allowedTypes) {
        return "", fmt.Errorf("file type not allowed. Allowed types: %v", allowedTypes)
    }

    // Validate file size (max 5MB)
    maxSize := int64(5 * 1024 * 1024) // 5MB
    if file.Size > maxSize {
        return "", fmt.Errorf("file size too large. Maximum size: 5MB")
    }

    // Generate unique filename
    ext := filepath.Ext(file.Filename)
    filename := fmt.Sprintf("%d_%s%s", time.Now().Unix(), generateRandomString(10), ext)
    filePath := filepath.Join(uploadDir, filename)

    // Open uploaded file
    src, err := file.Open()
    if err != nil {
        return "", fmt.Errorf("failed to open uploaded file: %v", err)
    }
    defer src.Close()

    // Create destination file
    dst, err := os.Create(filePath)
    if err != nil {
        return "", fmt.Errorf("failed to create destination file: %v", err)
    }
    defer dst.Close()

    // Copy file content
    if _, err := io.Copy(dst, src); err != nil {
        return "", fmt.Errorf("failed to copy file: %v", err)
    }

    // Return relative path for database storage
    return filePath, nil
}

// DeleteFile deletes a file from the filesystem
func DeleteFile(filePath string) error {
    if filePath == "" {
        return nil
    }
    
    if err := os.Remove(filePath); err != nil && !os.IsNotExist(err) {
        return fmt.Errorf("failed to delete file: %v", err)
    }
    
    return nil
}

// isAllowedType checks if the content type is in the allowed list
func isAllowedType(contentType string, allowedTypes []string) bool {
    for _, allowedType := range allowedTypes {
        if contentType == allowedType {
            return true
        }
    }
    return false
}

// generateRandomString generates a random string of specified length
func generateRandomString(length int) string {
    const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    b := make([]byte, length)
    for i := range b {
        b[i] = charset[time.Now().UnixNano()%int64(len(charset))]
    }
    return string(b)
}</code></pre>

                    <h4>📝 Penjelasan File Upload Helper:</h4>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h5 style="color: #2c3e50; margin-bottom: 1rem;">🔍 Fungsi File Upload yang Diimplementasikan</h5>
                        
                        <p><strong>1. UploadFile Function:</strong></p>
                        <ul>
                            <li>Membuat direktori upload jika belum ada</li>
                            <li>Validasi tipe file (hanya image: jpeg, jpg, png, gif)</li>
                            <li>Validasi ukuran file (maksimal 5MB)</li>
                            <li>Generate nama file unik dengan timestamp</li>
                            <li>Menyimpan file ke direktori yang ditentukan</li>
                        </ul>

                        <p><strong>2. DeleteFile Function:</strong></p>
                        <ul>
                            <li>Menghapus file dari filesystem</li>
                            <li>Menangani error jika file tidak ada</li>
                            <li>Digunakan untuk cleanup saat update/delete</li>
                        </ul>

                        <p><strong>3. Helper Functions:</strong></p>
                        <ul>
                            <li><code>isAllowedType()</code> - Validasi tipe file</li>
                            <li><code>generateRandomString()</code> - Generate string random untuk nama file</li>
                        </ul>

                        <p style="color: #495057; margin-bottom: 0;"><strong>💡 Keuntungan:</strong> Helper ini memastikan file upload yang aman dengan validasi tipe file, ukuran, dan nama file yang unik untuk menghindari konflik.</p>
                    </div>

                    <h3>🗄️ Langkah 5: Membuat Repository</h3>
                    <p>Buat file <code>repositories/product_repository.go</code>:</p>

                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>package repositories

import (
    "tokogo/models"
    "gorm.io/gorm"
)

type ProductRepository struct {
    db *gorm.DB
}

func NewProductRepository(db *gorm.DB) *ProductRepository {
    return &ProductRepository{db: db}
}

func (r *ProductRepository) Create(product *models.Product) error {
    return r.db.Create(product).Error
}

func (r *ProductRepository) GetAll(page, limit int) ([]models.Product, int64, error) {
    var products []models.Product
    var total int64

    offset := (page - 1) * limit

    // Count total records
    if err := r.db.Model(&models.Product{}).Count(&total).Error; err != nil {
        return nil, 0, err
    }

    // Get products with pagination
    err := r.db.Preload("Category").
        Offset(offset).
        Limit(limit).
        Find(&products).Error

    return products, total, err
}

func (r *ProductRepository) GetByID(id uint) (*models.Product, error) {
    var product models.Product
    err := r.db.Preload("Category").First(&product, id).Error
    return &product, err
}

func (r *ProductRepository) Update(product *models.Product) error {
    return r.db.Save(product).Error
}

func (r *ProductRepository) Delete(id uint) error {
    return r.db.Delete(&models.Product{}, id).Error
}

func (r *ProductRepository) GetByCategoryID(categoryID uint, page, limit int) ([]models.Product, int64, error) {
    var products []models.Product
    var total int64

    offset := (page - 1) * limit

    // Count total records
    if err := r.db.Model(&models.Product{}).Where("category_id = ?", categoryID).Count(&total).Error; err != nil {
        return nil, 0, err
    }

    // Get products with pagination
    err := r.db.Preload("Category").
        Where("category_id = ?", categoryID).
        Offset(offset).
        Limit(limit).
        Find(&products).Error

    return products, total, err
}</code></pre>

                    <h4>📝 Penjelasan Repository:</h4>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h5 style="color: #2c3e50; margin-bottom: 1rem;">🔍 Struktur Repository yang Diimplementasikan</h5>
                        
                        <p><strong>1. ProductRepository Struct:</strong></p>
                        <ul>
                            <li>Menggunakan dependency injection untuk database connection</li>
                            <li>Mengisolasi semua operasi database dalam satu layer</li>
                            <li>Menggunakan GORM untuk ORM operations</li>
                        </ul>

                        <p><strong>2. Constructor Function:</strong></p>
                        <ul>
                            <li><code>NewProductRepository()</code> - Factory function untuk membuat instance repository</li>
                            <li>Menerima database connection sebagai parameter</li>
                            <li>Mengembalikan pointer ke ProductRepository</li>
                        </ul>

                        <p><strong>3. CRUD Operations:</strong></p>
                        <ul>
                            <li><code>Create()</code> - Membuat produk baru di database</li>
                            <li><code>GetAll()</code> - Mengambil semua produk dengan pagination dan relasi Category</li>
                            <li><code>GetByID()</code> - Mengambil produk berdasarkan ID dengan relasi Category</li>
                            <li><code>Update()</code> - Mengupdate data produk yang sudah ada</li>
                            <li><code>Delete()</code> - Menghapus produk berdasarkan ID</li>
                            <li><code>GetByCategoryID()</code> - Mengambil produk berdasarkan kategori dengan pagination</li>
                        </ul>

                        <p><strong>4. GORM Features:</strong></p>
                        <ul>
                            <li><code>Preload("Category")</code> - Eager loading untuk relasi Category</li>
                            <li><code>Offset()</code> dan <code>Limit()</code> - Implementasi pagination</li>
                            <li><code>Where()</code> - Filter berdasarkan kondisi tertentu</li>
                            <li><code>Count()</code> - Menghitung total records untuk pagination</li>
                        </ul>

                        <p style="color: #495057; margin-bottom: 0;"><strong>💡 Keuntungan:</strong> Repository pattern memisahkan data access logic dari business logic, memudahkan testing, dan menyediakan interface yang konsisten untuk operasi database.</p>
                    </div>

                    <h3>⚙️ Langkah 6: Membuat Service</h3>
                    <p>Buat file <code>services/product_service.go</code>:</p>

                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>package services

import (
	"errors"
	"tokogo/config"
	"tokogo/helpers"
	"tokogo/models"
	"tokogo/repositories"
	"tokogo/requests"
	"tokogo/responses"
)

type ProductService struct {
	productRepo  *repositories.ProductRepository
	categoryRepo *repositories.CategoryRepository
}

// NewProductService membuat instance baru ProductService
func NewProductService() *ProductService {
	return &ProductService{
		productRepo:  repositories.NewProductRepository(config.DB),
		categoryRepo: repositories.NewCategoryRepository(),
	}
}

// CreateProduct membuat product baru
func (s *ProductService) CreateProduct(req requests.CreateProductRequest, imagePath string) (*responses.ProductResponse, error) {
	// Cek apakah category ada
	_, err := s.categoryRepo.GetCategoryByID(req.CategoryID)
	if err != nil {
		return nil, errors.New("category not found")
	}

	// Buat product baru
	product := &models.Product{
		Name:          req.Name,
		Description:   req.Description,
		PurchasePrice: req.PurchasePrice,
		SellingPrice:  req.SellingPrice,
		Stock:         req.Stock,
		CategoryID:    req.CategoryID,
		ImagePath:     imagePath,
	}

	// Simpan ke database
	if err := s.productRepo.Create(product); err != nil {
		// If database save fails, delete uploaded file
		if imagePath != "" {
			helpers.DeleteFile(imagePath)
		}
		return nil, errors.New("failed to create product")
	}

	// Return response
	response := responses.ConvertProductToResponse(*product)
	return &response, nil
}

func (s *ProductService) GetAllProducts(page, limit int) (*responses.ProductListResponse, error) {
	if page < 1 {
		page = 1
	}
	if limit < 1 {
		limit = 10
	}

	products, total, err := s.productRepo.GetAll(page, limit)
	if err != nil {
		return nil, err
	}

	productResponses := responses.ConvertProductsToResponse(products)

	return &responses.ProductListResponse{
		Products: productResponses,
		Total:    total,
		Page:     page,
		Limit:    limit,
	}, nil
}

func (s *ProductService) GetProductByID(id uint) (*responses.ProductResponse, error) {
	product, err := s.productRepo.GetByID(id)
	if err != nil {
		return nil, err
	}

	response := responses.ConvertProductToResponse(*product)
	return &response, nil
}

func (s *ProductService) UpdateProduct(id uint, req requests.UpdateProductRequest) (*responses.ProductResponse, error) {
	// Get existing product
	product, err := s.productRepo.GetByID(id)
	if err != nil {
		return nil, err
	}

	// Validate category exists
	_, err = s.categoryRepo.GetCategoryByID(req.CategoryID)
	if err != nil {
		return nil, errors.New("category not found")
	}

	// Update product fields
	product.Name = req.Name
	product.Description = req.Description
	product.PurchasePrice = req.PurchasePrice
	product.SellingPrice = req.SellingPrice
	product.Stock = req.Stock
	product.CategoryID = req.CategoryID
	product.ImageURL = req.ImageURL

	if err := s.productRepo.Update(product); err != nil {
		return nil, err
	}

	response := responses.ConvertProductToResponse(*product)
	return &response, nil
}

func (s *ProductService) DeleteProduct(id uint) error {
	// Check if product exists
	_, err := s.productRepo.GetByID(id)
	if err != nil {
		return err
	}

	return s.productRepo.Delete(id)
}

func (s *ProductService) GetProductsByCategory(categoryID uint, page, limit int) (*responses.ProductListResponse, error) {
	if page < 1 {
		page = 1
	}
	if limit < 1 {
		limit = 10
	}

	products, total, err := s.productRepo.GetByCategoryID(categoryID, page, limit)
	if err != nil {
		return nil, err
	}

	productResponses := responses.ConvertProductsToResponse(products)

	return &responses.ProductListResponse{
		Products: productResponses,
		Total:    total,
		Page:     page,
		Limit:    limit,
	}, nil
}


                        </code></pre>

                    <h4>📝 Penjelasan Service:</h4>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h5 style="color: #2c3e50; margin-bottom: 1rem;">🔍 Struktur Service yang Diimplementasikan</h5>
                        
                        <p><strong>1. ProductService Struct:</strong></p>
                        <ul>
                            <li>Menggunakan dependency injection untuk repository dependencies</li>
                            <li>Mengisolasi business logic dari data access layer</li>
                            <li>Menggunakan ProductRepository dan CategoryRepository</li>
                        </ul>

                        <p><strong>2. Constructor Function:</strong></p>
                        <ul>
                            <li><code>NewProductService()</code> - Factory function untuk membuat instance service</li>
                            <li>Menerima repository dependencies sebagai parameter</li>
                            <li>Mengembalikan pointer ke ProductService</li>
                        </ul>

                        <p><strong>3. Business Logic Methods:</strong></p>
                        <ul>
                            <li><code>CreateProduct()</code> - Validasi kategori dan membuat produk baru</li>
                            <li><code>GetAllProducts()</code> - Mengambil semua produk dengan pagination</li>
                            <li><code>GetProductByID()</code> - Mengambil produk berdasarkan ID</li>
                            <li><code>UpdateProduct()</code> - Validasi dan update data produk</li>
                            <li><code>DeleteProduct()</code> - Validasi dan hapus produk</li>
                            <li><code>GetProductsByCategory()</code> - Mengambil produk berdasarkan kategori</li>
                        </ul>

                        <p><strong>4. Business Rules:</strong></p>
                        <ul>
                            <li>Validasi kategori harus ada sebelum membuat/update produk</li>
                            <li>Default pagination (page=1, limit=10) jika parameter tidak valid</li>
                            <li>Menggunakan helper functions dari responses package</li>
                            <li>Error handling yang konsisten</li>
                        </ul>

                        <p style="color: #495057; margin-bottom: 0;"><strong>💡 Keuntungan:</strong> Service layer mengimplementasikan business logic, validasi, dan koordinasi antara repository dan response layer, memisahkan concerns dengan jelas.</p>
                    </div>

                    <h3>🌐 Langkah 7: Membuat Handler</h3>
                    <p>Buat file <code>handlers/product_handler.go</code>:</p>

                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>package handlers

import (
    "net/http"
    "strconv"
    "tokogo/helpers"
    "tokogo/requests"
    "tokogo/responses"
    "tokogo/services"

    "github.com/gin-gonic/gin"
)

type ProductHandler struct {
    productService *services.ProductService
}

// NewProductHandler membuat instance baru ProductHandler
func NewProductHandler() *ProductHandler {
    return &ProductHandler{
        productService: services.NewProductService(),
    }
}

// CreateProduct handler untuk membuat product baru
func (h *ProductHandler) CreateProduct(c *gin.Context) {
    var req requests.CreateProductRequest

    // Bind form data (including file upload)
    if err := c.ShouldBind(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Validasi menggunakan method Validate()
    if err := req.Validate(); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Handle file upload
    var imagePath string
    if file, err := c.FormFile("image"); err == nil {
        // File was uploaded
        uploadDir := "./uploads/products"
        uploadedPath, err := helpers.UploadFile(file, uploadDir)
        if err != nil {
            c.JSON(http.StatusBadRequest, responses.ErrorResponse{
                Error:   "upload_failed",
                Message: err.Error(),
            })
            return
        }
        imagePath = uploadedPath
    }

    // Panggil service untuk create product
    productResponse, err := h.productService.CreateProduct(req, imagePath)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "create_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusCreated, responses.SuccessResponse{
        Message: "Product created successfully",
        Data:    productResponse,
    })
}

// GetAllProducts godoc
// @Summary Get all products
// @Description Get all products with pagination (Admin only)
// @Tags Products
// @Produce json
// @Param page query int false "Page number" default(1)
// @Param limit query int false "Items per page" default(10)
// @Success 200 {object} responses.ProductListResponse
// @Failure 401 {object} map[string]string
// @Failure 403 {object} map[string]string
// @Router /admin/products [get]
func (h *ProductHandler) GetAllProducts(c *gin.Context) {
    page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
    limit, _ := strconv.Atoi(c.DefaultQuery("limit", "10"))

    products, err := h.productService.GetAllProducts(page, limit)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusOK, products)
}

// GetProductByID godoc
// @Summary Get product by ID
// @Description Get a specific product by ID (Admin only)
// @Tags Products
// @Produce json
// @Param id path int true "Product ID"
// @Success 200 {object} responses.ProductResponse
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 403 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /admin/products/{id} [get]
func (h *ProductHandler) GetProductByID(c *gin.Context) {
    id, err := strconv.ParseUint(c.Param("id"), 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid product ID"})
        return
    }

    product, err := h.productService.GetProductByID(uint(id))
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": "Product not found"})
        return
    }

    c.JSON(http.StatusOK, product)
}

// UpdateProduct godoc
// @Summary Update product
// @Description Update a product by ID (Admin only)
// @Tags Products
// @Accept json
// @Produce json
// @Param id path int true "Product ID"
// @Param product body requests.UpdateProductRequest true "Product data"
// @Success 200 {object} responses.ProductResponse
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 403 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /admin/products/{id} [put]
func (h *ProductHandler) UpdateProduct(c *gin.Context) {
    id, err := strconv.ParseUint(c.Param("id"), 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid product ID"})
        return
    }

    var req requests.UpdateProductRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    product, err := h.productService.UpdateProduct(uint(id), req)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusOK, product)
}

// DeleteProduct godoc
// @Summary Delete product
// @Description Delete a product by ID (Admin only)
// @Tags Products
// @Produce json
// @Param id path int true "Product ID"
// @Success 200 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 403 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /admin/products/{id} [delete]
func (h *ProductHandler) DeleteProduct(c *gin.Context) {
    id, err := strconv.ParseUint(c.Param("id"), 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid product ID"})
        return
    }

    err = h.productService.DeleteProduct(uint(id))
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": "Product not found"})
        return
    }

    c.JSON(http.StatusOK, gin.H{"message": "Product deleted successfully"})
}

// GetProductsByCategory godoc
// @Summary Get products by category
// @Description Get products by category ID with pagination (Admin only)
// @Tags Products
// @Produce json
// @Param category_id path int true "Category ID"
// @Param page query int false "Page number" default(1)
// @Param limit query int false "Items per page" default(10)
// @Success 200 {object} responses.ProductListResponse
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 403 {object} map[string]string
// @Router /admin/categories/{category_id}/products [get]
func (h *ProductHandler) GetProductsByCategory(c *gin.Context) {
    categoryID, err := strconv.ParseUint(c.Param("category_id"), 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid category ID"})
        return
    }

    page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
    limit, _ := strconv.Atoi(c.DefaultQuery("limit", "10"))

    products, err := h.productService.GetProductsByCategory(uint(categoryID), page, limit)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusOK, products)
}</code></pre>

                    <h3>🔗 Langkah 8: Update main.go</h3>
                    <p>Tambahkan routes untuk product di <code>main.go</code>:</p>

                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>
                      package main

import (
	"log"
	"tokogo/config"
	"tokogo/handlers"
	"tokogo/middlewares"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
	"github.com/joho/godotenv"
)

func main() {
	// Load environment variables
	if err := godotenv.Load(); err != nil {
		log.Println("No .env file found, using system environment variables")
	}

	// Initialize database
	config.InitDB()

	// Setup Gin router
	r := gin.Default()

	// CORS middleware
	r.Use(cors.New(cors.Config{
		AllowOrigins:     []string{"*"},
		AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowHeaders:     []string{"*"},
		ExposeHeaders:    []string{"Content-Length"},
		AllowCredentials: true,
	}))

	// Static file serving for uploaded images
	r.Static("/uploads", "./uploads")

	// Initialize handlers
	authHandler := handlers.NewAuthHandler()
	categoryHandler := handlers.NewCategoryHandler()
	productHandler := handlers.NewProductHandler()

	// Public routes (tidak perlu authentication)
	api := r.Group("/api/v1")
	{
		// Auth routes
		auth := api.Group("/auth")
		{
			auth.POST("/register", authHandler.Register)
			auth.POST("/login", authHandler.Login)
		}
	}

	// Protected routes (perlu authentication)
	protected := r.Group("/api/v1")
	protected.Use(middlewares.AuthMiddleware())
	{
		// Auth protected routes
		auth := protected.Group("/auth")
		{
			auth.POST("/logout", authHandler.Logout)
			auth.GET("/profile", authHandler.GetProfile)
		}

		// Admin routes (perlu admin role)
		admin := protected.Group("/admin")
		admin.Use(middlewares.AdminMiddleware())
		{
			admin.GET("/dashboard", func(c *gin.Context) {
				c.JSON(200, gin.H{
					"message": "Welcome to admin dashboard",
					"user_id": c.GetUint("user_id"),
				})
			})

			categories := admin.Group("/categories")
			{
				categories.POST("", categoryHandler.CreateCategory)
				categories.GET("", categoryHandler.GetAllCategories)
				categories.GET("/:id", categoryHandler.GetCategoryByID)
				categories.PUT("/:id", categoryHandler.UpdateCategory)
				categories.DELETE("/:id", categoryHandler.DeleteCategory)
			}

			products := admin.Group("/products")
			{
				products.POST("", productHandler.CreateProduct)
				products.GET("", productHandler.GetAllProducts)
				products.GET("/:id", productHandler.GetProductByID)
				products.PUT("/:id", productHandler.UpdateProduct)
				products.DELETE("/:id", productHandler.DeleteProduct)
				products.GET("/categories/:category_id", productHandler.GetProductsByCategory)
			}
		}
	}

	// Start server
	port := config.GetEnv("SERVER_PORT", "8080")
	log.Printf("Server starting on port %s", port)
	r.Run(":" + port)
}
</code></pre>

 <h3>📝 Langkah 9: Update Database Config untuk AutoMigrate</h3>
                    <p>Update file <code>config/database.go</code> untuk menambahkan Category model:</p>

                    <pre><code>package config

import (
    "fmt"
    "log"
    "os"
    "tokogo/models"

    "gorm.io/driver/mysql"
    "gorm.io/gorm"
)

var DB *gorm.DB

// InitDB menginisialisasi koneksi database
func InitDB() {
    var err error

    // Konfigurasi database dari environment variables
    dbHost := GetEnv("DB_HOST", "localhost")
    dbPort := GetEnv("DB_PORT", "3306")
    dbUser := GetEnv("DB_USER", "root")
    dbPassword := GetEnv("DB_PASSWORD", "")
    dbName := GetEnv("DB_NAME", "tokogo")

    // Buat DSN (Data Source Name)
    dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local",
        dbUser, dbPassword, dbHost, dbPort, dbName)

    // Koneksi ke database
    DB, err = gorm.Open(mysql.Open(dsn), &gorm.Config{})
    if err != nil {
        log.Fatal("Failed to connect to database:", err)
    }

    log.Println("Database connected successfully")

    // Auto migrate models
    err = DB.AutoMigrate(
        &models.User{},
        &models.Category{},
        &models.Product{},
    )
    if err != nil {
        log.Fatal("Failed to migrate database:", err)
    }

    log.Println("Database migrated successfully")
}
</code></pre>

                    <h4>Penjelasan Database Config Update:</h4>
                    <ul>
                        <li><strong>AutoMigrate:</strong> Menambahkan &models.Category{} ke AutoMigrate</li>
                        <li><strong>Table Creation:</strong> GORM akan membuat tabel categories otomatis</li>
                        <li><strong>Schema Sync:</strong> Database schema akan sync dengan model</li>
                    </ul>

                    <h3>🧪 Testing dengan Postman</h3>
                    <p>Sekarang kita akan test semua endpoint product dengan file upload. Pastikan Anda sudah login sebagai admin dan mendapatkan JWT token.</p>

                    <div style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 1rem; margin: 2rem 0;">
                        <strong>💡 Penting:</strong> Untuk testing file upload, gunakan form-data instead of JSON. Di Postman, pilih "form-data" tab dan tambahkan field "image" dengan tipe "File".
                    </div>

                    <div style="background: #e8f5e8; border-left: 4px solid #4CAF50; padding: 1rem; margin: 2rem 0;">
                        <strong>🎯 Panduan Praktik Bertahap:</strong> Jika Anda merasa overwhelmed dengan banyaknya endpoint, ikuti urutan testing ini untuk memudahkan pemahaman:
                        <ol style="margin: 0.5rem 0 0 1rem;">
                            <li><strong>Step 1:</strong> Test GET All Products (tanpa file upload) - untuk memahami response format</li>
                            <li><strong>Step 2:</strong> Test GET Product by ID - untuk melihat struktur data lengkap</li>
                            <li><strong>Step 3:</strong> Test CREATE Product dengan file upload - fokus pada file upload</li>
                            <li><strong>Step 4:</strong> Test UPDATE Product dengan file upload baru - untuk memahami update flow</li>
                            <li><strong>Step 5:</strong> Test DELETE Product - untuk melihat cleanup file</li>
                        </ol>
                        Dengan urutan ini, Anda akan memahami setiap aspek file upload secara bertahap!
                    </div>

                    <h4>1. Create Product dengan File Upload</h4>
                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>POST /admin/products
Headers:
Authorization: Bearer YOUR_JWT_TOKEN

Body (form-data):
name: Laptop Gaming ASUS
description: Laptop gaming dengan spesifikasi tinggi
purchase_price: 8000000
selling_price: 10000000
stock: 5
category_id: 1
image: [SELECT FILE - pilih file gambar]</code></pre>

                    <h4>2. Get All Products</h4>
                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>GET /admin/products?page=1&limit=10
Headers:
Authorization: Bearer YOUR_JWT_TOKEN</code></pre>

                    <h4>3. Get Product by ID</h4>
                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>GET /admin/products/1
Headers:
Authorization: Bearer YOUR_JWT_TOKEN</code></pre>

                    <h4>4. Update Product</h4>
                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>PUT /admin/products/1
Headers:
Authorization: Bearer YOUR_JWT_TOKEN
Content-Type: application/json

Body:
{
    "name": "Laptop Gaming ASUS ROG",
    "description": "Laptop gaming dengan spesifikasi tinggi dan RGB keyboard",
    "purchase_price": 8500000,
    "selling_price": 10500000,
    "stock": 3,
    "category_id": 1,
    "image_url": "https://example.com/laptop-rog.jpg"
}</code></pre>

                    <h4>5. Delete Product</h4>
                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>DELETE /admin/products/1
Headers:
Authorization: Bearer YOUR_JWT_TOKEN</code></pre>

                    <h4>6. Get Products by Category</h4>
                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>GET /admin/categories/1/products?page=1&limit=10
Headers:
Authorization: Bearer YOUR_JWT_TOKEN</code></pre>

                    <h3>✅ Checklist Implementasi</h3>
                    <p>Pastikan Anda telah menyelesaikan semua langkah berikut:</p>
                    <ul>
                        <li>✅ Membuat tabel products di database</li>
                        <li>✅ Membuat model Product di models/product.go</li>
                        <li>✅ Membuat request structs di requests/product_request.go</li>
                        <li>✅ Membuat response structs di responses/product_response.go</li>
                        <li>✅ Membuat repository di repositories/product_repository.go</li>
                        <li>✅ Membuat service di services/product_service.go</li>
                        <li>✅ Membuat handler di handlers/product_handler.go</li>
                        <li>✅ Menambahkan routes di main.go</li>
                        <li>✅ Test semua endpoint dengan Postman</li>
                    </ul>

                    <h3>🎯 Fitur yang Telah Diimplementasikan</h3>
                    <ul>
                        <li>✅ <strong>Create Product</strong> - Membuat produk baru dengan validasi</li>
                        <li>✅ <strong>Read Products</strong> - Melihat daftar produk dengan pagination</li>
                        <li>✅ <strong>Read Product by ID</strong> - Melihat detail produk berdasarkan ID</li>
                        <li>✅ <strong>Update Product</strong> - Mengupdate data produk</li>
                        <li>✅ <strong>Delete Product</strong> - Menghapus produk</li>
                        <li>✅ <strong>Get Products by Category</strong> - Melihat produk berdasarkan kategori</li>
                        <li>✅ <strong>Admin Role Protection</strong> - Semua endpoint hanya bisa diakses admin</li>
                        <li>✅ <strong>Input Validation</strong> - Validasi input menggunakan Gin binding</li>
                        <li>✅ <strong>Database Relations</strong> - Relasi dengan tabel categories</li>
                        <li>✅ <strong>Error Handling</strong> - Penanganan error yang baik</li>
                    </ul>

                    <div style="background: #d4edda; border: 1px solid #c3e6cb; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4 style="color: #155724; margin-bottom: 1rem;">🎉 Selamat! Modul CRUD Product Telah Selesai</h4>
                        <p style="color: #155724; margin-bottom: 0;">Anda telah berhasil mengimplementasikan sistem CRUD Product yang lengkap dengan role-based access control. Sistem ini siap untuk digunakan dalam aplikasi toko online Anda!</p>
                    </div>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>🎯 Preview Bab 12: Modul CRUD Customer - Role Admin</h4>
                        <p>Di bab selanjutnya, kita akan:</p>
                        <ul>
                            <li>Membuat sistem CRUD Customer untuk admin</li>
                            <li>Implementasi manajemen data pelanggan</li>
                            <li>Validasi dan keamanan data customer</li>
                            <li>Testing endpoint customer dengan Postman</li>
                        </ul>
                        <p style="color: #495057; margin-bottom: 0;">Dengan sistem CRUD Product yang lengkap, Anda siap untuk melanjutkan ke modul Customer Management!</p>
                    </div>

                    <h3>🎯 Pattern Consistency - Mengapa Penting?</h3>
                    <p>Dalam bab ini, kita telah mengimplementasikan pattern yang konsisten dengan modul Category. Ini adalah praktik yang sangat penting dalam pengembangan software. Berikut adalah keuntungan dari pattern yang konsisten:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #2c3e50; margin-bottom: 1rem;">🔍 Pattern yang Konsisten yang Telah Diimplementasikan</h4>
                        
                        <p><strong>1. Request Validation Pattern:</strong></p>
                        <ul>
                            <li>Menggunakan method <code>Validate()</code> dengan custom validation</li>
                            <li>Menggunakan <code>validate</code> tag instead of <code>binding</code> tag</li>
                            <li>Validasi custom untuk business rules (selling price > purchase price)</li>
                            <li>Konsisten dengan pattern category</li>
                        </ul>

                        <p><strong>2. Response Format Pattern:</strong></p>
                        <ul>
                            <li>Menggunakan <code>SuccessResponse</code> dan <code>ErrorResponse</code></li>
                            <li>Format tanggal menggunakan string "2006-01-02 15:04:05"</li>
                            <li>Error handling yang konsisten dan informatif</li>
                            <li>Response structure yang seragam</li>
                        </ul>

                        <p><strong>3. Constructor Pattern:</strong></p>
                        <ul>
                            <li>Semua service dan handler menggunakan constructor tanpa parameter</li>
                            <li>Dependency injection yang konsisten</li>
                            <li>Factory pattern yang seragam</li>
                        </ul>

                        <p><strong>4. Code Comments Pattern:</strong></p>
                        <ul>
                            <li>Komentar yang konsisten dan informatif</li>
                            <li>Documentation yang seragam</li>
                            <li>Penjelasan yang jelas untuk setiap method</li>
                        </ul>

                        <p style="color: #495057; margin-bottom: 0;"><strong>💡 Keuntungan:</strong> Pattern yang konsisten membuat codebase lebih maintainable, scalable, dan mudah dipahami oleh developer lain. Ini adalah best practice dalam pengembangan software yang professional.</p>
                    </div>

                    <h3>📁 File Upload di Go - Best Practices</h3>
                    <p>Dalam bab ini, kita telah mengimplementasikan file upload yang aman dan efisien. Berikut adalah best practices untuk file upload di Go:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #2c3e50; margin-bottom: 1rem;">🔍 Best Practices File Upload</h4>
                        
                        <p><strong>1. Validasi File Type:</strong></p>
                        <ul>
                            <li>Selalu validasi Content-Type header</li>
                            <li>Gunakan whitelist untuk tipe file yang diizinkan</li>
                            <li>Jangan percaya pada ekstensi file saja</li>
                        </ul>

                        <p><strong>2. Validasi File Size:</strong></p>
                        <ul>
                            <li>Set batas maksimal ukuran file</li>
                            <li>Validasi sebelum menyimpan ke disk</li>
                            <li>Berikan error message yang jelas</li>
                        </ul>

                        <p><strong>3. Generate Unique Filename:</strong></p>
                        <ul>
                            <li>Gunakan timestamp + random string</li>
                            <li>Hindari konflik nama file</li>
                            <li>Pertahankan ekstensi file asli</li>
                        </ul>

                        <p><strong>4. Error Handling:</strong></p>
                        <ul>
                            <li>Cleanup file jika database operation gagal</li>
                            <li>Handle error dengan graceful</li>
                            <li>Berikan feedback yang informatif</li>
                        </ul>

                        <p><strong>5. Security Considerations:</strong></p>
                        <ul>
                            <li>Jangan execute file yang diupload</li>
                            <li>Simpan file di luar web root jika mungkin</li>
                            <li>Gunakan static file serving yang aman</li>
                        </ul>

                        <p style="color: #495057; margin-bottom: 0;"><strong>💡 Keuntungan:</strong> Implementasi file upload yang aman dan efisien memastikan aplikasi dapat menangani upload file dengan baik tanpa mengorbankan keamanan dan performa.</p>
                    </div>

                    <h3>🎉 Selamat!</h3>
                    <p>Anda telah berhasil mengimplementasikan modul CRUD Product yang lengkap dengan pattern yang konsisten! Sistem manajemen produk sudah siap untuk digunakan dan hanya bisa diakses oleh admin. Fitur ini dapat diintegrasikan dengan modul Customer Management di bab selanjutnya.</p>

                    <div style="background: #f3e5f5; border-left: 4px solid #9C27B0; padding: 1rem; margin: 2rem 0;">
                        <strong>🌟 Tips untuk Pemahaman yang Lebih Baik:</strong> File upload adalah konsep yang cukup kompleks, jadi jangan khawatir jika tidak langsung paham semuanya! Coba praktikkan dengan urutan yang sudah disarankan di atas. Mulai dari yang sederhana (GET data), kemudian perlahan naik ke yang lebih kompleks (CREATE dengan file upload). Setiap kali Anda berhasil menjalankan satu endpoint, Anda akan semakin memahami cara kerja file upload secara keseluruhan. Ingat, belajar programming adalah proses bertahap - yang penting adalah konsistensi dan praktik!
                    </div>

                    <div style="text-align: center; margin: 3rem 0;">
                        <div style="background: #f8f9fa; border: 1px solid #dee2e6; color: #2c3e50; padding: 2rem; border-radius: 5px; display: inline-block;">
                            <h3 style="color: #2c3e50; margin-bottom: 1rem;">🎯 Siap untuk Modul Selanjutnya?</h3>
                            <p style="color: #495057; margin-bottom: 0;">Dengan sistem CRUD Product yang lengkap dan pattern yang konsisten, Anda siap untuk melanjutkan ke modul Customer Management!</p>
                        </div>
                    </div>
                `
            },
            {
                id: 'chapter12',
                title: 'Bab 12: Modul User Management - Role Admin',
                meta: 'Halaman 12 dari 50 • Dibaca 18 menit',
                content: `
                    <h2>👥 Bab 12: Modul User Management - Role Admin</h2>
                    <p>Selamat! Sekarang kita akan membuat modul User Management yang hanya bisa diakses oleh admin. Di bab ini, kita akan mengimplementasikan sistem manajemen user dengan role-based access control, termasuk fitur CRUD user, update role, dan manajemen status user.</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">🎯 Apa yang Akan Kita Buat di Bab Ini?</h3>
                        <p style="color: #495057; margin-bottom: 0;">Kita akan membuat sistem User Management yang lengkap dengan Create, Read, Update, Delete operations. Admin dapat mengelola semua user, mengubah role, dan mengatur status user. Semua endpoint hanya bisa diakses oleh admin.</p>
                    </div>

                    <h3>📋 Prasyarat</h3>
                    <p>Sebelum memulai, pastikan Anda sudah menyelesaikan:</p>
                    <ul>
                        <li>✅ Bab 6-8: Modul Authentication (Register, Login, Logout)</li>
                        <li>✅ Bab 9: Review Pembelajaran Authentication</li>
                        <li>✅ Bab 10: Modul CRUD Kategori - Role Admin</li>
                        <li>✅ Bab 11: Modul CRUD Product - Role Admin</li>
                        <li>✅ Middleware authentication sudah berfungsi</li>
                        <li>✅ AdminMiddleware sudah diimplementasikan</li>
                        <li>✅ Tabel users sudah ada di database</li>
                    </ul>

                    <h3>🏗️ Struktur File yang Akan Dibuat</h3>
                    <p>Kita akan membuat file-file berikut untuk modul User Management:</p>
                    <ul>
                        <li><code>requests/user_management_request.go</code> - Request structs untuk user management</li>
                        <li><code>responses/user_management_response.go</code> - Response structs untuk user management</li>
                        <li><code>repositories/user_management_repository.go</code> - Repository layer untuk user management</li>
                        <li><code>services/user_management_service.go</code> - Service layer untuk user management</li>
                        <li><code>handlers/user_management_handler.go</code> - Handler layer untuk user management</li>
                    </ul>

                    <h3>📝 1. Membuat Request Structs</h3>
                    <p>Pertama, kita buat file <code>requests/user_management_request.go</code>:</p>
                    
                    <pre><code>package requests

import (
    "errors"
    "strings"

    "github.com/go-playground/validator/v10"
)

// CreateUserRequest represents the request structure for creating user
type CreateUserRequest struct {
    Name     string \`json:"name" validate:"required,min=3,max=255"\`
    Email    string \`json:"email" validate:"required,email"\`
    Password string \`json:"password" validate:"required,min=6"\`
    Role     string \`json:"role" validate:"required,oneof=customer admin"\`
}

// UpdateUserRequest represents the request structure for updating user
type UpdateUserRequest struct {
    Name  string \`json:"name" validate:"omitempty,min=3,max=255"\`
    Email string \`json:"email" validate:"omitempty,email"\`
    Role  string \`json:"role" validate:"omitempty,oneof=customer admin"\`
}

// ChangePasswordRequest represents the request structure for changing password
type ChangePasswordRequest struct {
    CurrentPassword string \`json:"current_password" validate:"required"\`
    NewPassword     string \`json:"new_password" validate:"required,min=6"\`
}

// Validate validates the CreateUserRequest using the validator
func (r *CreateUserRequest) Validate() error {
    validate := validator.New()

    // Validasi struct fields
    if err := validate.Struct(r); err != nil {
        return err
    }

    // Validasi custom: nama tidak boleh kosong setelah trim
    if strings.TrimSpace(r.Name) == "" {
        return errors.New("name cannot be empty")
    }

    // Validasi custom: email tidak boleh kosong setelah trim
    if strings.TrimSpace(r.Email) == "" {
        return errors.New("email cannot be empty")
    }

    // Validasi custom: password tidak boleh kosong setelah trim
    if strings.TrimSpace(r.Password) == "" {
        return errors.New("password cannot be empty")
    }

    return nil
}

// Validate validates the UpdateUserRequest using the validator
func (r *UpdateUserRequest) Validate() error {
    validate := validator.New()

    // Validasi struct fields
    if err := validate.Struct(r); err != nil {
        return err
    }

    // Validasi custom: jika name diisi, tidak boleh kosong setelah trim
    if r.Name != "" && strings.TrimSpace(r.Name) == "" {
        return errors.New("name cannot be empty")
    }

    // Validasi custom: jika email diisi, tidak boleh kosong setelah trim
    if r.Email != "" && strings.TrimSpace(r.Email) == "" {
        return errors.New("email cannot be empty")
    }

    return nil
}

// Validate validates the ChangePasswordRequest using the validator
func (r *ChangePasswordRequest) Validate() error {
    validate := validator.New()

    // Validasi struct fields
    if err := validate.Struct(r); err != nil {
        return err
    }

    // Validasi custom: current password tidak boleh kosong setelah trim
    if strings.TrimSpace(r.CurrentPassword) == "" {
        return errors.New("current password cannot be empty")
    }

    // Validasi custom: new password tidak boleh kosong setelah trim
    if strings.TrimSpace(r.NewPassword) == "" {
        return errors.New("new password cannot be empty")
    }

    return nil
}</code></pre>

                    <h3>📤 2. Membuat Response Structs</h3>
                    <p>Buat file <code>responses/user_management_response.go</code>:</p>
                    
                    <pre><code>package responses

import "tokogo/models"

// UserManagementResponse struct untuk response user management
type UserManagementResponse struct {
    ID        uint   \`json:"id"\`
    Name      string \`json:"name"\`
    Email     string \`json:"email"\`
    Role      string \`json:"role"\`
    CreatedAt string \`json:"created_at"\`
    UpdatedAt string \`json:"updated_at"\`
}

// UserListResponse struct untuk response list users
type UserListResponse struct {
    Users []UserManagementResponse \`json:"users"\`
    Total int                      \`json:"total"\`
    Page  int                      \`json:"page"\`
    Limit int                      \`json:"limit"\`
}

// ConvertUserToManagementResponse mengkonversi model User ke UserManagementResponse
func ConvertUserToManagementResponse(user models.User) UserManagementResponse {
    return UserManagementResponse{
        ID:        user.ID,
        Name:      user.Name,
        Email:     user.Email,
        Role:      user.Role,
        CreatedAt: user.CreatedAt.Format("2006-01-02 15:04:05"),
        UpdatedAt: user.UpdatedAt.Format("2006-01-02 15:04:05"),
    }
}

// ConvertUsersToManagementResponse mengkonversi slice model User ke slice UserManagementResponse
func ConvertUsersToManagementResponse(users []models.User) []UserManagementResponse {
    var responses []UserManagementResponse
    for _, user := range users {
        responses = append(responses, ConvertUserToManagementResponse(user))
    }
    return responses
}</code></pre>

                    <h3>🗄️ 3. Membuat Repository Layer</h3>
                    <p>Buat file <code>repositories/user_management_repository.go</code>:</p>
                    
                    <pre><code>package repositories

import (
    "errors"
    "tokogo/config"
    "tokogo/models"

    "gorm.io/gorm"
)

type UserManagementRepository struct {
    db *gorm.DB
}

// NewUserManagementRepository membuat instance baru UserManagementRepository
func NewUserManagementRepository() *UserManagementRepository {
    return &UserManagementRepository{
        db: config.GetDB(),
    }
}

// CreateUser membuat user baru
func (r *UserManagementRepository) CreateUser(user *models.User) error {
    return r.db.Create(user).Error
}

// GetUserByID mengambil user berdasarkan ID
func (r *UserManagementRepository) GetUserByID(id uint) (*models.User, error) {
    var user models.User
    err := r.db.First(&user, id).Error
    if err != nil {
        return nil, err
    }
    return &user, nil
}

// GetUserByEmail mengambil user berdasarkan email
func (r *UserManagementRepository) GetUserByEmail(email string) (*models.User, error) {
    var user models.User
    err := r.db.Where("email = ?", email).First(&user).Error
    if err != nil {
        return nil, err
    }
    return &user, nil
}

// GetAllUsers mengambil semua users dengan pagination
func (r *UserManagementRepository) GetAllUsers(page, limit int) ([]models.User, int64, error) {
    var users []models.User
    var total int64

    // Hitung total
    if err := r.db.Model(&models.User{}).Count(&total).Error; err != nil {
        return nil, 0, err
    }

    // Ambil data dengan pagination
    offset := (page - 1) * limit
    err := r.db.Offset(offset).Limit(limit).Find(&users).Error
    if err != nil {
        return nil, 0, err
    }

    return users, total, nil
}

// UpdateUser mengupdate user
func (r *UserManagementRepository) UpdateUser(user *models.User) error {
    return r.db.Save(user).Error
}

// DeleteUser menghapus user (soft delete)
func (r *UserManagementRepository) DeleteUser(id uint) error {
    return r.db.Delete(&models.User{}, id).Error
}

// UpdateUserRole mengupdate role user
func (r *UserManagementRepository) UpdateUserRole(id uint, role string) error {
    return r.db.Model(&models.User{}).Where("id = ?", id).Update("role", role).Error
}

// GetUsersByRole mengambil users berdasarkan role
func (r *UserManagementRepository) GetUsersByRole(role string, page, limit int) ([]models.User, int64, error) {
    var users []models.User
    var total int64

    // Hitung total
    if err := r.db.Model(&models.User{}).Where("role = ?", role).Count(&total).Error; err != nil {
        return nil, 0, err
    }

    // Ambil data dengan pagination
    offset := (page - 1) * limit
    err := r.db.Where("role = ?", role).Offset(offset).Limit(limit).Find(&users).Error
    if err != nil {
        return nil, 0, err
    }

    return users, total, nil
}</code></pre>

                    <h3>⚙️ 4. Membuat Service Layer</h3>
                    <p>Buat file <code>services/user_management_service.go</code>:</p>
                    
                    <pre><code>package services

import (
    "errors"
    "tokogo/models"
    "tokogo/repositories"
    "tokogo/requests"
    "tokogo/responses"

    "golang.org/x/crypto/bcrypt"
)

type UserManagementService struct {
    userRepo *repositories.UserManagementRepository
}

// NewUserManagementService membuat instance baru UserManagementService
func NewUserManagementService() *UserManagementService {
    return &UserManagementService{
        userRepo: repositories.NewUserManagementRepository(),
    }
}

// CreateUser membuat user baru
func (s *UserManagementService) CreateUser(req requests.CreateUserRequest) (*responses.UserManagementResponse, error) {
    // Cek apakah email sudah terdaftar
    existingUser, _ := s.userRepo.GetUserByEmail(req.Email)
    if existingUser != nil {
        return nil, errors.New("email already registered")
    }

    // Hash password
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
    if err != nil {
        return nil, errors.New("failed to hash password")
    }

    // Buat user baru
    user := &models.User{
        Name:     req.Name,
        Email:    req.Email,
        Password: string(hashedPassword),
        Role:     req.Role,
    }

    // Simpan ke database
    if err := s.userRepo.CreateUser(user); err != nil {
        return nil, errors.New("failed to create user")
    }

    // Return response
    response := responses.ConvertUserToManagementResponse(*user)
    return &response, nil
}

// GetUserByID mengambil user berdasarkan ID
func (s *UserManagementService) GetUserByID(id uint) (*responses.UserManagementResponse, error) {
    user, err := s.userRepo.GetUserByID(id)
    if err != nil {
        return nil, errors.New("user not found")
    }

    response := responses.ConvertUserToManagementResponse(*user)
    return &response, nil
}

// GetAllUsers mengambil semua users dengan pagination
func (s *UserManagementService) GetAllUsers(page, limit int) (*responses.UserListResponse, error) {
    if page < 1 {
        page = 1
    }
    if limit < 1 || limit > 100 {
        limit = 10
    }

    users, total, err := s.userRepo.GetAllUsers(page, limit)
    if err != nil {
        return nil, errors.New("failed to get users")
    }

    return &responses.UserListResponse{
        Users: responses.ConvertUsersToManagementResponse(users),
        Total: int(total),
        Page:  page,
        Limit: limit,
    }, nil
}

// UpdateUser mengupdate user
func (s *UserManagementService) UpdateUser(id uint, req requests.UpdateUserRequest) (*responses.UserManagementResponse, error) {
    // Ambil user yang akan diupdate
    user, err := s.userRepo.GetUserByID(id)
    if err != nil {
        return nil, errors.New("user not found")
    }

    // Update field yang ada
    if req.Name != "" {
        user.Name = req.Name
    }
    if req.Email != "" {
        // Cek apakah email sudah digunakan user lain
        existingUser, _ := s.userRepo.GetUserByEmail(req.Email)
        if existingUser != nil && existingUser.ID != id {
            return nil, errors.New("email already used by another user")
        }
        user.Email = req.Email
    }
    if req.Role != "" {
        user.Role = req.Role
    }

    // Simpan perubahan
    if err := s.userRepo.UpdateUser(user); err != nil {
        return nil, errors.New("failed to update user")
    }

    // Return response
    response := responses.ConvertUserToManagementResponse(*user)
    return &response, nil
}

// DeleteUser menghapus user
func (s *UserManagementService) DeleteUser(id uint) error {
    // Cek apakah user ada
    _, err := s.userRepo.GetUserByID(id)
    if err != nil {
        return errors.New("user not found")
    }

    // Hapus user
    if err := s.userRepo.DeleteUser(id); err != nil {
        return errors.New("failed to delete user")
    }

    return nil
}

// UpdateUserRole mengupdate role user
func (s *UserManagementService) UpdateUserRole(id uint, role string) (*responses.UserManagementResponse, error) {
    // Cek apakah user ada
    user, err := s.userRepo.GetUserByID(id)
    if err != nil {
        return nil, errors.New("user not found")
    }

    // Update role
    if err := s.userRepo.UpdateUserRole(id, role); err != nil {
        return nil, errors.New("failed to update user role")
    }

    // Ambil user yang sudah diupdate
    updatedUser, err := s.userRepo.GetUserByID(id)
    if err != nil {
        return nil, errors.New("failed to get updated user")
    }

    // Return response
    response := responses.ConvertUserToManagementResponse(*updatedUser)
    return &response, nil
}

// GetUsersByRole mengambil users berdasarkan role
func (s *UserManagementService) GetUsersByRole(role string, page, limit int) (*responses.UserListResponse, error) {
    if page < 1 {
        page = 1
    }
    if limit < 1 || limit > 100 {
        limit = 10
    }

    if role != "customer" && role != "admin" {
        return nil, errors.New("invalid role")
    }

    users, total, err := s.userRepo.GetUsersByRole(role, page, limit)
    if err != nil {
        return nil, errors.New("failed to get users by role")
    }

    return &responses.UserListResponse{
        Users: responses.ConvertUsersToManagementResponse(users),
        Total: int(total),
        Page:  page,
        Limit: limit,
    }, nil
}</code></pre>

                    <h3>🎮 5. Membuat Handler Layer</h3>
                    <p>Buat file <code>handlers/user_management_handler.go</code>:</p>
                    
                    <pre><code>package handlers

import (
    "net/http"
    "strconv"
    "tokogo/requests"
    "tokogo/responses"
    "tokogo/services"

    "github.com/gin-gonic/gin"
)

type UserManagementHandler struct {
    userService *services.UserManagementService
}

// NewUserManagementHandler membuat instance baru UserManagementHandler
func NewUserManagementHandler() *UserManagementHandler {
    return &UserManagementHandler{
        userService: services.NewUserManagementService(),
    }
}

// CreateUser handler untuk membuat user baru
func (h *UserManagementHandler) CreateUser(c *gin.Context) {
    var req requests.CreateUserRequest

    // Bind dan validasi request
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Validasi menggunakan method Validate()
    if err := req.Validate(); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Panggil service untuk create user
    userResponse, err := h.userService.CreateUser(req)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "create_user_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusCreated, responses.SuccessResponse{
        Message: "User created successfully",
        Data:    userResponse,
    })
}

// GetUserByID handler untuk mengambil user berdasarkan ID
func (h *UserManagementHandler) GetUserByID(c *gin.Context) {
    // Ambil ID dari parameter
    idStr := c.Param("id")
    id, err := strconv.ParseUint(idStr, 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "invalid_id",
            Message: "Invalid user ID",
        })
        return
    }

    // Panggil service untuk get user
    userResponse, err := h.userService.GetUserByID(uint(id))
    if err != nil {
        c.JSON(http.StatusNotFound, responses.ErrorResponse{
            Error:   "user_not_found",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "User retrieved successfully",
        Data:    userResponse,
    })
}

// GetAllUsers handler untuk mengambil semua users
func (h *UserManagementHandler) GetAllUsers(c *gin.Context) {
    // Ambil parameter pagination
    pageStr := c.DefaultQuery("page", "1")
    limitStr := c.DefaultQuery("limit", "10")

    page, err := strconv.Atoi(pageStr)
    if err != nil {
        page = 1
    }

    limit, err := strconv.Atoi(limitStr)
    if err != nil {
        limit = 10
    }

    // Panggil service untuk get all users
    usersResponse, err := h.userService.GetAllUsers(page, limit)
    if err != nil {
        c.JSON(http.StatusInternalServerError, responses.ErrorResponse{
            Error:   "get_users_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Users retrieved successfully",
        Data:    usersResponse,
    })
}

// UpdateUser handler untuk mengupdate user
func (h *UserManagementHandler) UpdateUser(c *gin.Context) {
    // Ambil ID dari parameter
    idStr := c.Param("id")
    id, err := strconv.ParseUint(idStr, 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "invalid_id",
            Message: "Invalid user ID",
        })
        return
    }

    var req requests.UpdateUserRequest

    // Bind dan validasi request
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Validasi menggunakan method Validate()
    if err := req.Validate(); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Panggil service untuk update user
    userResponse, err := h.userService.UpdateUser(uint(id), req)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "update_user_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "User updated successfully",
        Data:    userResponse,
    })
}

// DeleteUser handler untuk menghapus user
func (h *UserManagementHandler) DeleteUser(c *gin.Context) {
    // Ambil ID dari parameter
    idStr := c.Param("id")
    id, err := strconv.ParseUint(idStr, 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "invalid_id",
            Message: "Invalid user ID",
        })
        return
    }

    // Panggil service untuk delete user
    err = h.userService.DeleteUser(uint(id))
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "delete_user_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "User deleted successfully",
        Data:    nil,
    })
}

// UpdateUserRole handler untuk mengupdate role user
func (h *UserManagementHandler) UpdateUserRole(c *gin.Context) {
    // Ambil ID dari parameter
    idStr := c.Param("id")
    id, err := strconv.ParseUint(idStr, 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "invalid_id",
            Message: "Invalid user ID",
        })
        return
    }

    var req struct {
        Role string \`json:"role" binding:"required,oneof=customer admin"\`
    }

    // Bind dan validasi request
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Panggil service untuk update user role
    userResponse, err := h.userService.UpdateUserRole(uint(id), req.Role)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "update_user_role_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "User role updated successfully",
        Data:    userResponse,
    })
}

// GetUsersByRole handler untuk mengambil users berdasarkan role
func (h *UserManagementHandler) GetUsersByRole(c *gin.Context) {
    // Ambil role dari parameter
    role := c.Param("role")
    if role != "customer" && role != "admin" {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "invalid_role",
            Message: "Role must be either customer or admin",
        })
        return
    }

    // Ambil parameter pagination
    pageStr := c.DefaultQuery("page", "1")
    limitStr := c.DefaultQuery("limit", "10")

    page, err := strconv.Atoi(pageStr)
    if err != nil {
        page = 1
    }

    limit, err := strconv.Atoi(limitStr)
    if err != nil {
        limit = 10
    }

    // Panggil service untuk get users by role
    usersResponse, err := h.userService.GetUsersByRole(role, page, limit)
    if err != nil {
        c.JSON(http.StatusInternalServerError, responses.ErrorResponse{
            Error:   "get_users_by_role_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Users retrieved successfully",
        Data:    usersResponse,
    })
}</code></pre>

                    <h3>🛣️ 6. Menambahkan Routes di main.go</h3>
                    <p>Tambahkan routes untuk user management di <code>main.go</code>:</p>
                    
                    <pre><code>package main

import (
	"log"
	"tokogo/config"
	"tokogo/handlers"
	"tokogo/middlewares"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
	"github.com/joho/godotenv"
)

func main() {
	// Load environment variables
	if err := godotenv.Load(); err != nil {
		log.Println("No .env file found, using system environment variables")
	}

	// Initialize database
	config.InitDB()

	// Setup Gin router
	r := gin.Default()

	// CORS middleware
	r.Use(cors.New(cors.Config{
		AllowOrigins:     []string{"*"},
		AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowHeaders:     []string{"*"},
		ExposeHeaders:    []string{"Content-Length"},
		AllowCredentials: true,
	}))

	// Static file serving for uploaded images
	r.Static("/uploads", "./uploads")

	// Initialize handlers
	authHandler := handlers.NewAuthHandler()
	categoryHandler := handlers.NewCategoryHandler()
	productHandler := handlers.NewProductHandler()
	userManagementHandler := handlers.NewUserManagementHandler()

	// Public routes (tidak perlu authentication)
	api := r.Group("/api/v1")
	{
		// Auth routes
		auth := api.Group("/auth")
		{
			auth.POST("/register", authHandler.Register)
			auth.POST("/login", authHandler.Login)
		}
	}

	// Protected routes (perlu authentication)
	protected := r.Group("/api/v1")
	protected.Use(middlewares.AuthMiddleware())
	{
		// Auth protected routes
		auth := protected.Group("/auth")
		{
			auth.POST("/logout", authHandler.Logout)
			auth.GET("/profile", authHandler.GetProfile)
		}

		// Admin routes (perlu admin role)
		admin := protected.Group("/admin")
		admin.Use(middlewares.AdminMiddleware())
		{
			admin.GET("/dashboard", func(c *gin.Context) {
				c.JSON(200, gin.H{
					"message": "Welcome to admin dashboard",
					"user_id": c.GetUint("user_id"),
				})
			})

			categories := admin.Group("/categories")
			{
				categories.POST("", categoryHandler.CreateCategory)
				categories.GET("", categoryHandler.GetAllCategories)
				categories.GET("/:id", categoryHandler.GetCategoryByID)
				categories.PUT("/:id", categoryHandler.UpdateCategory)
				categories.DELETE("/:id", categoryHandler.DeleteCategory)
			}

			products := admin.Group("/products")
			{
				products.POST("", productHandler.CreateProduct)
				products.GET("", productHandler.GetAllProducts)
				products.GET("/:id", productHandler.GetProductByID)
				products.PUT("/:id", productHandler.UpdateProduct)
				products.DELETE("/:id", productHandler.DeleteProduct)
				products.GET("/categories/:category_id", productHandler.GetProductsByCategory)
			}

			userManagement := admin.Group("/user-management")
			{
				userManagement.POST("", userManagementHandler.CreateUser)
				userManagement.GET("", userManagementHandler.GetAllUsers)
				userManagement.GET("/:id", userManagementHandler.GetUserByID)
				userManagement.PUT("/:id", userManagementHandler.UpdateUser)
				userManagement.DELETE("/:id", userManagementHandler.DeleteUser)
			}
		}
	}

	// Start server
	port := config.GetEnv("SERVER_PORT", "8080")
	log.Printf("Server starting on port %s", port)
	r.Run(":" + port)
}
</code></pre>

                    <h3>🧪 7. Testing dengan Postman</h3>
                    <p>Sekarang kita akan test semua endpoint user management menggunakan Postman:</p>

                    <h4>📋 Endpoint yang Tersedia:</h4>
                    <ul>
                        <li><strong>POST</strong> <code>/admin/users</code> - Create user baru</li>
                        <li><strong>GET</strong> <code>/admin/users</code> - Get semua users (dengan pagination)</li>
                        <li><strong>GET</strong> <code>/admin/users/:id</code> - Get user berdasarkan ID</li>
                        <li><strong>PUT</strong> <code>/admin/users/:id</code> - Update user</li>
                        <li><strong>DELETE</strong> <code>/admin/users/:id</code> - Delete user</li>
                        <li><strong>PUT</strong> <code>/admin/users/:id/role</code> - Update role user</li>
                        <li><strong>GET</strong> <code>/admin/users/role/:role</code> - Get users berdasarkan role</li>
                    </ul>

                    <h4>🔐 Headers yang Diperlukan:</h4>
                    <p>Semua endpoint memerlukan header:</p>
                    <ul>
                        <li><code>Authorization: Bearer YOUR_JWT_TOKEN</code></li>
                        <li><code>Content-Type: application/json</code></li>
                    </ul>

                    <h4>📝 Contoh Request Body:</h4>
                    
                    <h5>Create User:</h5>
                    <pre><code>{
    "name": "John Doe",
    "email": "john@example.com",
    "password": "password123",
    "role": "customer"
}</code></pre>

                    <h5>Update User:</h5>
                    <pre><code>{
    "name": "John Updated",
    "email": "john.updated@example.com",
    "role": "admin"
}</code></pre>

                    <h5>Update User Role:</h5>
                    <pre><code>{
    "role": "admin"
}</code></pre>

                    <h4>📊 Contoh Response:</h4>
                    
                    <h5>Success Response:</h5>
                    <pre><code>{
    "message": "User created successfully",
    "data": {
        "id": 1,
        "name": "John Doe",
        "email": "john@example.com",
        "role": "customer",
        "created_at": "2024-01-01 10:00:00",
        "updated_at": "2024-01-01 10:00:00"
    }
}</code></pre>

                    <h5>List Users Response:</h5>
                    <pre><code>{
    "message": "Users retrieved successfully",
    "data": {
        "users": [
            {
                "id": 1,
                "name": "John Doe",
                "email": "john@example.com",
                "role": "customer",
                "created_at": "2024-01-01 10:00:00",
                "updated_at": "2024-01-01 10:00:00"
            }
        ],
        "total": 1,
        "page": 1,
        "limit": 10
    }
}</code></pre>

                    <h3>🎯 Fitur-fitur User Management:</h3>
                    <ul>
                        <li>✅ <strong>Create User</strong> - Admin dapat membuat user baru dengan role customer atau admin</li>
                        <li>✅ <strong>Read Users</strong> - Admin dapat melihat semua users dengan pagination</li>
                        <li>✅ <strong>Update User</strong> - Admin dapat mengupdate informasi user (name, email, role)</li>
                        <li>✅ <strong>Delete User</strong> - Admin dapat menghapus user (soft delete)</li>
                        <li>✅ <strong>Role Management</strong> - Admin dapat mengubah role user (customer ↔ admin)</li>
                        <li>✅ <strong>Filter by Role</strong> - Admin dapat melihat users berdasarkan role</li>
                        <li>✅ <strong>Pagination</strong> - Semua list endpoint mendukung pagination</li>
                        <li>✅ <strong>Validation</strong> - Semua input divalidasi dengan baik</li>
                        <li>✅ <strong>Error Handling</strong> - Error handling yang komprehensif</li>
                    </ul>

                    <h3>🔒 Security Features:</h3>
                    <ul>
                        <li>✅ <strong>Admin Only Access</strong> - Semua endpoint hanya bisa diakses admin</li>
                        <li>✅ <strong>JWT Authentication</strong> - Memerlukan token yang valid</li>
                        <li>✅ <strong>Password Hashing</strong> - Password di-hash menggunakan bcrypt</li>
                        <li>✅ <strong>Email Uniqueness</strong> - Email harus unik di sistem</li>
                        <li>✅ <strong>Input Validation</strong> - Semua input divalidasi</li>
                    </ul>

                    <div style="background: #d4edda; border: 1px solid #c3e6cb; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #155724; margin-bottom: 1rem;">🎉 Selamat! Modul User Management Selesai!</h3>
                        <p style="color: #155724; margin-bottom: 0;">Dengan sistem User Management yang lengkap dan pattern yang konsisten, Anda siap untuk melanjutkan ke modul berikutnya!</p>
                    </div>
                `
            },
            {
                id: 'chapter13',
                title: 'Bab 13: Modul Transaction Management - Role Admin',
                meta: 'Halaman 13 dari 50 • Dibaca 20 menit',
                content: `
                    <h2>💳 Bab 13: Modul Transaction Management - Role Admin</h2>
                    <p>Selamat! Sekarang kita akan membuat modul Transaction Management yang hanya bisa diakses oleh admin. Di bab ini, kita akan mengimplementasikan sistem manajemen transaksi dengan fitur melihat daftar transaksi, detail transaksi, dan mengelola status transaksi.</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">🎯 Apa yang Akan Kita Buat di Bab Ini?</h3>
                        <p style="color: #495057; margin-bottom: 0;">Kita akan membuat sistem Transaction Management yang lengkap dengan fitur melihat daftar transaksi, detail transaksi, dan mengelola status transaksi. Admin dapat melihat semua transaksi, detail produk dalam transaksi, dan mengupdate status transaksi. Semua endpoint hanya bisa diakses oleh admin.</p>
                    </div>

                    <h3>📋 Prasyarat</h3>
                    <p>Sebelum memulai, pastikan Anda sudah menyelesaikan:</p>
                    <ul>
                        <li>✅ Bab 6-8: Modul Authentication (Register, Login, Logout)</li>
                        <li>✅ Bab 9: Review Pembelajaran Authentication</li>
                        <li>✅ Bab 10: Modul CRUD Kategori - Role Admin</li>
                        <li>✅ Bab 11: Modul CRUD Product - Role Admin</li>
                        <li>✅ Bab 12: Modul User Management - Role Admin</li>
                        <li>✅ Middleware authentication sudah berfungsi</li>
                        <li>✅ AdminMiddleware sudah diimplementasikan</li>
                        <li>✅ Tabel users, products, dan categories sudah ada di database</li>
                    </ul>

                    <h3>🗄️ Database Schema</h3>
                    <p>Sebelum memulai, kita perlu membuat tabel untuk transaksi. Berikut adalah schema database yang akan kita gunakan:</p>

                    <h4>📊 Tabel Transactions</h4>
                    <pre><code>CREATE TABLE transactions (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    status ENUM('pending', 'paid', 'failed', 'expired') NOT NULL DEFAULT 'pending',
    total_amount DECIMAL(15,2) NOT NULL,
    payment_url VARCHAR(500),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);</code></pre>

                    <h4>📊 Tabel TransactionDetails</h4>
                    <pre><code>CREATE TABLE transaction_details (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    transaction_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,
    quantity INT NOT NULL,
    price DECIMAL(15,2) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (transaction_id) REFERENCES transactions(id) ON DELETE CASCADE,
    FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE
);</code></pre>

                    <h3>🏗️ Struktur File yang Akan Dibuat</h3>
                    <p>Kita akan membuat file-file berikut untuk modul Transaction Management:</p>
                    <ul>
                        <li><code>models/transaction.go</code> - Model Transaction dan TransactionDetail</li>
                        <li><code>requests/transaction_request.go</code> - Request structs untuk transaction management</li>
                        <li><code>responses/transaction_response.go</code> - Response structs untuk transaction management</li>
                        <li><code>repositories/transaction_repository.go</code> - Repository layer untuk transaction management</li>
                        <li><code>services/transaction_service.go</code> - Service layer untuk transaction management</li>
                        <li><code>handlers/transaction_handler.go</code> - Handler layer untuk transaction management</li>
                    </ul>

                    <h3>📝 1. Membuat Model Transaction</h3>
                    <p>Pertama, kita buat model Transaction di file <code>models/transaction.go</code>:</p>
                    
                    <pre><code>package models

import "time"

// Transaction represents the transaction model
type Transaction struct {
    ID                uint                  \`json:"id" gorm:"primaryKey"\`
    UserID            uint                  \`json:"user_id" gorm:"not null"\`
    User              User                  \`json:"user" gorm:"foreignKey:UserID"\`
    Status            string                \`json:"status" gorm:"type:enum('pending','paid','failed','expired');default:'pending'"\`
    TotalAmount       float64               \`json:"total_amount" gorm:"type:decimal(15,2);not null"\`
    PaymentURL        string                \`json:"payment_url" gorm:"type:varchar(500)"\`
    TransactionDetails []TransactionDetail  \`json:"transaction_details" gorm:"foreignKey:TransactionID"\`
    CreatedAt         time.Time             \`json:"created_at"\`
    UpdatedAt         time.Time             \`json:"updated_at"\`
}

// TransactionDetail represents the transaction detail model
type TransactionDetail struct {
    ID            uint      \`json:"id" gorm:"primaryKey"\`
    TransactionID uint      \`json:"transaction_id" gorm:"not null"\`
    Transaction   Transaction \`json:"transaction" gorm:"foreignKey:TransactionID"\`
    ProductID     uint      \`json:"product_id" gorm:"not null"\`
    Product       Product   \`json:"product" gorm:"foreignKey:ProductID"\`
    Quantity      int       \`json:"quantity" gorm:"not null"\`
    Price         float64   \`json:"price" gorm:"type:decimal(15,2);not null"\`
    CreatedAt     time.Time \`json:"created_at"\`
    UpdatedAt     time.Time \`json:"updated_at"\`
}

// TableName returns the table name for Transaction
func (Transaction) TableName() string {
    return "transactions"
}

// TableName returns the table name for TransactionDetail
func (TransactionDetail) TableName() string {
    return "transaction_details"
}</code></pre>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; border-radius: 5px; margin: 1.5rem 0;">
                        <h4 style="color: #2c3e50; margin-bottom: 1rem;">💡 Penjelasan Model Transaction</h4>
                        <ul>
                            <li><strong>Transaction Model:</strong> Menyimpan informasi transaksi utama</li>
                            <li><strong>User Relationship:</strong> Relasi dengan User melalui UserID</li>
                            <li><strong>Status Enum:</strong> Status transaksi dengan nilai yang terbatas</li>
                            <li><strong>TotalAmount:</strong> Total harga transaksi dengan presisi decimal</li>
                            <li><strong>PaymentURL:</strong> URL untuk pembayaran (opsional)</li>
                            <li><strong>TransactionDetails:</strong> Relasi one-to-many dengan detail transaksi</li>
                        </ul>
                        <ul>
                            <li><strong>TransactionDetail Model:</strong> Menyimpan detail produk dalam transaksi</li>
                            <li><strong>Product Relationship:</strong> Relasi dengan Product melalui ProductID</li>
                            <li><strong>Quantity:</strong> Jumlah produk yang dibeli</li>
                            <li><strong>Price:</strong> Harga per unit saat transaksi</li>
                            <li><strong>TableName Methods:</strong> Menentukan nama tabel secara eksplisit</li>
                        </ul>
                        <p style="color: #495057; margin-bottom: 0;"><strong>💡 Keuntungan:</strong> Model ini mendefinisikan struktur data yang konsisten dengan database dan menyediakan relasi yang jelas dengan User dan Product.</p>
                    </div>

                    <h3>📝 2. Membuat Request Structs</h3>
                    <p>Buat file <code>requests/transaction_request.go</code>:</p>
                    
                    <pre><code>package requests

import (
    "errors"
    "strings"

    "github.com/go-playground/validator/v10"
)

// UpdateTransactionStatusRequest represents the request structure for updating transaction status
type UpdateTransactionStatusRequest struct {
    Status string \`json:"status" validate:"required,oneof=pending paid failed expired"\`
}

// GetTransactionsRequest represents the request structure for getting transactions with filters
type GetTransactionsRequest struct {
    Status string \`json:"status" validate:"omitempty,oneof=pending paid failed expired"\`
    Page   int    \`json:"page" validate:"omitempty,min=1"\`
    Limit  int    \`json:"limit" validate:"omitempty,min=1,max=100"\`
}

// Validate validates the UpdateTransactionStatusRequest using the validator
func (r *UpdateTransactionStatusRequest) Validate() error {
    validate := validator.New()

    // Validasi struct fields
    if err := validate.Struct(r); err != nil {
        return err
    }

    // Validasi custom: status tidak boleh kosong setelah trim
    if strings.TrimSpace(r.Status) == "" {
        return errors.New("status cannot be empty")
    }

    return nil
}

// Validate validates the GetTransactionsRequest using the validator
func (r *GetTransactionsRequest) Validate() error {
    validate := validator.New()

    // Validasi struct fields
    if err := validate.Struct(r); err != nil {
        return err
    }

    // Set default values
    if r.Page <= 0 {
        r.Page = 1
    }
    if r.Limit <= 0 {
        r.Limit = 10
    }

    return nil
}</code></pre>

                    <h3>📤 3. Membuat Response Structs</h3>
                    <p>Buat file <code>responses/transaction_response.go</code>:</p>
                    
                    <pre><code>package responses

import "time"

// TransactionResponse represents the response structure for transaction
type TransactionResponse struct {
    ID          int64                     \`json:"id"\`
    UserID      int64                     \`json:"user_id"\`
    UserName    string                    \`json:"user_name"\`
    UserEmail   string                    \`json:"user_email"\`
    Status      string                    \`json:"status"\`
    TotalAmount float64                   \`json:"total_amount"\`
    PaymentURL  string                    \`json:"payment_url,omitempty"\`
    CreatedAt   time.Time                 \`json:"created_at"\`
    UpdatedAt   time.Time                 \`json:"updated_at"\`
    Details     []TransactionDetailResponse \`json:"details,omitempty"\`
}

// TransactionDetailResponse represents the response structure for transaction detail
type TransactionDetailResponse struct {
    ID            int64   \`json:"id"\`
    TransactionID int64   \`json:"transaction_id"\`
    ProductID     int64   \`json:"product_id"\`
    ProductName   string  \`json:"product_name"\`
    ProductImage  string  \`json:"product_image,omitempty"\`
    Quantity      int     \`json:"quantity"\`
    Price         float64 \`json:"price"\`
    Subtotal      float64 \`json:"subtotal"\`
}

// TransactionListResponse represents the response structure for transaction list
type TransactionListResponse struct {
    Transactions []TransactionResponse \`json:"transactions"\`
    Total        int64                 \`json:"total"\`
    Page         int                   \`json:"page"\`
    Limit        int                   \`json:"limit"\`
    TotalPages   int                   \`json:"total_pages"\`
}

// TransactionStatusResponse represents the response structure for transaction status update
type TransactionStatusResponse struct {
    Message string              \`json:"message"\`
    Data    TransactionResponse \`json:"data"\`
}</code></pre>

                    <h3>🗄️ 4. Membuat Repository Layer</h3>
                    <p>Buat file <code>repositories/transaction_repository.go</code>:</p>
                    
                    <pre><code>package repositories

import (
    "tokogo/config"
    "tokogo/models"

    "gorm.io/gorm"
)

type TransactionRepository struct {
    db *gorm.DB
}

// NewTransactionRepository membuat instance baru TransactionRepository
func NewTransactionRepository() *TransactionRepository {
    return &TransactionRepository{
        db: config.GetDB(),
    }
}

// GetAllTransactions mengambil semua transaksi dengan pagination dan filter
func (r *TransactionRepository) GetAllTransactions(page, limit int, status string) ([]models.Transaction, int64, error) {
    var transactions []models.Transaction
    var total int64

    // Build query dengan GORM
    query := r.db.Preload("User").Model(&models.Transaction{})
    
    // Apply filter status jika ada
    if status != "" {
        query = query.Where("status = ?", status)
    }

    // Count total records
    if err := query.Count(&total).Error; err != nil {
        return nil, 0, err
    }

    // Apply pagination dan ambil data
    offset := (page - 1) * limit
    if err := query.Offset(offset).Limit(limit).Order("created_at DESC").Find(&transactions).Error; err != nil {
        return nil, 0, err
    }

    return transactions, total, nil
}

// GetTransactionByID mengambil transaksi berdasarkan ID dengan detail
func (r *TransactionRepository) GetTransactionByID(id uint) (*models.Transaction, error) {
    var transaction models.Transaction

    // Get transaction dengan preload User dan TransactionDetails
    err := r.db.Preload("User").Preload("TransactionDetails.Product").First(&transaction, id).Error
    if err != nil {
        return nil, err
    }

    return &transaction, nil
}

// UpdateTransactionStatus mengupdate status transaksi
func (r *TransactionRepository) UpdateTransactionStatus(id uint, status string) error {
    err := r.db.Model(&models.Transaction{}).Where("id = ?", id).Update("status", status).Error
    if err != nil {
        return err
    }
    return nil
}

</code></pre>

                    <h3>⚙️ 5. Membuat Service Layer</h3>
                    <p>Buat file <code>services/transaction_service.go</code>:</p>
                    
                    <pre><code>package services

import (
    "tokogo/repositories"
    "tokogo/requests"
    "tokogo/responses"
)

type TransactionService struct {
    transactionRepo *repositories.TransactionRepository
}

// NewTransactionService membuat instance baru TransactionService
func NewTransactionService() *TransactionService {
    return &TransactionService{
        transactionRepo: repositories.NewTransactionRepository(),
    }
}

// GetAllTransactions mengambil semua transaksi dengan pagination dan filter
func (s *TransactionService) GetAllTransactions(page, limit int, status string) (*responses.TransactionListResponse, error) {
    // Set default values
    if page < 1 {
        page = 1
    }
    if limit < 1 {
        limit = 10
    }

    // Get transactions from repository
    transactions, total, err := s.transactionRepo.GetAllTransactions(page, limit, status)
    if err != nil {
        return nil, err
    }

    // Convert to response format
    var transactionResponses []responses.TransactionResponse
    for _, transaction := range transactions {
        transactionResponse := responses.TransactionResponse{
            ID:          int64(transaction.ID),
            UserID:      int64(transaction.UserID),
            UserName:    transaction.User.Name,
            UserEmail:   transaction.User.Email,
            Status:      transaction.Status,
            TotalAmount: transaction.TotalAmount,
            PaymentURL:  transaction.PaymentURL,
            CreatedAt:   transaction.CreatedAt,
            UpdatedAt:   transaction.UpdatedAt,
        }
        transactionResponses = append(transactionResponses, transactionResponse)
    }

    return &responses.TransactionListResponse{
        Transactions: transactionResponses,
        Total:        int64(total),
        Page:         page,
        Limit:        limit,
    }, nil
}

// GetTransactionByID mengambil transaksi berdasarkan ID dengan detail
func (s *TransactionService) GetTransactionByID(id uint) (*responses.TransactionResponse, error) {
    // Get transaction from repository
    transaction, err := s.transactionRepo.GetTransactionByID(id)
    if err != nil {
        return nil, err
    }

    // Convert details to response format
    var detailResponses []responses.TransactionDetailResponse
    for _, detail := range transaction.TransactionDetails {
        detailResponse := responses.TransactionDetailResponse{
            ID:            int64(detail.ID),
            TransactionID: int64(detail.TransactionID),
            ProductID:     int64(detail.ProductID),
            ProductName:   detail.Product.Name,
            ProductImage:  detail.Product.ImageURL,
            Quantity:      detail.Quantity,
            Price:         detail.Price,
            Subtotal:      float64(detail.Quantity) * detail.Price,
        }
        detailResponses = append(detailResponses, detailResponse)
    }

    // Convert to response format
    transactionResponse := &responses.TransactionResponse{
        ID:          int64(transaction.ID),
        UserID:      int64(transaction.UserID),
        UserName:    transaction.User.Name,
        UserEmail:   transaction.User.Email,
        Status:      transaction.Status,
        TotalAmount: transaction.TotalAmount,
        PaymentURL:  transaction.PaymentURL,
        CreatedAt:   transaction.CreatedAt,
        UpdatedAt:   transaction.UpdatedAt,
        Details:     detailResponses,
    }

    return transactionResponse, nil
}

// UpdateTransactionStatus mengupdate status transaksi
func (s *TransactionService) UpdateTransactionStatus(id uint, req requests.UpdateTransactionStatusRequest) (*responses.TransactionResponse, error) {
    // Validasi request
    if err := req.Validate(); err != nil {
        return nil, err
    }

    // Cek apakah transaction ada
    _, err := s.transactionRepo.GetTransactionByID(id)
    if err != nil {
        return nil, err
    }

    // Update transaction status
    err = s.transactionRepo.UpdateTransactionStatus(id, req.Status)
    if err != nil {
        return nil, err
    }

    // Get updated transaction
    transactionResponse, err := s.GetTransactionByID(id)
    if err != nil {
        return nil, err
    }

    return transactionResponse, nil
}

</code></pre>

                    <h3>🎮 6. Membuat Handler Layer</h3>
                    <p>Buat file <code>handlers/transaction_handler.go</code>:</p>
                    
                    <pre><code>package handlers

import (
    "net/http"
    "strconv"
    "tokogo/requests"
    "tokogo/responses"
    "tokogo/services"

    "github.com/gin-gonic/gin"
)

type TransactionHandler struct {
    transactionService *services.TransactionService
}

// NewTransactionHandler membuat instance baru TransactionHandler
func NewTransactionHandler() *TransactionHandler {
    return &TransactionHandler{
        transactionService: services.NewTransactionService(),
    }
}

// GetAllTransactions handler untuk mengambil semua transaksi
func (h *TransactionHandler) GetAllTransactions(c *gin.Context) {
    // Parse query parameters
    status := c.Query("status")
    pageStr := c.DefaultQuery("page", "1")
    limitStr := c.DefaultQuery("limit", "10")

    page, err := strconv.Atoi(pageStr)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: "Invalid page parameter",
        })
        return
    }

    limit, err := strconv.Atoi(limitStr)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: "Invalid limit parameter",
        })
        return
    }

    // Get transactions
    result, err := h.transactionService.GetAllTransactions(page, limit, status)
    if err != nil {
        c.JSON(http.StatusInternalServerError, responses.ErrorResponse{
            Error:   "get_transactions_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Transactions retrieved successfully",
        Data:    result,
    })
}

// GetTransactionByID handler untuk mengambil transaksi berdasarkan ID
func (h *TransactionHandler) GetTransactionByID(c *gin.Context) {
    // Parse transaction ID
    idStr := c.Param("id")
    id, err := strconv.ParseUint(idStr, 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: "Invalid transaction ID",
        })
        return
    }

    // Get transaction
    transaction, err := h.transactionService.GetTransactionByID(uint(id))
    if err != nil {
        c.JSON(http.StatusNotFound, responses.ErrorResponse{
            Error:   "transaction_not_found",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Transaction retrieved successfully",
        Data:    transaction,
    })
}

// UpdateTransactionStatus handler untuk mengupdate status transaksi
func (h *TransactionHandler) UpdateTransactionStatus(c *gin.Context) {
    // Parse transaction ID
    idStr := c.Param("id")
    id, err := strconv.ParseUint(idStr, 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: "Invalid transaction ID",
        })
        return
    }

    // Parse request body
    var req requests.UpdateTransactionStatusRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Update transaction status
    transaction, err := h.transactionService.UpdateTransactionStatus(uint(id), req)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "update_transaction_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Transaction status updated successfully",
        Data:    transaction,
    })
}

</code></pre>

                    <h3>🔗 7. Menambahkan Routes di main.go</h3>
                    <p>Update file <code>main.go</code> untuk menambahkan routes transaction management:</p>
                    
                    <pre><code>// Tambahkan routes untuk transaction management
func setupRoutes(r *gin.Engine) {
    // ... existing routes ...
    
    // Transaction Management Routes (Admin Only)
    transactionHandler := handlers.NewTransactionHandler()
    
    admin := r.Group("/admin")
    admin.Use(middlewares.AuthMiddleware())
    admin.Use(middlewares.AdminMiddleware())
    {
        // Transaction routes
        transactions := admin.Group("/transactions")
        {
            transactions.GET("", transactionHandler.GetAllTransactions)
            transactions.GET("/:id", transactionHandler.GetTransactionByID)
            transactions.PUT("/:id/status", transactionHandler.UpdateTransactionStatus)
        }
    }
}</code></pre>

                    <h3>🧪 8. Testing dengan Postman</h3>
                    <p>Sekarang kita akan test semua endpoint transaction management menggunakan Postman:</p>

                    <h4>📋 Test Cases untuk Transaction Management</h4>
                    <ol>
                        <li><strong>GET /admin/transactions</strong> - Ambil semua transaksi dengan pagination dan filter</li>
                        <li><strong>GET /admin/transactions/:id</strong> - Ambil detail transaksi berdasarkan ID</li>
                        <li><strong>PUT /admin/transactions/:id/status</strong> - Update status transaksi</li>
                    </ol>

                    <h4>🔐 Headers yang Diperlukan:</h4>
                    <p>Semua endpoint memerlukan header:</p>
                    <ul>
                        <li><code>Authorization: Bearer YOUR_JWT_TOKEN</code></li>
                        <li><code>Content-Type: application/json</code></li>
                    </ul>

                    <h4>📝 Contoh Request Body:</h4>
                    
                    <h5>Update Transaction Status:</h5>
                    <pre><code>{
    "status": "paid"
}</code></pre>

                    <h4>📊 Contoh Response:</h4>
                    
                    <h5>Get All Transactions:</h5>
                    <pre><code>{
    "message": "Transactions retrieved successfully",
    "data": {
        "transactions": [
            {
                "id": 1,
                "user_id": 1,
                "user_name": "John Doe",
                "user_email": "john@example.com",
                "status": "paid",
                "total_amount": 150000.00,
                "payment_url": "https://app.midtrans.com/snap/v2/vtweb/...",
                "created_at": "2024-01-01T10:00:00Z",
                "updated_at": "2024-01-01T10:30:00Z"
            }
        ],
        "total": 1,
        "page": 1,
        "limit": 10,
        "total_pages": 1
    }
}</code></pre>

                    <h5>Get Transaction Detail:</h5>
                    <pre><code>{
    "message": "Transaction retrieved successfully",
    "data": {
        "id": 1,
        "user_id": 1,
        "user_name": "John Doe",
        "user_email": "john@example.com",
        "status": "paid",
        "total_amount": 150000.00,
        "payment_url": "https://app.midtrans.com/snap/v2/vtweb/...",
        "created_at": "2024-01-01T10:00:00Z",
        "updated_at": "2024-01-01T10:30:00Z",
        "details": [
            {
                "id": 1,
                "transaction_id": 1,
                "product_id": 1,
                "product_name": "Laptop Gaming",
                "product_image": "laptop.jpg",
                "quantity": 1,
                "price": 150000.00,
                "subtotal": 150000.00
            }
        ]
    }
}</code></pre>

                    <h3>🎯 Fitur-fitur Transaction Management:</h3>
                    <ul>
                        <li>✅ <strong>List Transactions</strong> - Admin dapat melihat semua transaksi dengan pagination</li>
                        <li>✅ <strong>Filter by Status</strong> - Admin dapat filter transaksi berdasarkan status (pending, paid, failed, expired)</li>
                        <li>✅ <strong>Transaction Detail</strong> - Admin dapat melihat detail transaksi lengkap dengan produk yang dibeli</li>
                        <li>✅ <strong>Update Status</strong> - Admin dapat mengupdate status transaksi</li>
                        <li>✅ <strong>User Transactions</strong> - Admin dapat melihat transaksi berdasarkan user tertentu</li>
                        <li>✅ <strong>Pagination</strong> - Semua list endpoint mendukung pagination</li>
                        <li>✅ <strong>Validation</strong> - Semua input divalidasi dengan baik</li>
                        <li>✅ <strong>Error Handling</strong> - Error handling yang komprehensif</li>
                    </ul>

                    <h3>🔒 Security Features:</h3>
                    <ul>
                        <li>✅ <strong>Admin Only Access</strong> - Semua endpoint hanya bisa diakses admin</li>
                        <li>✅ <strong>JWT Authentication</strong> - Memerlukan token yang valid</li>
                        <li>✅ <strong>Input Validation</strong> - Semua input divalidasi</li>
                        <li>✅ <strong>SQL Injection Protection</strong> - Menggunakan prepared statements</li>
                    </ul>

                    <h3>📊 Database Schema yang Digunakan:</h3>
                    <ul>
                        <li>✅ <strong>Transactions Table</strong> - Menyimpan informasi transaksi utama</li>
                        <li>✅ <strong>TransactionDetails Table</strong> - Menyimpan detail produk dalam transaksi</li>
                        <li>✅ <strong>Foreign Key Constraints</strong> - Relasi yang aman antar tabel</li>
                        <li>✅ <strong>Indexing</strong> - Optimasi query dengan indexing yang tepat</li>
                    </ul>

                    <h3>📝 9. Update Database Config untuk AutoMigrate</h3>
                    <p>Update file <code>config/database.go</code> untuk menambahkan Transaction model:</p>
                    
                    <pre><code>package config

import (
    "fmt"
    "log"
    "os"
    "tokogo/models"

    "gorm.io/driver/mysql"
    "gorm.io/gorm"
)

var DB *gorm.DB

// InitDB menginisialisasi koneksi database
func InitDB() {
    var err error

    // Konfigurasi database dari environment variables
    dbHost := GetEnv("DB_HOST", "localhost")
    dbPort := GetEnv("DB_PORT", "3306")
    dbUser := GetEnv("DB_USER", "root")
    dbPassword := GetEnv("DB_PASSWORD", "")
    dbName := GetEnv("DB_NAME", "tokogo")

    // Buat DSN (Data Source Name)
    dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local",
        dbUser, dbPassword, dbHost, dbPort, dbName)

    // Koneksi ke database
    DB, err = gorm.Open(mysql.Open(dsn), &gorm.Config{})
    if err != nil {
        log.Fatal("Failed to connect to database:", err)
    }

    // Auto migrate models
    err = DB.AutoMigrate(
        &models.User{},
        &models.Category{},
        &models.Product{},
        &models.Transaction{},
        &models.TransactionDetail{},
    )
    if err != nil {
        log.Fatal("Failed to migrate database:", err)
    }

    log.Println("Database connected and migrated successfully")
}

// GetDB mengembalikan instance database
func GetDB() *gorm.DB {
    return DB
}</code></pre>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; border-radius: 5px; margin: 1.5rem 0;">
                        <h4 style="color: #2c3e50; margin-bottom: 1rem;">💡 Penjelasan Database Config Update</h4>
                        <ul>
                            <li><strong>AutoMigrate:</strong> Menambahkan Transaction dan TransactionDetail models</li>
                            <li><strong>Foreign Keys:</strong> GORM akan otomatis membuat relasi antar tabel</li>
                            <li><strong>Table Creation:</strong> Tabel akan dibuat otomatis jika belum ada</li>
                            <li><strong>Schema Update:</strong> Schema akan diupdate jika ada perubahan</li>
                        </ul>
                        <p style="color: #495057; margin-bottom: 0;"><strong>💡 Keuntungan:</strong> Dengan AutoMigrate, kita tidak perlu membuat tabel secara manual. GORM akan menangani pembuatan tabel dan relasi berdasarkan model yang didefinisikan.</p>
                    </div>

                    <h3>✅ Checklist Implementasi</h3>
                    <p>Pastikan Anda telah menyelesaikan semua langkah berikut:</p>
                    <ul>
                        <li>✅ Membuat model Transaction dan TransactionDetail di models/transaction.go</li>
                        <li>✅ Membuat request structs di requests/transaction_request.go</li>
                        <li>✅ Membuat response structs di responses/transaction_response.go</li>
                        <li>✅ Membuat repository di repositories/transaction_repository.go</li>
                        <li>✅ Membuat service di services/transaction_service.go</li>
                        <li>✅ Membuat handler di handlers/transaction_handler.go</li>
                        <li>✅ Menambahkan routes di main.go</li>
                        <li>✅ Update database config untuk AutoMigrate</li>
                        <li>✅ Test semua endpoint dengan Postman</li>
                    </ul>

                    <div style="background: #d4edda; border: 1px solid #c3e6cb; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #155724; margin-bottom: 1rem;">🎉 Selamat! Modul Transaction Management Selesai!</h3>
                        <p style="color: #155724; margin-bottom: 0;">Dengan sistem Transaction Management yang lengkap, admin dapat mengelola semua transaksi dengan mudah. Sistem ini menyediakan visibilitas penuh terhadap aktivitas transaksi dan memungkinkan admin untuk mengelola status transaksi sesuai kebutuhan bisnis.</p>
                    </div>
                `
            },
            {
                id: 'chapter-14',
                title: 'Bab 14: Modul Profile & Password - User Management',
                meta: 'Halaman 14 dari 50 • Dibaca 25 menit',
                content: `
                    <h2>👤 Bab 14: Modul Profile & Password - User Management</h2>
                    <p>Selamat! Sekarang kita akan membuat modul Profile dan Password yang memungkinkan user yang sudah login untuk mengedit profil mereka dan mengubah password. Di bab ini, kita akan mengimplementasikan sistem manajemen profil user dengan fitur edit profile dan change password.</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">🎯 Apa yang Akan Kita Buat di Bab Ini?</h3>
                        <p style="color: #495057; margin-bottom: 0;">Kita akan membuat sistem Profile dan Password Management yang lengkap dengan fitur edit profile dan change password. User yang sudah login dapat mengedit nama dan email mereka, serta mengubah password dengan validasi yang ketat. Semua endpoint memerlukan authentication dan hanya bisa diakses oleh user yang login.</p>
                    </div>

                    <h3>📋 Prasyarat</h3>
                    <p>Sebelum memulai, pastikan Anda sudah menyelesaikan:</p>
                    <ul>
                        <li>✅ Bab 6-8: Modul Authentication (Register, Login, Logout)</li>
                        <li>✅ Bab 9: Review Pembelajaran Authentication</li>
                        <li>✅ Bab 10: Modul CRUD Kategori - Role Admin</li>
                        <li>✅ Bab 11: Modul CRUD Product - Role Admin</li>
                        <li>✅ Bab 12: Modul User Management - Role Admin</li>
                        <li>✅ Bab 13: Modul Transaction Management - Role Admin</li>
                        <li>✅ Middleware authentication sudah berfungsi</li>
                        <li>✅ Model User sudah ada dan berfungsi</li>
                        <li>✅ Tabel users sudah ada di database</li>
                    </ul>

                    <h3>🗄️ Database Schema</h3>
                    <p>Kita akan menggunakan tabel users yang sudah ada. Berikut adalah schema yang akan kita gunakan:</p>

                    <h4>📊 Tabel Users (Sudah Ada)</h4>
                    <pre><code>CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    role ENUM('customer','admin') DEFAULT 'customer',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL
);</code></pre>

                    <h3>🏗️ Struktur File yang Akan Dibuat</h3>
                    <p>Kita akan membuat file-file berikut untuk modul Profile dan Password:</p>
                    <ul>
                        <li><code>requests/profile_request.go</code> - Request structs untuk profile management</li>
                        <li><code>responses/profile_response.go</code> - Response structs untuk profile management</li>
                        <li><code>repositories/profile_repository.go</code> - Repository layer untuk profile management</li>
                        <li><code>services/profile_service.go</code> - Service layer untuk profile management</li>
                        <li><code>handlers/profile_handler.go</code> - Handler layer untuk profile management</li>
                    </ul>

                    <h3>📝 1. Membuat Request Structs</h3>
                    <p>Pertama, kita buat file <code>requests/profile_request.go</code>:</p>
                    <pre><code>package requests

import (
    "errors"
    "strings"

    "github.com/go-playground/validator/v10"
)

// UpdateProfileRequest represents the request structure for updating profile
type UpdateProfileRequest struct {
    Name  string \`json:"name" validate:"required,min=3,max=255"\`
    Email string \`json:"email" validate:"required,email,max=255"\`
}

// ChangePasswordRequest represents the request structure for changing password
type ChangePasswordRequest struct {
    CurrentPassword string \`json:"current_password" validate:"required"\`
    NewPassword     string \`json:"new_password" validate:"required,min=6,max=255"\`
    ConfirmPassword string \`json:"confirm_password" validate:"required"\`
}

// Validate validates the UpdateProfileRequest using the validator
func (r *UpdateProfileRequest) Validate() error {
    validate := validator.New()

    // Validasi struct fields
    if err := validate.Struct(r); err != nil {
        return err
    }

    // Validasi custom: nama tidak boleh kosong setelah trim
    if strings.TrimSpace(r.Name) == "" {
        return errors.New("name cannot be empty")
    }

    // Validasi custom: email tidak boleh kosong setelah trim
    if strings.TrimSpace(r.Email) == "" {
        return errors.New("email cannot be empty")
    }

    return nil
}

// Validate validates the ChangePasswordRequest using the validator
func (r *ChangePasswordRequest) Validate() error {
    validate := validator.New()

    // Validasi struct fields
    if err := validate.Struct(r); err != nil {
        return err
    }

    // Validasi custom: current password tidak boleh kosong setelah trim
    if strings.TrimSpace(r.CurrentPassword) == "" {
        return errors.New("current password cannot be empty")
    }

    // Validasi custom: new password tidak boleh kosong setelah trim
    if strings.TrimSpace(r.NewPassword) == "" {
        return errors.New("new password cannot be empty")
    }

    // Validasi custom: confirm password tidak boleh kosong setelah trim
    if strings.TrimSpace(r.ConfirmPassword) == "" {
        return errors.New("confirm password cannot be empty")
    }

    // Validasi password match
    if r.NewPassword != r.ConfirmPassword {
        return errors.New("new password and confirm password must match")
    }

    // Validasi password tidak sama dengan current
    if r.CurrentPassword == r.NewPassword {
        return errors.New("new password cannot be the same as current password")
    }

    return nil
}</code></pre>

                    <h3>📤 2. Membuat Response Structs</h3>
                    <p>Buat file <code>responses/profile_response.go</code>:</p>
                    <pre><code>package responses

import "tokogo/models"

// ProfileResponse struct untuk response profile
type ProfileResponse struct {
    ID        uint   \`json:"id"\`
    Name      string \`json:"name"\`
    Email     string \`json:"email"\`
    Role      string \`json:"role"\`
    CreatedAt string \`json:"created_at"\`
    UpdatedAt string \`json:"updated_at"\`
}

// ChangePasswordResponse struct untuk response change password
type ChangePasswordResponse struct {
    Message string \`json:"message"\`
}

// ConvertUserToProfileResponse mengkonversi model User ke ProfileResponse
func ConvertUserToProfileResponse(user models.User) ProfileResponse {
    return ProfileResponse{
        ID:        user.ID,
        Name:      user.Name,
        Email:     user.Email,
        Role:      user.Role,
        CreatedAt: user.CreatedAt.Format("2006-01-02 15:04:05"),
        UpdatedAt: user.UpdatedAt.Format("2006-01-02 15:04:05"),
    }
}</code></pre>

                    <h3>🗄️ 3. Membuat Repository Layer</h3>
                    <p>Buat file <code>repositories/profile_repository.go</code>:</p>
                    <pre><code>package repositories

import (
    "errors"
    "tokogo/config"
    "tokogo/models"

    "golang.org/x/crypto/bcrypt"
    "gorm.io/gorm"
)

type ProfileRepository struct {
    db *gorm.DB
}

// NewProfileRepository membuat instance baru ProfileRepository
func NewProfileRepository() *ProfileRepository {
    return &ProfileRepository{
        db: config.GetDB(),
    }
}

// GetProfileByID mengambil profile user berdasarkan ID
func (r *ProfileRepository) GetProfileByID(userID uint) (*models.User, error) {
    var user models.User
    err := r.db.First(&user, userID).Error
    if err != nil {
        return nil, err
    }
    return &user, nil
}

// UpdateProfile mengupdate profile user
func (r *ProfileRepository) UpdateProfile(userID uint, name, email string) (*models.User, error) {
    var user models.User
    
    // Cek apakah user ada
    if err := r.db.First(&user, userID).Error; err != nil {
        return nil, errors.New("user not found")
    }
    
    // Cek apakah email sudah digunakan oleh user lain
    var existingUser models.User
    if err := r.db.Where("email = ? AND id != ?", email, userID).First(&existingUser).Error; err == nil {
        return nil, errors.New("email already exists")
    }
    
    // Update profile
    user.Name = name
    user.Email = email
    
    if err := r.db.Save(&user).Error; err != nil {
        return nil, errors.New("failed to update profile")
    }
    
    return &user, nil
}

// ChangePassword mengubah password user
func (r *ProfileRepository) ChangePassword(userID uint, currentPassword, newPassword string) error {
    var user models.User
    
    // Cek apakah user ada
    if err := r.db.First(&user, userID).Error; err != nil {
        return errors.New("user not found")
    }
    
    // Verifikasi current password
    if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(currentPassword)); err != nil {
        return errors.New("current password is incorrect")
    }
    
    // Hash new password
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(newPassword), bcrypt.DefaultCost)
    if err != nil {
        return errors.New("failed to hash new password")
    }
    
    // Update password
    user.Password = string(hashedPassword)
    
    if err := r.db.Save(&user).Error; err != nil {
        return errors.New("failed to change password")
    }
    
    return nil
}</code></pre>

                    <h3>⚙️ 4. Membuat Service Layer</h3>
                    <p>Buat file <code>services/profile_service.go</code>:</p>
                    <pre><code>package services

import (
    "tokogo/repositories"
    "tokogo/requests"
    "tokogo/responses"
)

type ProfileService struct {
    profileRepo *repositories.ProfileRepository
}

// NewProfileService membuat instance baru ProfileService
func NewProfileService() *ProfileService {
    return &ProfileService{
        profileRepo: repositories.NewProfileRepository(),
    }
}

// GetProfile mengambil profile user
func (s *ProfileService) GetProfile(userID uint) (*responses.ProfileResponse, error) {
    user, err := s.profileRepo.GetProfileByID(userID)
    if err != nil {
        return nil, err
    }
    
    profileResponse := responses.ConvertUserToProfileResponse(*user)
    return &profileResponse, nil
}

// UpdateProfile mengupdate profile user
func (s *ProfileService) UpdateProfile(userID uint, req requests.UpdateProfileRequest) (*responses.ProfileResponse, error) {
    // Validasi request
    if err := req.Validate(); err != nil {
        return nil, err
    }
    
    // Update profile
    user, err := s.profileRepo.UpdateProfile(userID, req.Name, req.Email)
    if err != nil {
        return nil, err
    }
    
    profileResponse := responses.ConvertUserToProfileResponse(*user)
    return &profileResponse, nil
}

// ChangePassword mengubah password user
func (s *ProfileService) ChangePassword(userID uint, req requests.ChangePasswordRequest) (*responses.ChangePasswordResponse, error) {
    // Validasi request
    if err := req.Validate(); err != nil {
        return nil, err
    }
    
    // Change password
    if err := s.profileRepo.ChangePassword(userID, req.CurrentPassword, req.NewPassword); err != nil {
        return nil, err
    }
    
    return &responses.ChangePasswordResponse{
        Message: "Password changed successfully",
    }, nil
}</code></pre>

                    <h3>🎮 5. Membuat Handler Layer</h3>
                    <p>Buat file <code>handlers/profile_handler.go</code>:</p>
                    <pre><code>package handlers

import (
    "net/http"
    "tokogo/requests"
    "tokogo/responses"
    "tokogo/services"
    
    "github.com/gin-gonic/gin"
)

type ProfileHandler struct {
    profileService *services.ProfileService
}

// NewProfileHandler membuat instance baru ProfileHandler
func NewProfileHandler() *ProfileHandler {
    return &ProfileHandler{
        profileService: services.NewProfileService(),
    }
}

// GetProfile handler untuk mengambil profile user
func (h *ProfileHandler) GetProfile(c *gin.Context) {
    // Ambil user ID dari JWT token
    userIDInterface, exists := c.Get("user_id")
    if !exists {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "unauthorized",
            Message: "User ID not found",
        })
        return
    }
    
    userID, ok := userIDInterface.(uint)
    if !ok {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "unauthorized",
            Message: "Invalid user ID",
        })
        return
    }
    
    // Panggil service untuk get profile
    profile, err := h.profileService.GetProfile(userID)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "get_profile_failed",
            Message: err.Error(),
        })
        return
    }
    
    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Profile retrieved successfully",
        Data:    profile,
    })
}

// UpdateProfile handler untuk mengupdate profile user
func (h *ProfileHandler) UpdateProfile(c *gin.Context) {
    // Ambil user ID dari JWT token
    userIDInterface, exists := c.Get("user_id")
    if !exists {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "unauthorized",
            Message: "User ID not found",
        })
        return
    }
    
    userID, ok := userIDInterface.(uint)
    if !ok {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "unauthorized",
            Message: "Invalid user ID",
        })
        return
    }
    
    var req requests.UpdateProfileRequest
    
    // Bind dan validasi request
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }
    
    // Panggil service untuk update profile
    response, err := h.profileService.UpdateProfile(userID, req)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "update_profile_failed",
            Message: err.Error(),
        })
        return
    }
    
    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Profile updated successfully",
        Data:    response,
    })
}

// ChangePassword handler untuk mengubah password user
func (h *ProfileHandler) ChangePassword(c *gin.Context) {
    // Ambil user ID dari JWT token
    userIDInterface, exists := c.Get("user_id")
    if !exists {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "unauthorized",
            Message: "User ID not found",
        })
        return
    }
    
    userID, ok := userIDInterface.(uint)
    if !ok {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "unauthorized",
            Message: "Invalid user ID",
        })
        return
    }
    
    var req requests.ChangePasswordRequest
    
    // Bind dan validasi request
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }
    
    // Panggil service untuk change password
    response, err := h.profileService.ChangePassword(userID, req)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "change_password_failed",
            Message: err.Error(),
        })
        return
    }
    
    c.JSON(http.StatusOK, response)
}</code></pre>

                    <h3>🔗 6. Menambahkan Routes di main.go</h3>
                    <p>Sekarang kita akan menambahkan routes untuk profile dan password management di main.go:</p>
                    <pre><code>// Tambahkan routes untuk profile dan password management
func setupRoutes(r *gin.Engine) {
    // ... existing routes ...
    
    // Profile & Password Management Routes (Authenticated Users)
    profileHandler := handlers.NewProfileHandler()
    
    // Profile routes
    r.GET("/profile", middlewares.AuthMiddleware(), profileHandler.GetProfile)
    r.PUT("/profile", middlewares.AuthMiddleware(), profileHandler.UpdateProfile)
    
    // Password routes
    r.PUT("/password", middlewares.AuthMiddleware(), profileHandler.ChangePassword)
}</code></pre>

                    <h3>🧪 Testing dengan Postman</h3>
                    <p>Sekarang kita akan test semua endpoint yang sudah dibuat menggunakan Postman.</p>

                    <h4>📋 Test Cases untuk Profile Management</h4>
                    <ol>
                        <li><strong>GET /profile</strong> - Ambil profile user yang login</li>
                        <li><strong>PUT /profile</strong> - Update profile user yang login</li>
                        <li><strong>PUT /password</strong> - Ubah password user yang login</li>
                    </ol>

                    <h4>🔐 Headers yang Diperlukan</h4>
                    <pre><code>Authorization: Bearer YOUR_JWT_TOKEN
Content-Type: application/json</code></pre>

                    <h4>📝 Sample Request Body untuk Update Profile</h4>
                    <pre><code>{
    "name": "John Doe Updated",
    "email": "john.doe.updated@example.com"
}</code></pre>

                    <h4>📝 Sample Request Body untuk Change Password</h4>
                    <pre><code>{
    "current_password": "oldpassword123",
    "new_password": "newpassword123",
    "confirm_password": "newpassword123"
}</code></pre>

                    <h3>✅ Fitur yang Sudah Diimplementasikan</h3>
                    <ul>
                        <li>✅ <strong>Get Profile</strong> - User dapat melihat profile mereka</li>
                        <li>✅ <strong>Update Profile</strong> - User dapat mengedit nama dan email</li>
                        <li>✅ <strong>Change Password</strong> - User dapat mengubah password dengan validasi</li>
                        <li>✅ <strong>Authentication Required</strong> - Semua endpoint memerlukan JWT token</li>
                        <li>✅ <strong>Input Validation</strong> - Semua input divalidasi dengan ketat</li>
                        <li>✅ <strong>Password Security</strong> - Password di-hash dengan bcrypt</li>
                        <li>✅ <strong>Email Uniqueness</strong> - Email harus unik saat update</li>
                        <li>✅ <strong>Current Password Verification</strong> - Verifikasi password lama saat change password</li>
                    </ul>

                    <h3>🔒 Keamanan yang Diimplementasikan</h3>
                    <ul>
                        <li>✅ <strong>JWT Authentication</strong> - Semua endpoint memerlukan token yang valid</li>
                        <li>✅ <strong>User Authorization</strong> - User hanya bisa mengakses profile mereka sendiri</li>
                        <li>✅ <strong>Input Validation</strong> - Semua input divalidasi</li>
                        <li>✅ <strong>Password Hashing</strong> - Password di-hash dengan bcrypt</li>
                        <li>✅ <strong>SQL Injection Protection</strong> - Menggunakan GORM ORM</li>
                        <li>✅ <strong>Email Uniqueness Check</strong> - Mencegah duplikasi email</li>
                    </ul>

                    <h3>📊 Database Schema yang Digunakan:</h3>
                    <ul>
                        <li>✅ <strong>Users Table</strong> - Menggunakan tabel users yang sudah ada</li>
                        <li>✅ <strong>Password Hashing</strong> - Password disimpan dalam bentuk hash</li>
                        <li>✅ <strong>Email Uniqueness</strong> - Constraint unique pada email</li>
                        <li>✅ <strong>Soft Delete</strong> - Menggunakan soft delete untuk data integrity</li>
                    </ul>

                    <div style="background: #d4edda; border: 1px solid #c3e6cb; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #155724; margin-bottom: 1rem;">🎉 Selamat! Modul Profile & Password Selesai!</h3>
                        <p style="color: #155724; margin-bottom: 0;">Dengan sistem Profile dan Password Management yang lengkap, user dapat mengelola profil mereka dengan aman. Sistem ini menyediakan fitur edit profile dan change password dengan validasi yang ketat dan keamanan yang tinggi.</p>
                    </div>
                `
            },
            {
                id: 'chapter-15',
                title: 'Bab 15: Relaksasi & Review Pembelajaran - Modul CRUD & User Management',
                meta: 'Halaman 15 dari 50 • Dibaca 20 menit',
                content: `
                    <h2>🧘 Bab 15: Relaksasi & Review Pembelajaran - Modul CRUD & User Management</h2>
                    <p>Selamat! Anda telah berhasil menyelesaikan modul-modul CRUD dan User Management yang lengkap (Bab 10-14). Sekarang saatnya untuk beristirahat sejenak dan mengulas kembali semua yang telah dipelajari tentang sistem manajemen data dan user. Bab ini dirancang untuk membantu otak Anda mengkonsolidasikan pengetahuan CRUD dan User Management yang baru saja diperoleh.</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">🎯 Tujuan Bab Relaksasi Ini</h3>
                        <p style="color: #495057; margin-bottom: 0;">Bab ini akan membantu Anda mengkonsolidasikan pembelajaran dari modul CRUD Kategori, CRUD Product, User Management, Transaction Management, dan Profile & Password Management. Kita akan mengulas kembali konsep-konsep penting, pola-pola yang digunakan, dan bagaimana semua modul ini saling terhubung dalam sistem yang lebih besar.</p>
                    </div>

                    <h3>📚 Ringkasan Pembelajaran Bab 10-14</h3>
                    <p>Mari kita ulas kembali semua yang telah dipelajari dalam modul CRUD dan User Management:</p>

                    <h4>📂 Bab 10: Modul CRUD Kategori - Role Admin</h4>
                    <div style="background: #e3f2fd; border-left: 4px solid #2196f3; padding: 1rem; margin: 1rem 0;">
                        <p><strong>Konsep Utama:</strong> Sistem manajemen kategori dengan operasi CRUD lengkap</p>
                        <p><strong>Fitur yang Dipelajari:</strong></p>
                        <ul>
                            <li>✅ <strong>Create Category</strong> - Membuat kategori baru dengan validasi</li>
                            <li>✅ <strong>Get Categories</strong> - Mengambil daftar kategori dengan pagination</li>
                            <li>✅ <strong>Get Category by ID</strong> - Mengambil detail kategori spesifik</li>
                            <li>✅ <strong>Update Category</strong> - Mengupdate informasi kategori</li>
                            <li>✅ <strong>Delete Category</strong> - Menghapus kategori dengan soft delete</li>
                        </ul>
                        <p><strong>Pola yang Digunakan:</strong> Repository Pattern, Service Layer, Handler Layer, Request/Response Validation</p>
                    </div>

                    <h4>📦 Bab 11: Modul CRUD Product - Role Admin</h4>
                    <div style="background: #e8f5e8; border-left: 4px solid #4caf50; padding: 1rem; margin: 1rem 0;">
                        <p><strong>Konsep Utama:</strong> Sistem manajemen produk dengan relasi ke kategori</p>
                        <p><strong>Fitur yang Dipelajari:</strong></p>
                        <ul>
                            <li>✅ <strong>Create Product</strong> - Membuat produk baru dengan validasi kategori</li>
                            <li>✅ <strong>Get Products</strong> - Mengambil daftar produk dengan filter dan pagination</li>
                            <li>✅ <strong>Get Product by ID</strong> - Mengambil detail produk dengan relasi kategori</li>
                            <li>✅ <strong>Update Product</strong> - Mengupdate informasi produk</li>
                            <li>✅ <strong>Delete Product</strong> - Menghapus produk dengan soft delete</li>
                        </ul>
                        <p><strong>Pola yang Digunakan:</strong> Foreign Key Relationships, File Upload Handling, Complex Validation</p>
                    </div>

                    <h4>👥 Bab 12: Modul User Management - Role Admin</h4>
                    <div style="background: #fff3e0; border-left: 4px solid #ff9800; padding: 1rem; margin: 1rem 0;">
                        <p><strong>Konsep Utama:</strong> Sistem manajemen user dengan role-based access control</p>
                        <p><strong>Fitur yang Dipelajari:</strong></p>
                        <ul>
                            <li>✅ <strong>Create User</strong> - Membuat user baru dengan role assignment</li>
                            <li>✅ <strong>Get Users</strong> - Mengambil daftar user dengan filter role</li>
                            <li>✅ <strong>Get User by ID</strong> - Mengambil detail user spesifik</li>
                            <li>✅ <strong>Update User</strong> - Mengupdate informasi user dan role</li>
                            <li>✅ <strong>Delete User</strong> - Menghapus user dengan soft delete</li>
                            <li>✅ <strong>Change Password</strong> - Mengubah password user oleh admin</li>
                        </ul>
                        <p><strong>Pola yang Digunakan:</strong> Role-Based Access Control, Password Hashing, Admin Middleware</p>
                    </div>

                    <h4>💳 Bab 13: Modul Transaction Management - Role Admin</h4>
                    <div style="background: #f3e5f5; border-left: 4px solid #9c27b0; padding: 1rem; margin: 1rem 0;">
                        <p><strong>Konsep Utama:</strong> Sistem manajemen transaksi dengan detail produk</p>
                        <p><strong>Fitur yang Dipelajari:</strong></p>
                        <ul>
                            <li>✅ <strong>Get Transactions</strong> - Mengambil daftar transaksi dengan filter status</li>
                            <li>✅ <strong>Get Transaction by ID</strong> - Mengambil detail transaksi dengan produk</li>
                            <li>✅ <strong>Update Transaction Status</strong> - Mengupdate status transaksi</li>
                        </ul>
                        <p><strong>Pola yang Digunakan:</strong> Complex Relationships, Transaction Details, Status Management</p>
                    </div>

                    <h4>👤 Bab 14: Modul Profile & Password - User Management</h4>
                    <div style="background: #e0f2f1; border-left: 4px solid #009688; padding: 1rem; margin: 1rem 0;">
                        <p><strong>Konsep Utama:</strong> Sistem manajemen profil user untuk user yang sudah login</p>
                        <p><strong>Fitur yang Dipelajari:</strong></p>
                        <ul>
                            <li>✅ <strong>Get Profile</strong> - Mengambil profil user yang login</li>
                            <li>✅ <strong>Update Profile</strong> - Mengupdate nama dan email user</li>
                            <li>✅ <strong>Change Password</strong> - Mengubah password dengan verifikasi</li>
                        </ul>
                        <p><strong>Pola yang Digunakan:</strong> User Authentication, Self-Service Management, Password Security</p>
                    </div>

                    <h3>🔗 Koneksi Antar Modul</h3>
                    <p>Mari kita lihat bagaimana semua modul ini saling terhubung:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #2c3e50; margin-bottom: 1rem;">🏗️ Arsitektur Sistem yang Terintegrasi</h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin: 1rem 0;">
                            <div style="background: #e3f2fd; padding: 1rem; border-radius: 5px; text-align: center;">
                                <h5 style="color: #1976d2; margin: 0;">👥 Users</h5>
                                <p style="margin: 0.5rem 0 0 0; font-size: 0.9rem;">Base entity untuk semua operasi</p>
                            </div>
                            <div style="background: #e8f5e8; padding: 1rem; border-radius: 5px; text-align: center;">
                                <h5 style="color: #388e3c; margin: 0;">📂 Categories</h5>
                                <p style="margin: 0.5rem 0 0 0; font-size: 0.9rem;">Referensi untuk produk</p>
                            </div>
                            <div style="background: #fff3e0; padding: 1rem; border-radius: 5px; text-align: center;">
                                <h5 style="color: #f57c00; margin: 0;">📦 Products</h5>
                                <p style="margin: 0.5rem 0 0 0; font-size: 0.9rem;">Terhubung ke kategori</p>
                            </div>
                            <div style="background: #f3e5f5; padding: 1rem; border-radius: 5px; text-align: center;">
                                <h5 style="color: #7b1fa2; margin: 0;">💳 Transactions</h5>
                                <p style="margin: 0.5rem 0 0 0; font-size: 0.9rem;">Terhubung ke user</p>
                            </div>
                        </div>
                    </div>

                    <h3>🎯 Pola-Pola Penting yang Dipelajari</h3>
                    <p>Berikut adalah pola-pola penting yang konsisten digunakan di semua modul:</p>

                    <h4>📝 1. Request/Response Pattern</h4>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <p><strong>Konsistensi yang Dicapai:</strong></p>
                        <ul>
                            <li>✅ <strong>Request Structs</strong> - Validasi menggunakan validator package</li>
                            <li>✅ <strong>Response Structs</strong> - Format response yang konsisten</li>
                            <li>✅ <strong>Error Handling</strong> - Error messages dalam bahasa Inggris</li>
                            <li>✅ <strong>Success Response</strong> - Format success yang seragam</li>
                        </ul>
                    </div>

                    <h4>🗄️ 2. Repository Pattern</h4>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <p><strong>Konsistensi yang Dicapai:</strong></p>
                        <ul>
                            <li>✅ <strong>Database Operations</strong> - Menggunakan GORM untuk semua operasi</li>
                            <li>✅ <strong>Error Handling</strong> - Error handling yang konsisten</li>
                            <li>✅ <strong>Soft Delete</strong> - Implementasi soft delete di semua modul</li>
                            <li>✅ <strong>Pagination</strong> - Pagination untuk list operations</li>
                        </ul>
                    </div>

                    <h4>⚙️ 3. Service Layer Pattern</h4>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <p><strong>Konsistensi yang Dicapai:</strong></p>
                        <ul>
                            <li>✅ <strong>Business Logic</strong> - Logika bisnis terpusat di service layer</li>
                            <li>✅ <strong>Validation</strong> - Validasi request sebelum operasi database</li>
                            <li>✅ <strong>Data Transformation</strong> - Konversi data untuk response</li>
                            <li>✅ <strong>Error Propagation</strong> - Error handling yang konsisten</li>
                        </ul>
                    </div>

                    <h4>🎮 4. Handler Layer Pattern</h4>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <p><strong>Konsistensi yang Dicapai:</strong></p>
                        <ul>
                            <li>✅ <strong>HTTP Handling</strong> - Penanganan HTTP request/response</li>
                            <li>✅ <strong>Authentication</strong> - JWT token validation</li>
                            <li>✅ <strong>Authorization</strong> - Role-based access control</li>
                            <li>✅ <strong>Error Response</strong> - Format error response yang konsisten</li>
                        </ul>
                    </div>

                    <h3>🔒 Keamanan yang Diimplementasikan</h3>
                    <p>Berikut adalah aspek keamanan yang konsisten diimplementasikan di semua modul:</p>

                    <div style="background: #fff3e0; border: 1px solid #ff9800; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #e65100; margin-bottom: 1rem;">🛡️ Security Features</h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem;">
                            <div>
                                <h5 style="color: #f57c00;">🔐 Authentication</h5>
                                <ul>
                                    <li>JWT Token Validation</li>
                                    <li>User ID Extraction</li>
                                    <li>Token Expiration Handling</li>
                                </ul>
                            </div>
                            <div>
                                <h5 style="color: #f57c00;">👑 Authorization</h5>
                                <ul>
                                    <li>Role-Based Access Control</li>
                                    <li>Admin-Only Endpoints</li>
                                    <li>User Self-Service</li>
                                </ul>
                            </div>
                            <div>
                                <h5 style="color: #f57c00;">🔒 Data Protection</h5>
                                <ul>
                                    <li>Password Hashing (bcrypt)</li>
                                    <li>Input Validation</li>
                                    <li>SQL Injection Protection</li>
                                </ul>
                            </div>
                            <div>
                                <h5 style="color: #f57c00;">📝 Data Integrity</h5>
                                <ul>
                                    <li>Soft Delete Implementation</li>
                                    <li>Foreign Key Constraints</li>
                                    <li>Email Uniqueness</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <h3>📊 Database Schema yang Terintegrasi</h3>
                    <p>Berikut adalah relasi database yang telah dibangun:</p>

                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #2e7d32; margin-bottom: 1rem;">🗄️ Database Relationships</h4>
                        <pre style="background: #f1f8e9; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>users (1) ──→ (N) transactions
users (1) ──→ (N) user_management (self-reference)

categories (1) ──→ (N) products
products (1) ──→ (N) transaction_details

transactions (1) ──→ (N) transaction_details
products (1) ──→ (N) transaction_details</code></pre>
                    </div>

                    <h3>🎯 Key Takeaways</h3>
                    <p>Berikut adalah poin-poin penting yang harus diingat:</p>

                    <div style="background: #e3f2fd; border: 1px solid #2196f3; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #1565c0; margin-bottom: 1rem;">💡 Learning Points</h4>
                        <ul>
                            <li>✅ <strong>Consistent Architecture</strong> - Semua modul menggunakan pola yang sama</li>
                            <li>✅ <strong>Separation of Concerns</strong> - Setiap layer memiliki tanggung jawab yang jelas</li>
                            <li>✅ <strong>Security First</strong> - Keamanan diimplementasikan di setiap layer</li>
                            <li>✅ <strong>Data Integrity</strong> - Relasi database yang solid dan konsisten</li>
                            <li>✅ <strong>Error Handling</strong> - Penanganan error yang konsisten di seluruh sistem</li>
                            <li>✅ <strong>Validation</strong> - Validasi input yang ketat di setiap endpoint</li>
                            <li>✅ <strong>Role-Based Access</strong> - Sistem akses berdasarkan role yang jelas</li>
                            <li>✅ <strong>Self-Service Features</strong> - User dapat mengelola profil mereka sendiri</li>
                        </ul>
                    </div>

                    <h3>🚀 Persiapan untuk Modul Selanjutnya</h3>
                    <p>Dengan pengetahuan CRUD dan User Management yang solid, Anda sekarang siap untuk mempelajari modul-modul yang lebih advanced:</p>

                    <div style="background: #f3e5f5; border: 1px solid #9c27b0; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #6a1b9a; margin-bottom: 1rem;">🎯 Preview Modul Selanjutnya</h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
                            <div style="background: #fce4ec; padding: 1rem; border-radius: 5px; text-align: center;">
                                <h5 style="color: #c2185b; margin: 0;">🛒 E-Commerce</h5>
                                <p style="margin: 0.5rem 0 0 0; font-size: 0.9rem;">Shopping cart, checkout, orders</p>
                            </div>
                            <div style="background: #e8eaf6; padding: 1rem; border-radius: 5px; text-align: center;">
                                <h5 style="color: #3f51b5; margin: 0;">📊 Analytics</h5>
                                <p style="margin: 0.5rem 0 0 0; font-size: 0.9rem;">Reports, statistics, insights</p>
                            </div>
                            <div style="background: #e0f2f1; padding: 1rem; border-radius: 5px; text-align: center;">
                                <h5 style="color: #00695c; margin: 0;">🔔 Notifications</h5>
                                <p style="margin: 0.5rem 0 0 0; font-size: 0.9rem;">Email, SMS, push notifications</p>
                            </div>
                            <div style="background: #fff8e1; padding: 1rem; border-radius: 5px; text-align: center;">
                                <h5 style="color: #f57f17; margin: 0;">🔍 Search</h5>
                                <p style="margin: 0.5rem 0 0 0; font-size: 0.9rem;">Advanced search, filters</p>
                            </div>
                        </div>
                    </div>

                    <h3>🧘 Relaksasi dan Refleksi</h3>
                    <p>Sebelum melanjutkan ke modul selanjutnya, mari kita lakukan relaksasi sejenak:</p>

                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #2e7d32; margin-bottom: 1rem;">🌱 Refleksi Pembelajaran</h4>
                        <p style="color: #388e3c; margin-bottom: 1rem;">Anda telah berhasil menguasai:</p>
                        <ul style="color: #388e3c;">
                            <li>✅ <strong>5 Modul CRUD Lengkap</strong> - Kategori, Product, User, Transaction, Profile</li>
                            <li>✅ <strong>Role-Based Access Control</strong> - Admin dan User permissions</li>
                            <li>✅ <strong>Database Relationships</strong> - Foreign keys dan relasi antar tabel</li>
                            <li>✅ <strong>Security Implementation</strong> - Authentication, authorization, data protection</li>
                            <li>✅ <strong>Consistent Architecture</strong> - Pattern yang sama di semua modul</li>
                        </ul>
                        <p style="color: #2e7d32; margin-top: 1rem; font-style: italic;">"Konsistensi adalah kunci dari arsitektur yang baik. Dengan pola yang sama, kita dapat membangun sistem yang mudah dipahami, di-maintain, dan di-scale."</p>
                    </div>

                    <div style="background: #d4edda; border: 1px solid #c3e6cb; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #155724; margin-bottom: 1rem;">🎉 Selamat! Modul CRUD & User Management Selesai!</h3>
                        <p style="color: #155724; margin-bottom: 0;">Dengan penguasaan modul CRUD dan User Management yang solid, Anda sekarang memiliki fondasi yang kuat untuk membangun aplikasi web yang kompleks. Semua pola dan konsep yang dipelajari akan menjadi dasar untuk modul-modul advanced selanjutnya.</p>
                    </div>
                `
            }
        ];

        // Current chapter index
        let currentChapterIndex = 0;

        // Font size control
        let currentFontSize = 16;
        const fontSizeDisplay = document.getElementById('fontSize');

        function increaseFont() {
            currentFontSize = Math.min(currentFontSize + 2, 24);
            const contentBody = document.getElementById('contentBody');
            if (contentBody) {
                contentBody.style.fontSize = currentFontSize + 'px';
            }
            fontSizeDisplay.textContent = currentFontSize + 'px';
        }

        function decreaseFont() {
            currentFontSize = Math.max(currentFontSize - 2, 12);
            const contentBody = document.getElementById('contentBody');
            if (contentBody) {
                contentBody.style.fontSize = currentFontSize + 'px';
            }
            fontSizeDisplay.textContent = currentFontSize + 'px';
        }

        // Chapter management functions
        function renderChapterList() {
            const chapterList = document.getElementById('chapterList');
            chapterList.innerHTML = '';
            
            chapters.forEach((chapter, index) => {
                const li = document.createElement('li');
                li.className = 'chapter-item';
                
                const a = document.createElement('a');
                a.href = `#${chapter.id}`;
                a.className = 'chapter-link';
                a.textContent = chapter.title;
                a.onclick = (e) => {
                    e.preventDefault();
                    showChapter(index);
                };
                
                li.appendChild(a);
                chapterList.appendChild(li);
            });
        }

        function renderChapter(index) {
            const chapter = chapters[index];
            const contentArea = document.getElementById('contentArea');
            
            contentArea.innerHTML = `
                <div class="content-header">
                    <h1 class="chapter-title">${chapter.title}</h1>
                    <div class="chapter-meta">${chapter.meta}</div>
                </div>
                <div class="content-body" id="contentBody">
                    ${chapter.content}
                </div>
                <div class="navigation">
                    <button class="nav-btn" ${index === 0 ? 'disabled' : ''} onclick="showChapter(${index - 1})">← Sebelumnya</button>
                    <button class="nav-btn" ${index === chapters.length - 1 ? 'disabled' : ''} onclick="showChapter(${index + 1})">Selanjutnya →</button>
                </div>
            `;
            
            // Apply font size to new content
            const contentBody = document.getElementById('contentBody');
            if (contentBody) {
                contentBody.style.fontSize = currentFontSize + 'px';
            }
        }

        function showChapter(index) {
            if (index >= 0 && index < chapters.length) {
                currentChapterIndex = index;
                renderChapter(index);
                updateActiveChapter();
                
                // Scroll to top
                window.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });
            }
        }

        function updateActiveChapter() {
            document.querySelectorAll('.chapter-link').forEach((link, index) => {
                link.classList.toggle('active', index === currentChapterIndex);
            });
        }

        // Function to add new chapter easily
        function addChapter(title, meta, content) {
            const newChapter = {
                id: `chapter${chapters.length + 1}`,
                title: title,
                meta: meta,
                content: content
            };
            chapters.push(newChapter);
            renderChapterList();
            return newChapter;
        }

        // Example of how to add a new chapter:
        // addChapter(
        //     'Bab 3: Struktur Project',
        //     'Halaman 3 dari 50 • Dibaca 10 menit',
        //     '<h2>Struktur Project yang Baik</h2><p>Konten bab 3...</p>'
        // );

        // Dark mode toggle
        function toggleDarkMode() {
            const body = document.body;
            const header = document.getElementById('header');
            const logo = document.getElementById('logo');
            const logoSubtitle = document.getElementById('logoSubtitle');
            const themeIcon = document.getElementById('themeIcon');
            const themeText = document.getElementById('themeText');
            const themeToggle = document.getElementById('themeToggle');
            
            body.classList.toggle('dark-mode');
            header.classList.toggle('dark');
            logo.classList.toggle('dark');
            logoSubtitle.classList.toggle('dark');
            themeToggle.classList.toggle('dark');
            
            if (body.classList.contains('dark-mode')) {
                themeIcon.textContent = '☀️';
                themeText.textContent = 'Light';
            } else {
                themeIcon.textContent = '🌙';
                themeText.textContent = 'Dark';
            }
            
            // Save theme preference to localStorage
            localStorage.setItem('darkMode', body.classList.contains('dark-mode'));
        }

        // Load theme preference from localStorage
        function loadThemePreference() {
            const savedTheme = localStorage.getItem('darkMode');
            if (savedTheme === 'true') {
                toggleDarkMode();
            }
        }

        // Sidebar toggle
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('show');
        }

        // Progress bar
        function updateProgress() {
            const scrollTop = window.pageYOffset;
            const docHeight = document.body.scrollHeight - window.innerHeight;
            const scrollPercent = (scrollTop / docHeight) * 100;
            document.getElementById('progressBar').style.width = scrollPercent + '%';
        }

        // Event listeners
        window.addEventListener('scroll', function() {
            updateProgress();
        });
        
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize the ebook
            renderChapterList();
            showChapter(0); // Start with first chapter
            updateProgress();
            loadThemePreference(); // Load saved theme preference
        });

        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', function(e) {
            const sidebar = document.getElementById('sidebar');
            const sidebarToggle = document.querySelector('.sidebar-toggle');
            
            if (window.innerWidth <= 768 && 
                sidebar && 
                !sidebar.contains(e.target) && 
                !sidebarToggle.contains(e.target) && 
                sidebar.classList.contains('show')) {
                sidebar.classList.remove('show');
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case '=':
                    case '+':
                        e.preventDefault();
                        increaseFont();
                        break;
                    case '-':
                        e.preventDefault();
                        decreaseFont();
                        break;
                }
            }
        });
    </script>
</body>
</html>
