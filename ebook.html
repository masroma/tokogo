<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Golang From Hero To Hero - Membangun API Mini Toko Online</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #ffffff;
            overflow-x: hidden;
        }

        html {
            scroll-behavior: smooth;
        }

        /* Header */
        .header {
            background: #ffffff;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            padding: 1rem 0;
            transition: all 0.3s ease;
        }

        .header.dark {
            background: #1f2937;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 2rem;
        }

        .logo-section {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: bold;
            color: #2c3e50;
            transition: color 0.3s ease;
        }

        .logo.dark {
            color: #f9fafb;
        }

        .logo-subtitle {
            font-size: 0.875rem;
            color: #6b7280;
            font-weight: 500;
            transition: color 0.3s ease;
        }

        .logo-subtitle.dark {
            color: #9ca3af;
        }

        .header-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .font-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn:hover {
            background: #2980b9;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: #95a5a6;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
        }

        .theme-toggle {
            background: #f8f9fa;
            color: #495057;
            border: 1px solid #dee2e6;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            box-shadow: none;
        }

        .theme-toggle:hover {
            background: #e9ecef;
            border-color: #adb5bd;
            transform: none;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .theme-toggle.dark {
            background: #343a40;
            color: #f8f9fa;
            border-color: #495057;
        }

        .theme-toggle.dark:hover {
            background: #495057;
            border-color: #6c757d;
        }

        /* Main Layout */
        .main-container {
            display: flex;
            max-width: 1200px;
            margin: 0 auto;
            margin-top: 80px;
            min-height: calc(100vh - 80px);
        }

        /* Sidebar */
        .sidebar {
            width: 250px;
            background: #f8f9fa;
            border-right: 1px solid #e9ecef;
            padding: 1.5rem 1rem;
            position: fixed;
            left: 0;
            top: 80px;
            height: calc(100vh - 80px);
            overflow-y: auto;
            transition: transform 0.3s ease;
        }

        .sidebar h3 {
            font-size: 1rem;
            margin-bottom: 1rem;
            color: #2c3e50;
            font-weight: 600;
        }

        .sidebar.hidden {
            transform: translateX(-100%);
        }

        .sidebar-toggle {
            display: none;
            position: fixed;
            top: 100px;
            left: 20px;
            z-index: 1001;
            background: #3498db;
            color: white;
            border: none;
            padding: 0.5rem;
            border-radius: 5px;
            cursor: pointer;
        }

        .chapter-list {
            list-style: none;
        }

        .chapter-item {
            margin-bottom: 0.25rem;
        }

        .chapter-link {
            display: block;
            padding: 0.5rem 0.75rem;
            color: #2c3e50;
            text-decoration: none;
            border-radius: 3px;
            transition: background 0.3s;
            font-size: 0.9rem;
            line-height: 1.3;
        }

        .chapter-link:hover,
        .chapter-link.active {
            background: #3498db;
            color: white;
        }

        /* Content Area */
        .content {
            flex: 1;
            margin-left: 250px;
            padding: 2rem;
            background: white;
        }

        .content-header {
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid #e9ecef;
        }

        .chapter-title {
            font-size: 2rem;
            color: #2c3e50;
            margin-bottom: 0.5rem;
        }

        .chapter-meta {
            color: #7f8c8d;
            font-size: 0.9rem;
        }

        .content-body {
            font-size: 1.1rem;
            line-height: 1.8;
            max-width: 800px;
            margin: 0 auto;
        }

        .content-body h1,
        .content-body h2,
        .content-body h3 {
            color: #2c3e50;
            margin: 2rem 0 1rem 0;
        }

        .content-body h1 {
            font-size: 1.8rem;
        }

        .content-body h2 {
            font-size: 1.5rem;
        }

        .content-body h3 {
            font-size: 1.3rem;
        }

        .content-body p {
            margin-bottom: 1.5rem;
            text-align: justify;
        }

        .content-body blockquote {
            border-left: 4px solid #3498db;
            padding-left: 1.5rem;
            margin: 2rem 0;
            font-style: italic;
            color: #555;
        }

        .content-body ul,
        .content-body ol {
            margin: 1rem 0 1rem 2rem;
        }

        .content-body li {
            margin-bottom: 0.5rem;
        }

        .content-body pre {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .content-body code {
            background: #f8f9fa;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            color: #e74c3c;
        }

        .content-body pre code {
            background: none;
            padding: 0;
            color: #2c3e50;
        }

        .content-body a {
            color: #3498db;
            text-decoration: none;
        }

        .content-body a:hover {
            text-decoration: underline;
        }

        /* Navigation */
        .navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid #e9ecef;
        }

        .nav-btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 1rem 2rem;
            border-radius: 5px;
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
            transition: background 0.3s;
        }

        .nav-btn:hover {
            background: #2980b9;
        }

        .nav-btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }

        /* Progress Bar */
        .progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            width: 0%;
            height: 3px;
            background: #3498db;
            z-index: 1001;
            transition: width 0.3s ease;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .sidebar {
                transform: translateX(-100%);
            }

            .sidebar.show {
                transform: translateX(0);
            }

            .sidebar-toggle {
                display: block;
            }

            .content {
                margin-left: 0;
                padding: 1rem;
            }

            .header-content {
                padding: 0 1rem;
            }

            .chapter-title {
                font-size: 1.5rem;
            }

            .content-body {
                font-size: 1rem;
            }

            .navigation {
                flex-direction: column;
                gap: 1rem;
            }

            .nav-btn {
                text-align: center;
            }
        }

        /* Dark Mode Support */
        body.dark-mode {
            background-color: #111827;
            color: #f9fafb;
        }

        body.dark-mode .header {
            background: #1f2937;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        body.dark-mode .sidebar {
            background: #1f2937;
            border-right-color: #374151;
        }

        body.dark-mode .content {
            background: #111827;
        }

        body.dark-mode .content-header {
            border-bottom-color: #374151;
        }

        body.dark-mode .chapter-title {
            color: #f9fafb;
        }

        body.dark-mode .content-body h1,
        body.dark-mode .content-body h2,
        body.dark-mode .content-body h3 {
            color: #f9fafb;
        }

        body.dark-mode .navigation {
            border-top-color: #374151;
        }

        body.dark-mode .chapter-link {
            color: #d1d5db;
        }

        body.dark-mode .chapter-link:hover,
        body.dark-mode .chapter-link.active {
            background: #3b82f6;
            color: white;
        }

        body.dark-mode .content-body {
            color: #e5e7eb;
        }

        body.dark-mode .content-body blockquote {
            border-left-color: #3b82f6;
            color: #d1d5db;
        }

        body.dark-mode .content-body pre {
            background: #1f2937;
            border-color: #374151;
            color: #f9fafb;
        }

        body.dark-mode .content-body code {
            background: #1f2937;
            color: #fbbf24;
        }

        body.dark-mode .content-body pre code {
            background: none;
            color: #f9fafb;
        }

        body.dark-mode .content-body a {
            color: #60a5fa;
        }

        body.dark-mode .nav-btn {
            background: #3b82f6;
        }

        body.dark-mode .nav-btn:hover {
            background: #2563eb;
        }

        body.dark-mode .nav-btn:disabled {
            background: #6b7280;
        }

        /* Print Styles */
        @media print {
            .header,
            .sidebar,
            .navigation,
            .sidebar-toggle {
                display: none;
            }

            .content {
                margin-left: 0;
                padding: 0;
            }

            .content-body {
                font-size: 12pt;
                line-height: 1.5;
            }
        }
    </style>
</head>
<body>
    <!-- Progress Bar -->
    <div class="progress-bar" id="progressBar"></div>

    <!-- Header -->
    <header class="header" id="header">
        <div class="header-content">
            <div class="logo-section">
                <div class="logo" id="logo">Golang From Hero To Hero</div>
                <div class="logo-subtitle" id="logoSubtitle">Membangun API Mini Toko Online</div>
            </div>
            <div class="header-controls">
                <div class="font-controls">
                    <button class="btn btn-secondary" onclick="decreaseFont()">
                        <span>A-</span>
                    </button>
                    <span id="fontSize" class="text-sm font-medium">16px</span>
                    <button class="btn btn-secondary" onclick="increaseFont()">
                        <span>A+</span>
                    </button>
                </div>
                <button class="theme-toggle" id="themeToggle" onclick="toggleDarkMode()">
                    <span id="themeIcon">🌙</span>
                    <span id="themeText">Dark</span>
                </button>
            </div>
        </div>
    </header>

    <!-- Sidebar Toggle -->
    <button class="sidebar-toggle" onclick="toggleSidebar()">☰</button>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Sidebar -->
        <nav class="sidebar" id="sidebar">
            <h3>Daftar Isi</h3>
            <ul class="chapter-list" id="chapterList">
                <!-- Chapters will be populated by JavaScript -->
            </ul>
        </nav>

        <!-- Content Area -->
        <main class="content" id="contentArea">
            <!-- Content will be populated by JavaScript -->
        </main>
    </div>

    <script>
        // Chapter data structure - Easy to add new chapters
        const chapters = [
            {
                id: 'chapter1',
                title: 'Bab 1: Pengenalan',
                meta: 'Halaman 1 dari 50 • Dibaca 8 menit',
                content: `
                    <h2>Selamat Datang di Tutorial API Mini Toko Online dengan Go</h2>
                    <p>Dalam tutorial ini, kita akan belajar membuat API mini toko online menggunakan bahasa pemrograman Go. Go adalah bahasa pemrograman yang dikembangkan oleh Google yang terkenal dengan performa tinggi, kesederhanaan, dan kemudahan dalam pengembangan aplikasi web.</p>

                    <h3>Apa yang Akan Kita Pelajari?</h3>
                    <p>Sepanjang tutorial ini, kita akan membangun API toko online yang lengkap dengan fitur-fitur berikut:</p>

                    <ul>
                        <li><strong>Setup Project:</strong> Inisialisasi project dengan Go modules</li>
                        <li><strong>HTTP Server:</strong> Membuat server HTTP dengan Go standard library</li>
                        <li><strong>API Endpoints:</strong> Endpoint untuk CRUD operations (Create, Read, Update, Delete)</li>
                        <li><strong>Database Integration:</strong> Koneksi dan operasi database</li>
                        <li><strong>Middleware:</strong> Authentication, logging, dan error handling</li>
                        <li><strong>Testing:</strong> Unit testing dan integration testing</li>
                        <li><strong>Deployment:</strong> Cara deploy aplikasi ke production</li>
                    </ul>

                    <h3>Prasyarat</h3>
                    <p>Sebelum memulai, pastikan Anda telah menginstall:</p>

                    <ul>
                        <li><strong>Go 1.19+</strong> - Download dari <a href="https://golang.org/dl/" target="_blank">golang.org</a></li>
                        <li><strong>Git</strong> - Untuk version control</li>
                        <li><strong>Text Editor/IDE</strong> - VS Code, GoLand, atau editor favorit Anda</li>
                        <li><strong>Postman/Insomnia</strong> - Untuk testing API (opsional)</li>
                    </ul>

                    <h3>Tutorial Pertama: Install Go Modules</h3>
                    <p>Langkah pertama dalam membuat API mini toko online adalah menginisialisasi project dengan Go modules. Go modules adalah sistem manajemen dependensi resmi untuk Go yang memungkinkan kita mengelola package dan versi dengan mudah.</p>

                    <h4>Langkah 1: Buat Direktori Project</h4>
                    <p>Buat direktori baru untuk project kita:</p>

                    <pre><code>mkdir tokogo
cd tokogo</code></pre>

                    <h4>Langkah 2: Inisialisasi Go Module</h4>
                    <p>Jalankan perintah berikut untuk menginisialisasi Go module:</p>

                    <pre><code>go mod init tokogo</code></pre>

                    <p>Perintah ini akan membuat file <code>go.mod</code> di direktori project. File ini berisi informasi tentang module kita, termasuk nama module dan versi Go yang digunakan.</p>

                    <h4>Struktur File go.mod</h4>
                    <p>Setelah menjalankan perintah di atas, Anda akan melihat file <code>go.mod</code> dengan isi seperti ini:</p>

                    <pre><code>module tokogo

go 1.25.1</code></pre>

                    <p>File ini menunjukkan bahwa:</p>
                    <ul>
                        <li>Nama module kita adalah <code>tokogo</code></li>
                        <li>Kita menggunakan Go versi 1.25.1</li>
                    </ul>

                    <h4>Langkah 3: Verifikasi Setup</h4>
                    <p>Untuk memastikan setup berhasil, jalankan perintah berikut:</p>

                    <pre><code>go version</code></pre>

                    <p>Anda seharusnya melihat output yang menunjukkan versi Go yang terinstall.</p>

                    <blockquote>
                        <strong>Tips:</strong> Go modules memungkinkan kita untuk mengelola dependensi dengan mudah. Ketika kita mengimport package dari repository lain, Go akan otomatis menambahkannya ke file go.mod dan membuat file go.sum untuk verifikasi checksum.
                    </blockquote>

                    <h3>Langkah Selanjutnya</h3>
                    <p>Sekarang kita telah berhasil menginisialisasi project dengan Go modules. Di bab selanjutnya, kita akan belajar tentang struktur project yang baik dan mulai membangun HTTP server pertama kita.</p>

                    <p>Pastikan Anda telah memahami konsep Go modules sebelum melanjutkan ke bab berikutnya, karena ini adalah fondasi penting untuk pengembangan aplikasi Go modern.</p>
                `
            },
            {
                id: 'chapter2',
                title: 'Bab 2: Install Dependency',
                meta: 'Halaman 2 dari 50 • Dibaca 6 menit',
                content: `
                    <h2>Menginstall Dependencies untuk API Toko Online</h2>
                    <p>Setelah berhasil menginisialisasi project dengan Go modules, langkah selanjutnya adalah menginstall dependencies (package) yang dibutuhkan untuk membangun API mini toko online. Dependencies ini akan membantu kita dalam berbagai aspek pengembangan, mulai dari HTTP server hingga database operations.</p>

                    <h3>Dependencies yang Akan Kita Install</h3>
                    <p>Berikut adalah daftar dependencies yang akan kita gunakan dalam project ini:</p>

                    <ul>
                        <li><strong>Gin Framework:</strong> HTTP web framework yang cepat dan ringan</li>
                        <li><strong>GORM:</strong> Object-Relational Mapping library untuk Go</li>
                        <li><strong>MySQL Driver:</strong> Driver untuk koneksi ke database MySQL</li>
                        <li><strong>CORS Middleware:</strong> Untuk menangani Cross-Origin Resource Sharing</li>
                        <li><strong>Godotenv:</strong> Untuk memuat environment variables dari file .env</li>
                        <li><strong>JWT:</strong> Untuk implementasi JSON Web Token authentication</li>
                    </ul>

                    <h3>Langkah-langkah Instalasi</h3>
                    <p>Jalankan perintah-perintah berikut satu per satu di terminal dalam direktori project <code>tokogo</code>:</p>

                    <h4>1. Install Gin Framework</h4>
                    <p>Gin adalah HTTP web framework yang sangat populer di Go karena performanya yang tinggi dan kemudahan penggunaannya.</p>
                    <pre><code>go get -u github.com/gin-gonic/gin</code></pre>

                    <h4>2. Install GORM</h4>
                    <p>GORM adalah ORM library yang powerful untuk Go, memudahkan kita dalam berinteraksi dengan database.</p>
                    <pre><code>go get -u gorm.io/gorm</code></pre>

                    <h4>3. Install MySQL Driver untuk GORM</h4>
                    <p>Driver ini diperlukan untuk koneksi ke database MySQL.</p>
                    <pre><code>go get -u gorm.io/driver/mysql</code></pre>

                    <h4>4. Install CORS Middleware</h4>
                    <p>CORS middleware diperlukan untuk menangani request dari frontend yang berbeda domain.</p>
                    <pre><code>go get -u github.com/gin-contrib/cors</code></pre>

                    <h4>5. Install Godotenv</h4>
                    <p>Godotenv membantu kita memuat environment variables dari file .env untuk konfigurasi aplikasi.</p>
                    <pre><code>go get -u github.com/joho/godotenv</code></pre>

                    <h4>6. Install JWT Library</h4>
                    <p>JWT library untuk implementasi authentication dan authorization.</p>
                    <pre><code>go get github.com/golang-jwt/jwt</code></pre>

                    <h4>7. Install Validator Library</h4>
                    <p>Validator library untuk validasi input data dengan binding tags.</p>
                    <pre><code>go get github.com/go-playground/validator/v10@v10.26.0</code></pre>

                    <h3>Verifikasi Instalasi</h3>
                    <p>Setelah menjalankan semua perintah di atas, periksa file <code>go.mod</code> untuk memastikan semua dependencies telah terinstall:</p>

                    <pre><code>cat go.mod</code></pre>

                    <p>File <code>go.mod</code> Anda seharusnya terlihat seperti ini:</p>

                    <pre><code>module tokogo

go 1.25.1

require (
    github.com/gin-contrib/cors v1.4.0
    github.com/gin-gonic/gin v1.9.1
    github.com/go-playground/validator/v10 v10.26.0
    github.com/golang-jwt/jwt v3.2.2+incompatible
    github.com/joho/godotenv v1.4.0
    gorm.io/driver/mysql v1.5.1
    gorm.io/gorm v1.25.2
)</code></pre>

                    <h3>Penjelasan Setiap Dependency</h3>

                    <h4>🔧 Gin Framework</h4>
                    <p><strong>Fungsi:</strong> HTTP web framework yang menyediakan routing, middleware, dan fitur-fitur web development lainnya.</p>
                    <p><strong>Keunggulan:</strong> Performa tinggi, sintaks yang sederhana, dan ekosistem yang luas.</p>

                    <h4>🗄️ GORM</h4>
                    <p><strong>Fungsi:</strong> Object-Relational Mapping yang memudahkan operasi database dengan sintaks Go yang natural.</p>
                    <p><strong>Keunggulan:</strong> Auto-migration, associations, hooks, dan dukungan untuk berbagai database.</p>

                    <h4>🐬 MySQL Driver</h4>
                    <p><strong>Fungsi:</strong> Driver resmi untuk koneksi ke database MySQL melalui GORM.</p>
                    <p><strong>Keunggulan:</strong> Optimized untuk performa dan kompatibilitas dengan MySQL.</p>

                    <h4>🌐 CORS Middleware</h4>
                    <p><strong>Fungsi:</strong> Menangani Cross-Origin Resource Sharing untuk komunikasi dengan frontend.</p>
                    <p><strong>Keunggulan:</strong> Konfigurasi yang fleksibel dan mudah digunakan.</p>

                    <h4>⚙️ Godotenv</h4>
                    <p><strong>Fungsi:</strong> Memuat environment variables dari file .env untuk konfigurasi aplikasi.</p>
                    <p><strong>Keunggulan:</strong> Memisahkan konfigurasi dari kode, meningkatkan keamanan.</p>

                    <h4>🔐 JWT Library</h4>
                    <p><strong>Fungsi:</strong> Implementasi JSON Web Token untuk authentication dan authorization.</p>
                    <p><strong>Keunggulan:</strong> Stateless authentication, aman, dan mudah diimplementasikan.</p>

                    <h4>✅ Validator Library</h4>
                    <p><strong>Fungsi:</strong> Library untuk validasi input data dengan binding tags yang powerful.</p>
                    <p><strong>Keunggulan:</strong> Validasi otomatis, fleksibel, dan terintegrasi dengan Gin framework.</p>

                    <blockquote>
                        <strong>Tips:</strong> Gunakan flag <code>-u</code> pada perintah <code>go get</code> untuk mengupdate ke versi terbaru dari dependencies yang sudah ada. Ini memastikan kita menggunakan versi yang paling up-to-date dan aman.
                    </blockquote>

                    <h3>File go.sum</h3>
                    <p>Setelah instalasi, Go akan otomatis membuat file <code>go.sum</code> yang berisi checksum untuk verifikasi integritas dependencies. File ini penting untuk memastikan konsistensi dependencies di berbagai environment.</p>

                    <h3>Langkah Selanjutnya</h3>
                    <p>Sekarang kita telah berhasil menginstall semua dependencies yang dibutuhkan. Di bab selanjutnya, kita akan belajar tentang struktur project yang baik dan mulai membuat file-file dasar untuk aplikasi kita.</p>

                    <p>Pastikan semua dependencies terinstall dengan benar sebelum melanjutkan ke bab berikutnya, karena kita akan menggunakan semua package ini dalam pengembangan API.</p>
                `
            },
            {
                id: 'chapter3',
                title: 'Bab 3: Struktur Folder',
                meta: 'Halaman 3 dari 50 • Dibaca 7 menit',
                content: `
                    <h2>Struktur Folder Project API Toko Online</h2>
                    <p>Setelah berhasil menginstall dependencies, langkah selanjutnya adalah membuat struktur folder yang baik dan terorganisir. Struktur folder yang rapi akan memudahkan pengembangan, maintenance, dan kolaborasi dalam tim.</p>

                    <h3>Struktur Folder yang Akan Kita Buat</h3>
                    <p>Berikut adalah struktur folder yang akan kita gunakan untuk project API mini toko online. <strong>File-file yang ditampilkan hanya sebagai contoh dan gambaran</strong> - yang penting adalah memahami struktur foldernya saja:</p>

                    <pre><code>tokogo/
├── config/
│   └── config.go
├── handlers/
│   ├── auth.go
│   ├── product.go
│   └── user.go
├── helpers/
│   ├── jwt.go
│   ├── response.go
│   └── validator.go
├── middlewares/
│   ├── auth.go
│   ├── cors.go
│   └── logger.go
├── models/
│   ├── product.go
│   └── user.go
├── repositories/
│   ├── product.go
│   └── user.go
├── requests/
│   ├── auth_request.go
│   ├── product_request.go
│   └── user_request.go
├── responses/
│   ├── auth_response.go
│   ├── product_response.go
│   └── user_response.go
├── services/
│   ├── auth.go
│   ├── product.go
│   └── user.go
├── main.go
├── .env
├── .gitignore
├── go.mod
├── go.sum
└── README.md</code></pre>

                    <h3>Penjelasan Setiap Folder</h3>
                    <p><em>Catatan: Nama file yang disebutkan di bawah ini hanya sebagai contoh. Yang penting adalah memahami fungsi setiap folder.</em></p>

                    <h4>📁 config/</h4>
                    <p><strong>Fungsi:</strong> Berisi konfigurasi aplikasi dan environment variables</p>
                    <p><strong>Contoh file:</strong> <code>config.go</code> - Load dan manage konfigurasi dari .env</p>

                    <h4>📁 handlers/</h4>
                    <p><strong>Fungsi:</strong> HTTP handlers (controllers) yang menangani request dari client</p>
                    <p><strong>Contoh file:</strong></p>
                    <ul>
                        <li><code>auth.go</code> - Handler untuk authentication (login, register)</li>
                        <li><code>product.go</code> - Handler untuk CRUD produk</li>
                        <li><code>user.go</code> - Handler untuk manajemen user</li>
                    </ul>

                    <h4>📁 helpers/</h4>
                    <p><strong>Fungsi:</strong> Utility functions dan helper yang bisa digunakan di seluruh aplikasi</p>
                    <p><strong>Contoh file:</strong></p>
                    <ul>
                        <li><code>jwt.go</code> - JWT token generation dan validation</li>
                        <li><code>response.go</code> - Standard response format</li>
                        <li><code>validator.go</code> - Custom validation functions</li>
                    </ul>

                    <h4>📁 middlewares/</h4>
                    <p><strong>Fungsi:</strong> Middleware functions untuk intercept request/response</p>
                    <p><strong>Contoh file:</strong></p>
                    <ul>
                        <li><code>auth.go</code> - Authentication middleware</li>
                        <li><code>cors.go</code> - CORS configuration</li>
                        <li><code>logger.go</code> - Request logging</li>
                    </ul>

                    <h4>📁 models/</h4>
                    <p><strong>Fungsi:</strong> Data models/structs yang merepresentasikan database tables</p>
                    <p><strong>Contoh file:</strong></p>
                    <ul>
                        <li><code>product.go</code> - Product model struct</li>
                        <li><code>user.go</code> - User model struct</li>
                    </ul>

                    <h4>📁 repositories/</h4>
                    <p><strong>Fungsi:</strong> Data access layer untuk berinteraksi dengan database</p>
                    <p><strong>Contoh file:</strong></p>
                    <ul>
                        <li><code>product.go</code> - Product database operations</li>
                        <li><code>user.go</code> - User database operations</li>
                    </ul>

                    <h4>📁 requests/</h4>
                    <p><strong>Fungsi:</strong> Request structs untuk validasi input dari client</p>
                    <p><strong>Contoh file:</strong></p>
                    <ul>
                        <li><code>auth_request.go</code> - Login/Register request structs</li>
                        <li><code>product_request.go</code> - Product CRUD request structs</li>
                        <li><code>user_request.go</code> - User management request structs</li>
                    </ul>

                    <h4>📁 responses/</h4>
                    <p><strong>Fungsi:</strong> Response structs untuk format output yang konsisten</p>
                    <p><strong>Contoh file:</strong></p>
                    <ul>
                        <li><code>auth_response.go</code> - Authentication response structs</li>
                        <li><code>product_response.go</code> - Product response structs</li>
                        <li><code>user_response.go</code> - User response structs</li>
                    </ul>

                    <h4>📁 services/</h4>
                    <p><strong>Fungsi:</strong> Business logic layer yang mengatur alur aplikasi</p>
                    <p><strong>Contoh file:</strong></p>
                    <ul>
                        <li><code>auth.go</code> - Authentication business logic</li>
                        <li><code>product.go</code> - Product business logic</li>
                        <li><code>user.go</code> - User business logic</li>
                    </ul>

                    <h4>📄 main.go</h4>
                    <p><strong>Fungsi:</strong> Entry point aplikasi yang menjalankan HTTP server</p>
                    <p><strong>Isi:</strong> Server setup, route configuration, dan middleware setup</p>

                    <h3>Langkah-langkah Membuat Struktur Folder</h3>

                    <h4>1. Buat Folder Utama</h4>
                    <p>Pastikan Anda sudah berada di direktori project <code>tokogo</code>:</p>
                    <pre><code>pwd
# Output: /path/to/your/project/tokogo</code></pre>

                    <h4>2. Buat Struktur Folder</h4>
                    <p>Jalankan perintah berikut untuk membuat semua folder sekaligus:</p>
                    <pre><code>mkdir -p config
mkdir -p handlers
mkdir -p helpers
mkdir -p middlewares
mkdir -p models
mkdir -p repositories
mkdir -p requests
mkdir -p responses
mkdir -p services</code></pre>

                    <h4>3. Verifikasi Struktur</h4>
                    <p>Gunakan command <code>tree</code> untuk melihat struktur folder:</p>
                    <pre><code>tree -d</code></pre>

                    <p>Jika <code>tree</code> tidak tersedia, gunakan:</p>
                    <pre><code>find . -type d | sort</code></pre>

                    <h3>File-file Konfigurasi</h3>

                    <h4>.env</h4>
                    <p>File untuk menyimpan environment variables:</p>
                    <pre><code># Database Configuration
DB_HOST=localhost
DB_PORT=3306
DB_USER=root
DB_PASSWORD=password
DB_NAME=tokogo

# Server Configuration
SERVER_PORT=8080
JWT_SECRET=your-secret-key

# Environment
ENV=development</code></pre>

                    <h4>.gitignore</h4>
                    <p>File untuk mengabaikan file tertentu dari Git:</p>
                    <pre><code># Binaries for programs and plugins
*.exe
*.exe~
*.dll
*.so
*.dylib

# Test binary, built with \`go test -c\`
*.test

# Output of the go coverage tool
*.out

# Dependency directories
vendor/

# Go workspace file
go.work

# Environment variables
.env
.env.local

# IDE files
.vscode/
.idea/
*.swp
*.swo

# OS generated files
.DS_Store
Thumbs.db</code></pre>

                    <h3>Arsitektur Pattern yang Digunakan</h3>

                    <h4>🏗️ Layered Architecture</h4>
                    <p>Struktur ini mengikuti prinsip Layered Architecture dengan pemisahan layer yang jelas:</p>
                    <ul>
                        <li><strong>Handlers:</strong> Layer presentasi (HTTP requests/responses)</li>
                        <li><strong>Services:</strong> Layer business logic</li>
                        <li><strong>Repositories:</strong> Layer data access</li>
                        <li><strong>Models:</strong> Data structures</li>
                        <li><strong>Requests/Responses:</strong> Data transfer objects</li>
                        <li><strong>Helpers:</strong> Utility functions</li>
                        <li><strong>Middlewares:</strong> Cross-cutting concerns</li>
                    </ul>

                    <h4>🔄 Dependency Flow</h4>
                    <p>Alur dependency mengalir dari luar ke dalam:</p>
                    <pre><code>Handlers → Services → Repositories → Database
    ↓         ↓         ↓
Requests  Responses  Models</code></pre>

                    <h4>📋 Request/Response Pattern</h4>
                    <p>Struktur ini menggunakan pattern Request/Response yang memisahkan:</p>
                    <ul>
                        <li><strong>Requests:</strong> Input validation dan data binding</li>
                        <li><strong>Responses:</strong> Output formatting dan serialization</li>
                        <li><strong>Models:</strong> Database entities</li>
                    </ul>

                    <blockquote>
                        <strong>Tips:</strong> Struktur folder ini mengikuti standar Go project layout yang direkomendasikan oleh komunitas Go. Ini akan memudahkan developer lain untuk memahami dan berkontribusi pada project.
                    </blockquote>

                    <h3>Langkah Selanjutnya</h3>
                    <p>Sekarang kita telah berhasil membuat struktur folder yang rapi dan terorganisir. Di bab selanjutnya, kita akan mulai membuat file-file dasar dan mengimplementasikan HTTP server pertama kita menggunakan Gin framework.</p>

                    <p><strong>Catatan Penting:</strong> File-file yang akan kita buat di bab selanjutnya mungkin memiliki nama atau struktur yang berbeda dengan contoh di atas. Yang penting adalah memahami konsep dan fungsi setiap folder. Struktur folder yang kita buat ini akan menjadi fondasi untuk pengembangan selanjutnya.</p>
                `
            },
            {
                id: 'chapter4',
                title: 'Bab 4: Konfigurasi Kode',
                meta: 'Halaman 4 dari 50 • Dibaca 8 menit',
                content: `
                    <h2>Konfigurasi Kode dan Environment Variables</h2>
                    <p>Setelah membuat struktur folder, langkah selanjutnya adalah membuat file-file konfigurasi yang akan mengatur environment variables dan koneksi database. Konfigurasi yang baik akan memudahkan deployment dan maintenance aplikasi.</p>

                    <h3>Langkah-langkah yang Akan Kita Lakukan</h3>
                    <p>Sebelum membuat file konfigurasi, kita perlu memastikan database MySQL sudah siap. Berikut urutan yang akan kita lakukan:</p>
                    <ol>
                        <li><strong>Setup Database MySQL</strong> - Membuat database dan user</li>
                        <li><strong>File .env</strong> - Environment variables</li>
                        <li><strong>config/env.go</strong> - Helper function untuk membaca environment variables</li>
                        <li><strong>config/database.go</strong> - Konfigurasi koneksi database</li>
                    </ol>

                    <h3>1. Setup Database MySQL</h3>
                    <p>Sebelum membuat konfigurasi, kita perlu memastikan database MySQL sudah berjalan dan database 'tokogo' sudah dibuat. Ada 2 cara yang bisa digunakan:</p>

                    <h4>🔧 Cara 1: Menggunakan Command Line (CMD/Terminal)</h4>
                    <p>Jika Anda sudah familiar dengan command line, cara ini lebih cepat:</p>

                    <h5>Langkah 1: Buka MySQL Command Line</h5>
                    <p>Buka Command Prompt atau Terminal, lalu login ke MySQL:</p>
                    <pre><code>mysql -u root -p</code></pre>
                    <p>Masukkan password MySQL Anda (jika ada). Jika tidak ada password, langsung tekan Enter.</p>

                    <h5>Langkah 2: Buat Database</h5>
                    <p>Setelah berhasil login, buat database 'tokogo':</p>
                    <pre><code>CREATE DATABASE tokogo;</code></pre>

                    <h5>Langkah 3: Verifikasi Database</h5>
                    <p>Pastikan database berhasil dibuat:</p>
                    <pre><code>SHOW DATABASES;</code></pre>
                    <p>Anda seharusnya melihat 'tokogo' dalam daftar database.</p>

                    <h5>Langkah 4: Keluar dari MySQL</h5>
                    <pre><code>EXIT;</code></pre>

                    <h4>🌐 Cara 2: Menggunakan phpMyAdmin (Lebih Mudah untuk Pemula)</h4>
                    <p>Jika Anda menggunakan XAMPP, WAMP, atau Laragon, cara ini lebih mudah:</p>

                    <h5>Langkah 1: Buka phpMyAdmin</h5>
                    <p>Buka browser dan akses: <code>http://localhost/phpmyadmin</code></p>

                    <h5>Langkah 2: Buat Database Baru</h5>
                    <p>Klik tab "Databases" di bagian atas, lalu:</p>
                    <ol>
                        <li>Masukkan nama database: <code>tokogo</code></li>
                        <li>Pilih Collation: <code>utf8mb4_unicode_ci</code> (opsional)</li>
                        <li>Klik tombol "Create"</li>
                    </ol>

                    <h5>Langkah 3: Verifikasi</h5>
                    <p>Database 'tokogo' akan muncul di sidebar kiri, klik untuk memastikan database kosong dan siap digunakan.</p>

                    <h4>⚠️ Troubleshooting</h4>
                    <p>Jika mengalami masalah:</p>
                    <ul>
                        <li><strong>MySQL tidak berjalan:</strong> Pastikan XAMPP/WAMP/Laragon sudah di-start</li>
                        <li><strong>Access denied:</strong> Coba tanpa password atau reset password MySQL</li>
                        <li><strong>Database sudah ada:</strong> Tidak masalah, bisa langsung digunakan</li>
                    </ul>

                    <blockquote>
                        <strong>Tips untuk Pemula:</strong> Jika Anda baru belajar, gunakan phpMyAdmin karena lebih visual dan mudah. Command line bisa dipelajari nanti setelah familiar dengan database.
                    </blockquote>

                    <h3>2. Membuat File .env</h3>
                    <p>File .env berisi environment variables yang akan digunakan oleh aplikasi. Buat file ini di root directory project:</p>

                    <pre><code># Database Configuration
DB_HOST=localhost
DB_PORT=3306
DB_USER=root
DB_PASSWORD=
DB_NAME=tokogo

# Server Configuration
SERVER_PORT=8080
JWT_SECRET=your-super-secret-jwt-key-here

# Environment
ENV=development</code></pre>

                    <h4>Penjelasan Environment Variables:</h4>
                    <ul>
                        <li><strong>DB_HOST:</strong> Host database (localhost untuk development)</li>
                        <li><strong>DB_PORT:</strong> Port database MySQL (default 3306)</li>
                        <li><strong>DB_USER:</strong> Username database</li>
                        <li><strong>DB_PASSWORD:</strong> Password database (kosong jika tidak ada)</li>
                        <li><strong>DB_NAME:</strong> Nama database yang akan digunakan</li>
                        <li><strong>SERVER_PORT:</strong> Port untuk HTTP server</li>
                        <li><strong>JWT_SECRET:</strong> Secret key untuk JWT token (ganti dengan key yang aman)</li>
                        <li><strong>ENV:</strong> Environment aplikasi (development/production)</li>
                    </ul>

                    <h3>3. Membuat File config/env.go</h3>
                    <p>File ini berisi helper function untuk membaca environment variables dengan default value:</p>

                    <pre><code>package config

import "os"

func GetEnv(key, defaultVal string) string {
    if value, exists := os.LookupEnv(key); exists && value != "" {
        return value
    }
    return defaultVal
}</code></pre>

                    <h4>Penjelasan Function GetEnv:</h4>
                    <ul>
                        <li><strong>Parameter key:</strong> Nama environment variable</li>
                        <li><strong>Parameter defaultVal:</strong> Nilai default jika environment variable tidak ditemukan</li>
                        <li><strong>Return:</strong> Nilai environment variable atau default value</li>
                    </ul>

                    <h3>4. Membuat File config/database.go</h3>
                    <p>File ini berisi konfigurasi koneksi database menggunakan GORM:</p>

                    <pre><code>package config

import (
    "fmt"
    "time"

    "tokogo/models"

    "gorm.io/driver/mysql"
    "gorm.io/gorm"
    "gorm.io/gorm/schema"
)

var DB *gorm.DB

func InitDB() {
    // Ambil konfigurasi database dari environment variables
    dbUser := GetEnv("DB_USER", "root")
    dbPassword := GetEnv("DB_PASSWORD", "")
    dbHost := GetEnv("DB_HOST", "localhost")
    dbPort := GetEnv("DB_PORT", "3306")
    dbName := GetEnv("DB_NAME", "tokogo")

    // Buat DSN (Data Source Name) untuk koneksi MySQL
    dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local",
        dbUser, dbPassword, dbHost, dbPort, dbName)

    var err error

    // Buka koneksi database menggunakan GORM
    DB, err = gorm.Open(mysql.Open(dsn), &gorm.Config{
        NamingStrategy: schema.NamingStrategy{
            SingularTable: true, // Gunakan nama table singular
        },
    })
    if err != nil {
        panic(fmt.Sprintf("Failed to connect to database: %v", err))
    }

    // Konfigurasi connection pool
    sqlDB, err := DB.DB()
    if err != nil {
        panic("Failed to get database instance!")
    }

    // Set connection pool settings
    sqlDB.SetMaxOpenConns(10)    // Maksimal 10 koneksi terbuka
    sqlDB.SetMaxIdleConns(5)     // Maksimal 5 koneksi idle
    sqlDB.SetConnMaxLifetime(time.Hour) // Maksimal 1 jam lifetime

    // Auto migrate model User (akan kita buat di bab selanjutnya)
    if err := DB.AutoMigrate(&models.User{}); err != nil {
        panic(fmt.Sprintf("AutoMigrate failed: %v", err))
    }
}</code></pre>

                    <h4>Penjelasan Konfigurasi Database:</h4>
                    <ul>
                        <li><strong>DSN:</strong> Data Source Name untuk koneksi MySQL</li>
                        <li><strong>SingularTable:</strong> Menggunakan nama table singular (user bukan users)</li>
                        <li><strong>Connection Pool:</strong> Mengatur jumlah koneksi maksimal</li>
                        <li><strong>AutoMigrate:</strong> Otomatis membuat/update table berdasarkan model</li>
                    </ul>

                    <h3>5. Membuat File .gitignore</h3>
                    <p>Pastikan file .env tidak di-commit ke Git untuk keamanan:</p>

                    <pre><code># Environment variables
.env
.env.local
.env.production

# Binaries
*.exe
*.exe~
*.dll
*.so
*.dylib

# Test binary
*.test

# Go workspace file
go.work

# IDE files
.vscode/
.idea/
*.swp
*.swo

# OS generated files
.DS_Store
Thumbs.db</code></pre>

                    <h3>6. Load Environment Variables di main.go</h3>
                    <p>Untuk menggunakan godotenv, kita perlu memuat file .env di awal aplikasi:</p>

                    <pre><code>package main

import (
    "log"

    "github.com/joho/godotenv"
    "tokogo/config"
)

func main() {
    // Load environment variables dari file .env
    if err := godotenv.Load(); err != nil {
        log.Println("No .env file found, using system environment variables")
    }

    // Initialize database connection
    config.InitDB()
    
    // Rest of your application code...
}</code></pre>

                    <h3>Keunggulan Konfigurasi Ini</h3>

                    <h4>🔒 Keamanan</h4>
                    <ul>
                        <li>Environment variables tidak di-commit ke Git</li>
                        <li>Konfigurasi berbeda untuk development dan production</li>
                        <li>Secret keys tidak ter-expose di kode</li>
                    </ul>

                    <h4>⚙️ Fleksibilitas</h4>
                    <ul>
                        <li>Mudah mengubah konfigurasi tanpa mengubah kode</li>
                        <li>Default values untuk development</li>
                        <li>Support multiple environments</li>
                    </ul>

                    <h4>🚀 Deployment</h4>
                    <ul>
                        <li>Mudah deploy ke server dengan environment variables</li>
                        <li>Konfigurasi database yang optimal</li>
                        <li>Connection pooling untuk performa</li>
                    </ul>

                    <blockquote>
                        <strong>Tips:</strong> Selalu gunakan environment variables untuk konfigurasi yang sensitif seperti database credentials dan JWT secret. Jangan pernah hardcode nilai-nilai ini di kode.
                    </blockquote>

                    <h3>7. Verifikasi Setup Database</h3>
                    <p>Setelah membuat semua file konfigurasi, mari kita verifikasi bahwa setup database sudah benar:</p>

                    <h4>✅ Checklist Verifikasi:</h4>
                    <ul>
                        <li>✅ MySQL server sudah berjalan (XAMPP/WAMP/Laragon sudah di-start)</li>
                        <li>✅ Database 'tokogo' sudah dibuat</li>
                        <li>✅ File .env sudah dibuat dengan konfigurasi yang benar</li>
                        <li>✅ File config/env.go sudah dibuat</li>
                        <li>✅ File config/database.go sudah dibuat</li>
                        <li>✅ File .gitignore sudah dibuat</li>
                    </ul>

                    <h4>🧪 Test Koneksi Database (Opsional)</h4>
                    <p>Jika ingin memastikan koneksi database berfungsi, buat file test sederhana:</p>

                    <pre><code>package main

import (
    "fmt"
    "log"

    "github.com/joho/godotenv"
    "tokogo/config"
)

func main() {
    // Load environment variables
    if err := godotenv.Load(); err != nil {
        log.Println("No .env file found, using system environment variables")
    }

    // Test database connection
    fmt.Println("Testing database connection...")
    config.InitDB()
    fmt.Println("✅ Database connection successful!")
}</code></pre>

                    <p>Jalankan dengan: <code>go run main.go</code></p>

                    <h3>Langkah Selanjutnya</h3>
                    <p>Sekarang kita telah berhasil membuat konfigurasi dasar untuk aplikasi. Di bab selanjutnya, kita akan membuat model User dan mulai mengimplementasikan HTTP server dengan Gin framework.</p>

                    <p><strong>Catatan Penting:</strong> Pastikan semua checklist di atas sudah terpenuhi sebelum melanjutkan ke bab selanjutnya. Jika ada error saat test koneksi database, periksa kembali konfigurasi MySQL dan file .env Anda.</p>
                `
            },
            {
                id: 'chapter5',
                title: 'Bab 5: Relaksasi & Review',
                meta: 'Halaman 5 dari 50 • Dibaca 12 menit',
                content: `
                    <h2>Bab Relaksasi & Review Pembelajaran</h2>
                    <p>Selamat! Anda telah menyelesaikan 4 bab pertama dari tutorial API Mini Toko Online dengan Go. Sekarang saatnya untuk beristirahat sejenak dan mengulas kembali semua yang telah dipelajari. Bab ini dirancang untuk membantu otak Anda mengkonsolidasikan pengetahuan yang baru saja diperoleh.</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">🧠 Mengapa Review Penting?</h3>
                        <p style="color: #495057; margin-bottom: 0;">Penelitian menunjukkan bahwa mengulang materi dalam 24 jam pertama dapat meningkatkan retensi memori hingga 80%. Mari kita manfaatkan momen ini untuk memperkuat pemahaman Anda!</p>
                    </div>

                    <h3>Ringkasan Pembelajaran Bab 1-4</h3>
                    <p>Sebelum masuk ke pertanyaan review, mari kita ingat kembali perjalanan pembelajaran yang telah kita lalui:</p>

                    <h4>Bab 1: Pengenalan Go Modules</h4>
                    <ul>
                        <li>✅ Memahami konsep Go modules dan manajemen dependensi</li>
                        <li>✅ Inisialisasi project dengan <code>go mod init tokogo</code></li>
                        <li>✅ Struktur file <code>go.mod</code> dan <code>go.sum</code></li>
                        <li>✅ Prasyarat pengembangan Go (Go 1.19+, Git, IDE)</li>
                    </ul>

                    <h4>Bab 2: Install Dependencies</h4>
                    <ul>
                        <li>✅ Gin Framework untuk HTTP web framework</li>
                        <li>✅ GORM untuk Object-Relational Mapping</li>
                        <li>✅ MySQL Driver untuk koneksi database</li>
                        <li>✅ CORS Middleware untuk Cross-Origin Resource Sharing</li>
                        <li>✅ Godotenv untuk environment variables</li>
                        <li>✅ JWT Library untuk authentication</li>
                    </ul>

                    <h4>Bab 3: Struktur Folder</h4>
                    <ul>
                        <li>✅ Layered Architecture pattern</li>
                        <li>✅ Pemisahan concerns (handlers, services, repositories)</li>
                        <li>✅ Request/Response pattern</li>
                        <li>✅ Dependency flow yang jelas</li>
                        <li>✅ Struktur folder yang scalable</li>
                    </ul>

                    <h4>Bab 4: Konfigurasi Kode</h4>
                    <ul>
                        <li>✅ Setup database MySQL</li>
                        <li>✅ Environment variables dengan file .env</li>
                        <li>✅ Konfigurasi koneksi database dengan GORM</li>
                        <li>✅ Connection pooling untuk performa</li>
                        <li>✅ Auto-migration untuk database schema</li>
                    </ul>

                    <h3>Pertanyaan Review Interaktif</h3>
                    <p>Mari kita uji pemahaman Anda dengan pertanyaan-pertanyaan yang dirancang untuk mengaktifkan kembali memori dan memperkuat pembelajaran:</p>

                    <div style="background: #f8f9fa; border-left: 4px solid #3498db; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Bagian A: Konsep Dasar Go Modules</h4>
                        
                        <p><strong>1. Apa fungsi utama dari file go.mod dalam project Go?</strong></p>
                        <p style="color: #666; font-style: italic;">💡 Petunjuk: Pikirkan tentang manajemen dependensi dan versi...</p>
                        
                        <p><strong>2. Mengapa kita menggunakan flag -u pada perintah go get?</strong></p>
                        <p style="color: #666; font-style: italic;">💡 Petunjuk: Apa yang terjadi jika kita tidak menggunakan flag ini?</p>
                        
                        <p><strong>3. Apa perbedaan antara go.mod dan go.sum?</strong></p>
                        <p style="color: #666; font-style: italic;">💡 Petunjuk: Satu untuk metadata, satu untuk keamanan...</p>
                    </div>

                    <div style="background: #f8f9fa; border-left: 4px solid #e74c3c; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Bagian B: Dependencies & Framework</h4>
                        
                        <p><strong>4. Mengapa kita memilih Gin Framework dibanding HTTP server bawaan Go?</strong></p>
                        <p style="color: #666; font-style: italic;">💡 Petunjuk: Pikirkan tentang routing, middleware, dan kemudahan...</p>
                        
                        <p><strong>5. Apa keunggulan GORM dibanding menulis SQL query manual?</strong></p>
                        <p style="color: #666; font-style: italic;">💡 Petunjuk: Auto-migration, associations, hooks...</p>
                        
                        <p><strong>6. Kapan kita membutuhkan CORS middleware?</strong></p>
                        <p style="color: #666; font-style: italic;">💡 Petunjuk: Frontend dan backend di domain berbeda...</p>
                        
                        <p><strong>7. Mengapa JWT lebih baik dari session-based authentication untuk API?</strong></p>
                        <p style="color: #666; font-style: italic;">💡 Petunjuk: Stateless, scalable, cross-domain...</p>
                    </div>

                    <div style="background: #f8f9fa; border-left: 4px solid #f39c12; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Bagian C: Arsitektur & Struktur</h4>
                        
                        <p><strong>8. Jelaskan alur dependency flow dalam arsitektur yang kita buat!</strong></p>
                        <p style="color: #666; font-style: italic;">💡 Petunjuk: Handlers → Services → Repositories → Database</p>
                        
                        <p><strong>9. Mengapa kita memisahkan requests dan responses dari models?</strong></p>
                        <p style="color: #666; font-style: italic;">💡 Petunjuk: Validasi input, format output, keamanan...</p>
                        
                        <p><strong>10. Apa fungsi dari folder helpers dan middlewares?</strong></p>
                        <p style="color: #666; font-style: italic;">💡 Petunjuk: Satu untuk utility, satu untuk intercept...</p>
                        
                        <p><strong>11. Bagaimana Layered Architecture membantu dalam maintenance code?</strong></p>
                        <p style="color: #666; font-style: italic;">💡 Petunjuk: Separation of concerns, testability...</p>
                    </div>

                    <div style="background: #f8f9fa; border-left: 4px solid #27ae60; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Bagian D: Konfigurasi & Database</h4>
                        
                        <p><strong>12. Mengapa kita menggunakan environment variables untuk konfigurasi?</strong></p>
                        <p style="color: #666; font-style: italic;">💡 Petunjuk: Keamanan, fleksibilitas, deployment...</p>
                        
                        <p><strong>13. Apa fungsi dari connection pooling dalam database?</strong></p>
                        <p style="color: #666; font-style: italic;">💡 Petunjuk: Performa, resource management...</p>
                        
                        <p><strong>14. Mengapa kita menggunakan AutoMigrate di GORM?</strong></p>
                        <p style="color: #666; font-style: italic;">💡 Petunjuk: Schema management, development speed...</p>
                        
                        <p><strong>15. Apa yang terjadi jika file .env tidak ditemukan saat aplikasi berjalan?</strong></p>
                        <p style="color: #666; font-style: italic;">💡 Petunjuk: Fallback ke system environment variables...</p>
                    </div>

                    <h3>🎯 Latihan Praktis</h3>
                    <p>Sekarang mari kita praktikkan dengan beberapa latihan yang akan memperkuat pemahaman Anda:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>💻 Latihan 1: Membuat Project Baru</h4>
                        <p><strong>Tantangan:</strong> Buat project Go baru dengan nama "my-shop-api" dan install minimal 3 dependencies yang berbeda dari yang sudah kita pelajari.</p>
                        <p><strong>Langkah:</strong></p>
                        <ol>
                            <li>Buat direktori baru</li>
                            <li>Inisialisasi Go module</li>
                            <li>Install 3 dependencies baru (bisa dari <a href="https://pkg.go.dev/" target="_blank">pkg.go.dev</a>)</li>
                            <li>Verifikasi file go.mod dan go.sum</li>
                        </ol>
                    </div>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>🏗️ Latihan 2: Merancang Struktur Folder</h4>
                        <p><strong>Tantangan:</strong> Rancang struktur folder untuk aplikasi "blog-api" yang memiliki fitur artikel, komentar, dan user management.</p>
                        <p><strong>Pertimbangkan:</strong></p>
                        <ul>
                            <li>Berapa banyak folder yang dibutuhkan?</li>
                            <li>Bagaimana dependency flow-nya?</li>
                            <li>File apa saja yang ada di setiap folder?</li>
                        </ul>
                    </div>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>⚙️ Latihan 3: Konfigurasi Environment</h4>
                        <p><strong>Tantangan:</strong> Buat file .env untuk aplikasi production dengan konfigurasi yang aman.</p>
                        <p><strong>Include:</strong></p>
                        <ul>
                            <li>Database configuration (production)</li>
                            <li>Server configuration</li>
                            <li>Security keys</li>
                            <li>External API keys</li>
                        </ul>
                    </div>

                    <h3>🧠 Teknik Memori untuk Developer</h3>
                    <p>Sebagai bonus, berikut beberapa teknik yang bisa membantu Anda mengingat konsep-konsep programming:</p>

                    <h4>🔗 Association Technique</h4>
                    <p>Hubungkan konsep baru dengan yang sudah familiar:</p>
                    <ul>
                        <li><strong>Go Modules</strong> → seperti <strong>package.json</strong> di Node.js</li>
                        <li><strong>GORM</strong> → seperti <strong>Eloquent</strong> di Laravel</li>
                        <li><strong>Gin Framework</strong> → seperti <strong>Express.js</strong> di Node.js</li>
                        <li><strong>Environment Variables</strong> → seperti <strong>config files</strong> di framework lain</li>
                    </ul>

                    <h4>🎯 Spaced Repetition</h4>
                    <p>Jadwal review yang optimal:</p>
                    <ul>
                        <li><strong>Hari 1:</strong> Review setelah 24 jam (sekarang!)</li>
                        <li><strong>Hari 3:</strong> Review singkat konsep utama</li>
                        <li><strong>Minggu 1:</strong> Praktik dengan project kecil</li>
                        <li><strong>Bulan 1:</strong> Implementasi dalam project real</li>
                    </ul>

                    <h4>💡 Active Recall</h4>
                    <p>Coba jawab pertanyaan tanpa melihat materi:</p>
                    <ul>
                        <li>Tutup ebook dan coba jelaskan Go modules</li>
                        <li>Gambarkan struktur folder tanpa melihat</li>
                        <li>List dependencies yang sudah diinstall</li>
                    </ul>

                    <h3>🎉 Refleksi Pembelajaran</h3>
                    <p>Mari kita refleksikan apa yang telah dipelajari:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #2c3e50;">📊 Self-Assessment</h4>
                        <p><strong>Rate pemahaman Anda (1-5):</strong></p>
                        <ul style="color: #495057;">
                            <li>Go Modules: ___/5</li>
                            <li>Dependencies Management: ___/5</li>
                            <li>Project Structure: ___/5</li>
                            <li>Database Configuration: ___/5</li>
                        </ul>
                        <p style="color: #495057;"><strong>Area yang perlu diperkuat:</strong> _________________</p>
                    </div>

                    <h3>🚀 Persiapan Bab Selanjutnya</h3>
                    <p>Setelah beristirahat dan review, kita akan melanjutkan ke bab yang lebih menarik:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>🎯 Preview Bab 6: Model & Database Schema</h4>
                        <p>Di bab selanjutnya, kita akan:</p>
                        <ul>
                            <li>✅ Membuat model User dengan GORM</li>
                            <li>✅ Implementasi database schema</li>
                            <li>✅ Validasi data dengan struct tags</li>
                            <li>✅ Relationship antar model</li>
                        </ul>
                    </div>

                    <blockquote style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 1rem; margin: 2rem 0;">
                        <strong>💡 Tips untuk Bab Selanjutnya:</strong> Pastikan Anda sudah memahami konsep struct di Go dan basic database operations. Jika belum, luangkan waktu 10 menit untuk review materi Go fundamentals tentang struct dan interface.
                    </blockquote>

                    <h3>🎊 Selamat!</h3>
                    <p>Anda telah berhasil menyelesaikan review bab 1-4! Otak Anda sekarang telah mengkonsolidasikan pengetahuan tentang Go modules, dependencies, project structure, dan database configuration. Ini adalah fondasi yang kuat untuk melanjutkan perjalanan pengembangan API.</p>

                  
                `
            },
            {
                id: 'chapter6',
                title: 'Bab 6: Modul Authentication - Register',
                meta: 'Halaman 6 dari 50 • Dibaca 8 menit',
                content: `
                    <h2>🔐 Bab 6: Modul Authentication - Register</h2>
                    <p>Selamat! Sekarang kita akan mulai membangun fitur authentication yang merupakan fondasi keamanan untuk API toko online. Kita akan mulai dengan modul Register terlebih dahulu, kemudian dilanjutkan dengan Login dan Logout di bab-bab selanjutnya.</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">🎯 Apa yang Akan Kita Buat di Bab Ini?</h3>
                        <p style="color: #495057; margin-bottom: 0;">Kita akan membuat sistem register user baru dengan validasi, password hashing, dan JWT token generation. Setelah selesai, kita akan test menggunakan Postman.</p>
                    </div>

                    <h3>📋 Database Schema User</h3>
                    <p>Berikut adalah struktur database untuk user:</p>

                    <pre><code>CREATE TABLE user (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    role ENUM('customer', 'admin') DEFAULT 'customer',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL
);</code></pre>

                    <h3>🏗️ Struktur File yang Akan Kita Buat</h3>
                    <p>Kita akan mengikuti struktur pattern folder yang sudah ada. Berikut file-file yang akan kita buat:</p>

                    <pre><code>tokogo/
├── models/
│   └── user.go                    # User model struct
├── requests/
│   └── auth_request.go           # Request structs untuk auth
├── responses/
│   └── auth_response.go          # Response structs untuk auth
├── repositories/
│   └── auth_repository.go        # Database operations
├── services/
│   └── auth_service.go           # Business logic
├── handlers/
│   └── auth_handler.go           # HTTP handlers
├── helpers/
│   └── jwt.go                    # JWT helper functions
└── middlewares/
    └── auth.go                   # Authentication middleware</code></pre>

                    <h3>📝 Langkah 1: Membuat User Model</h3>
                    <p>Pertama, kita buat model User di file <code>models/user.go</code>:</p>

                    <pre><code>package models

import (
    "time"
    "gorm.io/gorm"
)

type User struct {
    ID        uint           \`gorm:"primaryKey;column:id;type:BIGINT UNSIGNED AUTO_INCREMENT" json:"id"\`
    Name      string         \`gorm:"column:name;type:VARCHAR(255);not null" json:"name"\`
    Email     string         \`gorm:"column:email;type:VARCHAR(255);uniqueIndex;not null" json:"email"\`
    Password  string         \`gorm:"column:password;type:VARCHAR(255);not null" json:"-"\` // Hidden dari JSON response
    Role      string         \`gorm:"column:role;type:ENUM('customer','admin');default:'customer'" json:"role"\`
    CreatedAt time.Time      \`gorm:"column:created_at;type:TIMESTAMP DEFAULT CURRENT_TIMESTAMP" json:"created_at"\`
    UpdatedAt time.Time      \`gorm:"column:updated_at;type:TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP" json:"updated_at"\`
    DeletedAt gorm.DeletedAt \`gorm:"column:deleted_at;type:TIMESTAMP NULL;index" json:"-"\`
}

// TableName mengembalikan nama tabel untuk model User
func (User) TableName() string {
    return "user"
}</code></pre>

                    <h4>Penjelasan Model User:</h4>
                    <ul>
                        <li><strong>ID:</strong> Primary key dengan auto increment</li>
                        <li><strong>Name:</strong> Nama user (required)</li>
                        <li><strong>Email:</strong> Email unik (required)</li>
                        <li><strong>Password:</strong> Password yang di-hash (hidden dari JSON)</li>
                        <li><strong>Role:</strong> Enum dengan nilai 'customer' atau 'admin'</li>
                        <li><strong>Timestamps:</strong> created_at, updated_at, deleted_at</li>
                    </ul>

                    <h3>📝 Langkah 2: Membuat Request Struct untuk Register</h3>
                    <p>Buat file <code>requests/auth_request.go</code> untuk validasi input register:</p>

                    <pre><code>package requests

import (
    "errors"
    "github.com/go-playground/validator/v10"
)

// RegisterRequest represents the request structure for user registration
type RegisterRequest struct {
    Username        string \`json:"username" validate:"required,min=3,max=50"\`
    Email           string \`json:"email" validate:"required,email"\`
    Password        string \`json:"password" validate:"required,min=6"\`
    ConfirmPassword string \`json:"confirm_password" validate:"required,min=6"\`
}

// Validate validates the RegisterRequest using the validator
func (r *RegisterRequest) Validate() error {
    validate := validator.New()
    
    // Validasi struct fields
    if err := validate.Struct(r); err != nil {
        return err
    }
    
    // Validasi custom: password dan confirm_password harus sama
    if r.Password != r.ConfirmPassword {
        return errors.New("password and confirm_password must match")
    }
    
    return nil
}</code></pre>

                    <h4>Penjelasan RegisterRequest:</h4>
                    <ul>
                        <li><strong>Username:</strong> Nama pengguna dengan validasi min 3, max 50 karakter</li>
                        <li><strong>Email:</strong> Email dengan format yang valid</li>
                        <li><strong>Password:</strong> Password minimal 6 karakter</li>
                        <li><strong>ConfirmPassword:</strong> Konfirmasi password yang harus sama dengan password</li>
                        <li><strong>Validate():</strong> Method untuk memvalidasi struct dan memastikan password sama dengan confirm_password</li>
                    </ul>

                    <h4>Validasi yang Digunakan:</h4>
                    <ul>
                        <li><strong>required:</strong> Field wajib diisi</li>
                        <li><strong>email:</strong> Format email yang valid</li>
                        <li><strong>min=3,max=50:</strong> Username minimal 3, maksimal 50 karakter</li>
                        <li><strong>min=6:</strong> Password dan ConfirmPassword minimal 6 karakter</li>
                        <li><strong>Custom Validation:</strong> Password dan ConfirmPassword harus sama</li>
                    </ul>

                    <h3>📝 Langkah 3: Membuat Response Struct untuk Register</h3>
                    <p>Buat file <code>responses/auth_response.go</code> untuk format response register:</p>

                    <pre><code>package responses

import "tokogo/models"

// RegisterResponse struct untuk response register
type RegisterResponse struct {
    User  UserResponse \`json:"user"\`
    Token string       \`json:"token"\`
}

// UserResponse struct untuk response user (tanpa password)
type UserResponse struct {
    ID        uint   \`json:"id"\`
    Name      string \`json:"name"\`
    Email     string \`json:"email"\`
    Role      string \`json:"role"\`
    CreatedAt string \`json:"created_at"\`
}

// ErrorResponse struct untuk response error
type ErrorResponse struct {
    Error   string \`json:"error"\`
    Message string \`json:"message"\`
}

// SuccessResponse struct untuk response sukses
type SuccessResponse struct {
    Message string      \`json:"message"\`
    Data    interface{} \`json:"data,omitempty"\`
}

// ConvertUserToResponse mengkonversi User model ke UserResponse
func ConvertUserToResponse(user models.User) UserResponse {
    return UserResponse{
        ID:        user.ID,
        Name:      user.Name,
        Email:     user.Email,
        Role:      user.Role,
        CreatedAt: user.CreatedAt.Format("2006-01-02 15:04:05"),
    }
}</code></pre>

                    <h4>Penjelasan Response Structs:</h4>
                    <ul>
                        <li><strong>RegisterResponse:</strong> Response khusus untuk register yang berisi user data dan JWT token</li>
                        <li><strong>UserResponse:</strong> Data user tanpa password untuk keamanan</li>
                        <li><strong>ErrorResponse:</strong> Format response untuk error</li>
                        <li><strong>SuccessResponse:</strong> Format response untuk sukses</li>
                        <li><strong>ConvertUserToResponse:</strong> Helper function untuk konversi model ke response</li>
                    </ul>

                    <h3>📝 Langkah 4: Membuat JWT Helper untuk Register</h3>
                    <p>Buat file <code>helpers/jwt.go</code> untuk JWT operations:</p>

                    <pre><code>package helpers

import (
    "time"

    "github.com/golang-jwt/jwt"
    "tokogo/models"
)

var jwtSecret = []byte("your-secret-key") // Gunakan dari environment variable

// Claims struct untuk JWT claims
type Claims struct {
    UserID uint   \`json:"user_id"\`
    Email  string \`json:"email"\`
    Role   string \`json:"role"\`
    jwt.StandardClaims
}

// GenerateToken menghasilkan JWT token untuk user
func GenerateToken(user models.User) (string, error) {
    expirationTime := time.Now().Add(24 * time.Hour) // Token berlaku 24 jam
    
    claims := &Claims{
        UserID: user.ID,
        Email:  user.Email,
        Role:   user.Role,
        StandardClaims: jwt.StandardClaims{
            ExpiresAt: expirationTime.Unix(),
            IssuedAt:  time.Now().Unix(),
        },
    }

    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    tokenString, err := token.SignedString(jwtSecret)
    
    if err != nil {
        return "", err
    }

    return tokenString, nil
}</code></pre>

                    <h4>Penjelasan JWT Helper:</h4>
                    <ul>
                        <li><strong>Claims:</strong> Struct yang berisi data user dalam JWT token</li>
                        <li><strong>GenerateToken:</strong> Function untuk membuat JWT token setelah user berhasil register</li>
                        <li><strong>ExpirationTime:</strong> Token berlaku selama 24 jam</li>
                        <li><strong>jwtSecret:</strong> Secret key untuk signing token (sebaiknya dari environment variable)</li>
                    </ul>

                    <h3>📝 Langkah 5: Membuat Auth Repository untuk Register</h3>
                    <p>Buat file <code>repositories/auth_repository.go</code> untuk database operations register:</p>

                    <pre><code>package repositories

import (
    "errors"
    "tokogo/config"
    "tokogo/models"
    "gorm.io/gorm"
)

type AuthRepository struct {
    db *gorm.DB
}

// NewAuthRepository membuat instance baru AuthRepository
func NewAuthRepository() *AuthRepository {
    return &AuthRepository{
        db: config.DB,
    }
}

// CreateUser membuat user baru
func (r *AuthRepository) CreateUser(user *models.User) error {
    return r.db.Create(user).Error
}

// GetUserByEmail mengambil user berdasarkan email (untuk cek duplikasi)
func (r *AuthRepository) GetUserByEmail(email string) (*models.User, error) {
    var user models.User
    err := r.db.Where("email = ?", email).First(&user).Error
    
    if err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, errors.New("user not found")
        }
        return nil, err
    }
    
    return &user, nil
}</code></pre>

                    <h4>Penjelasan Auth Repository:</h4>
                    <ul>
                        <li><strong>CreateUser:</strong> Function untuk menyimpan user baru ke database</li>
                        <li><strong>GetUserByEmail:</strong> Function untuk mengecek apakah email sudah terdaftar</li>
                        <li><strong>NewAuthRepository:</strong> Constructor untuk membuat instance repository</li>
                        <li><strong>Error Handling:</strong> Menangani error jika user tidak ditemukan</li>
                    </ul>

                    <h3>📝 Langkah 6: Membuat Auth Service untuk Register</h3>
                    <p>Buat file <code>services/auth_service.go</code> untuk business logic register:</p>

                    <pre><code>package services

import (
    "errors"
    "tokogo/helpers"
    "tokogo/models"
    "tokogo/repositories"
    "tokogo/requests"
    "tokogo/responses"
    "golang.org/x/crypto/bcrypt"
)

type AuthService struct {
    authRepo *repositories.AuthRepository
}

// NewAuthService membuat instance baru AuthService
func NewAuthService() *AuthService {
    return &AuthService{
        authRepo: repositories.NewAuthRepository(),
    }
}

// Register mendaftarkan user baru
func (s *AuthService) Register(req requests.RegisterRequest) (*responses.RegisterResponse, error) {
    // Cek apakah email sudah terdaftar
    existingUser, _ := s.authRepo.GetUserByEmail(req.Email)
    if existingUser != nil {
        return nil, errors.New("email already registered")
    }

    // Hash password
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
    if err != nil {
        return nil, errors.New("failed to hash password")
    }

    // Buat user baru
    user := &models.User{
        Name:     req.Username, // Menggunakan Username dari request
        Email:    req.Email,
        Password: string(hashedPassword),
        Role:     "customer", // Default role
    }

    // Simpan ke database
    if err := s.authRepo.CreateUser(user); err != nil {
        return nil, errors.New("failed to create user")
    }

    // Generate JWT token
    token, err := helpers.GenerateToken(*user)
    if err != nil {
        return nil, errors.New("failed to generate token")
    }

    // Return response
    return &responses.RegisterResponse{
        User:  responses.ConvertUserToResponse(*user),
        Token: token,
    }, nil
}</code></pre>

                    <h4>Penjelasan Auth Service Register:</h4>
                    <ul>
                        <li><strong>Register Function:</strong> Business logic untuk registrasi user baru</li>
                        <li><strong>Email Check:</strong> Mengecek apakah email sudah terdaftar</li>
                        <li><strong>Password Hashing:</strong> Menggunakan bcrypt untuk hash password</li>
                        <li><strong>User Creation:</strong> Membuat user baru dengan role default "customer"</li>
                        <li><strong>JWT Generation:</strong> Membuat JWT token setelah user berhasil dibuat</li>
                        <li><strong>Response:</strong> Mengembalikan user data dan token</li>
                    </ul>

                    <h3>📝 Langkah 7: Membuat Auth Handler untuk Register</h3>
                    <p>Buat file <code>handlers/auth_handler.go</code> untuk HTTP handler register:</p>

                    <pre><code>package handlers

import (
    "net/http"
    "tokogo/requests"
    "tokogo/responses"
    "tokogo/services"
    "github.com/gin-gonic/gin"
)

type AuthHandler struct {
    authService *services.AuthService
}

// NewAuthHandler membuat instance baru AuthHandler
func NewAuthHandler() *AuthHandler {
    return &AuthHandler{
        authService: services.NewAuthService(),
    }
}

// Register handler untuk registrasi user baru
func (h *AuthHandler) Register(c *gin.Context) {
    var req requests.RegisterRequest
    
    // Bind dan validasi request
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Validasi menggunakan method Validate()
    if err := req.Validate(); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Panggil service untuk register
    registerResponse, err := h.authService.Register(req)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "register_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusCreated, responses.SuccessResponse{
        Message: "User registered successfully",
        Data:    registerResponse,
    })
}</code></pre>

                    <h4>Penjelasan Auth Handler Register:</h4>
                    <ul>
                        <li><strong>Register Function:</strong> HTTP handler untuk endpoint register</li>
                        <li><strong>ShouldBindJSON:</strong> Binding JSON request ke struct</li>
                        <li><strong>Validate():</strong> Validasi menggunakan go-playground/validator</li>
                        <li><strong>Service Call:</strong> Memanggil business logic di service layer</li>
                        <li><strong>Response:</strong> Mengembalikan response sukses atau error</li>
                        <li><strong>Status Code:</strong> 201 Created untuk sukses, 400 Bad Request untuk error</li>
                    </ul>

                    <h3>📝 Langkah 8: Update Main.go untuk Register</h3>
                    <p>Update file <code>main.go</code> untuk setup route register:</p>

                    <pre><code>package main

import (
    "log"
    "tokogo/config"
    "tokogo/handlers"
    "github.com/gin-contrib/cors"
    "github.com/gin-gonic/gin"
    "github.com/joho/godotenv"
)

func main() {
    // Load environment variables
    if err := godotenv.Load(); err != nil {
        log.Println("No .env file found, using system environment variables")
    }

    // Initialize database
    config.InitDB()

    // Setup Gin router
    r := gin.Default()

    // CORS middleware
    r.Use(cors.New(cors.Config{
        AllowOrigins:     []string{"*"},
        AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
        AllowHeaders:     []string{"*"},
        ExposeHeaders:    []string{"Content-Length"},
        AllowCredentials: true,
    }))

    // Initialize handlers
    authHandler := handlers.NewAuthHandler()

    // Public routes (tidak perlu authentication)
    api := r.Group("/api/v1")
    {
        // Auth routes
        auth := api.Group("/auth")
        {
            auth.POST("/register", authHandler.Register)
        }
    }

    // Start server
    port := config.GetEnv("SERVER_PORT", "8080")
    log.Printf("Server starting on port %s", port)
    r.Run(":" + port)
}</code></pre>

                    <h4>Penjelasan Main.go:</h4>
                    <ul>
                        <li><strong>Database Init:</strong> Menginisialisasi koneksi database</li>
                        <li><strong>CORS Setup:</strong> Konfigurasi CORS untuk frontend</li>
                        <li><strong>Route Setup:</strong> Setup route untuk register endpoint</li>
                        <li><strong>Server Start:</strong> Menjalankan server di port yang ditentukan</li>
                    </ul>

                    <h3>📝 Langkah 9: Update Database Configuration</h3>
                    <p>Update file <code>config/database.go</code> untuk include User model:</p>

                    <pre><code>// Auto migrate model User
if err := DB.AutoMigrate(&models.User{}); err != nil {
    panic(fmt.Sprintf("AutoMigrate failed: %v", err))
}</code></pre>

                    <h4>Penjelasan Database Configuration:</h4>
                    <ul>
                        <li><strong>AutoMigrate:</strong> Otomatis membuat/update table user berdasarkan model</li>
                        <li><strong>Error Handling:</strong> Panic jika migration gagal</li>
                    </ul>

                    <h3>🧪 Testing API Register</h3>
                    <p>Sekarang mari kita test API register yang sudah kita buat:</p>

                    <h4>1. Register User Baru</h4>
                    <pre><code>POST http://localhost:8080/api/v1/auth/register
Content-Type: application/json

{
    "username": "johndoe",
    "email": "john@example.com",
    "password": "password123",
    "confirm_password": "password123"
}</code></pre>

                    <h4>Response Sukses (201 Created):</h4>
                    <pre><code>{
    "message": "User registered successfully",
    "data": {
        "user": {
            "id": 1,
            "name": "johndoe",
            "email": "john@example.com",
            "role": "customer",
            "created_at": "2024-01-15 10:30:00"
        },
        "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
    }
}</code></pre>

                    <h4>Response Error (400 Bad Request):</h4>
                    <pre><code>{
    "error": "validation_error",
    "message": "Key: 'RegisterRequest.Email' Error:Field validation for 'Email' failed on the 'email' tag"
}</code></pre>

                    <h4>Response Error - Password Tidak Sama:</h4>
                    <pre><code>{
    "error": "validation_error",
    "message": "password and confirm_password must match"
}</code></pre>

                    <h4>Response Error - Email Sudah Terdaftar:</h4>
                    <pre><code>{
    "error": "register_failed",
    "message": "email already registered"
}</code></pre>

                    <h3>🔧 Environment Variables</h3>
                    <p>Pastikan file <code>.env</code> Anda memiliki konfigurasi berikut:</p>

                    <pre><code># Database Configuration
DB_HOST=localhost
DB_PORT=3306
DB_USER=root
DB_PASSWORD=
DB_NAME=tokogo

# Server Configuration
SERVER_PORT=8080
JWT_SECRET=your-super-secret-jwt-key-here

# Environment
ENV=development</code></pre>

                    <h3>📦 Dependencies yang Dibutuhkan</h3>
                    <p>Pastikan Anda sudah menginstall dependencies berikut:</p>

                    <pre><code>go get golang.org/x/crypto/bcrypt</code></pre>

                    <h3>✅ Checklist Implementasi Register</h3>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>File yang Harus Dibuat:</h4>
                        <ul>
                            <li>✅ models/user.go</li>
                            <li>✅ requests/auth_request.go (RegisterRequest)</li>
                            <li>✅ responses/auth_response.go (RegisterResponse)</li>
                            <li>✅ helpers/jwt.go (GenerateToken)</li>
                            <li>✅ repositories/auth_repository.go (CreateUser, GetUserByEmail)</li>
                            <li>✅ services/auth_service.go (Register)</li>
                            <li>✅ handlers/auth_handler.go (Register)</li>
                        </ul>
                        
                        <h4>File yang Harus Diupdate:</h4>
                        <ul>
                            <li>✅ config/database.go (AutoMigrate User)</li>
                            <li>✅ main.go (Register route)</li>
                            <li>✅ .env (JWT_SECRET)</li>
                        </ul>
                    </div>

                    <h3>🚀 Cara Menjalankan</h3>
                    <ol>
                        <li>Pastikan MySQL sudah berjalan</li>
                        <li>Pastikan database 'tokogo' sudah dibuat</li>
                        <li>Jalankan: <code>go run main.go</code></li>
                        <li>Test dengan Postman atau curl</li>
                    </ol>

                    <h3>🎯 Fitur Register yang Sudah Diimplementasikan</h3>
                    <ul>
                        <li>✅ User Registration dengan validasi</li>
                        <li>✅ Password hashing dengan bcrypt</li>
                        <li>✅ JWT token generation</li>
                        <li>✅ Email uniqueness check</li>
                        <li>✅ Input validation dengan go-playground/validator</li>
                        <li>✅ Error handling yang proper</li>
                        <li>✅ Response format yang konsisten</li>
                    </ul>

                    <h3>🔒 Keamanan yang Sudah Diimplementasikan</h3>
                    <ul>
                        <li>✅ Password hashing dengan bcrypt</li>
                        <li>✅ JWT token dengan expiration</li>
                        <li>✅ Input validation dengan go-playground/validator</li>
                        <li>✅ SQL injection protection (GORM)</li>
                        <li>✅ CORS configuration</li>
                        <li>✅ Environment variables untuk secret keys</li>
                    </ul>

                    <h3>🎉 Selamat!</h3>
                    <p>Anda telah berhasil mengimplementasikan modul Register yang lengkap! Sistem register sudah siap untuk digunakan dan dapat diintegrasikan dengan frontend aplikasi.</p>

                    <div style="text-align: center; margin: 3rem 0;">
                        <div style="background: #f8f9fa; border: 1px solid #dee2e6; color: #2c3e50; padding: 2rem; border-radius: 5px; display: inline-block;">
                            <h3 style="color: #2c3e50; margin-bottom: 1rem;">🎯 Siap untuk Bab Selanjutnya?</h3>
                            <p style="color: #495057; margin-bottom: 0;">Di bab selanjutnya, kita akan membuat modul Login untuk melengkapi sistem authentication!</p>
                        </div>
                    </div>
                `
            },
            {
                id: 'chapter7',
                title: 'Bab 7: Modul Authentication - Login',
                meta: 'Halaman 7 dari 50 • Dibaca 8 menit',
                content: `
                    <h2>🔐 Bab 7: Modul Authentication - Login</h2>
                    <p>Selamat! Sekarang kita akan melanjutkan dengan modul Login untuk melengkapi sistem authentication. Di bab ini, kita akan mengimplementasikan fitur login user yang sudah terdaftar dengan validasi email dan password.</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">🎯 Apa yang Akan Kita Buat di Bab Ini?</h3>
                        <p style="color: #495057; margin-bottom: 0;">Kita akan membuat sistem login user dengan validasi email/password, password verification, dan JWT token generation. Setelah selesai, kita akan test menggunakan Postman.</p>
                    </div>

                    <h3>📋 Prasyarat</h3>
                    <p>Sebelum memulai, pastikan Anda sudah menyelesaikan:</p>
                    <ul>
                        <li>✅ Bab 6: Modul Authentication - Register</li>
                        <li>✅ User sudah terdaftar di database</li>
                        <li>✅ File-file authentication sudah dibuat</li>
                    </ul>

                    <h3>📝 Langkah 1: Update Request Struct untuk Login</h3>
                    <p>Update file <code>requests/auth_request.go</code> untuk menambahkan LoginRequest:</p>

                    <pre><code>package requests

import "github.com/go-playground/validator/v10"

// RegisterRequest represents the request structure for user registration
type RegisterRequest struct {
    Username string \`json:"username" validate:"required,min=3,max=50"\`
    Email    string \`json:"email" validate:"required,email"\`
    Password string \`json:"password" validate:"required,min=6"\`
}

// LoginRequest represents the request structure for user login
type LoginRequest struct {
    Email    string \`json:"email" validate:"required,email"\`
    Password string \`json:"password" validate:"required"\`
}

// Validate validates the RegisterRequest using the validator
func (r *RegisterRequest) Validate() error {
    validate := validator.New()
    return validate.Struct(r)
}

// Validate validates the LoginRequest using the validator
func (r *LoginRequest) Validate() error {
    validate := validator.New()
    return validate.Struct(r)
}</code></pre>

                    <h4>Penjelasan LoginRequest:</h4>
                    <ul>
                        <li><strong>Email:</strong> Email user yang akan login (required, format email valid)</li>
                        <li><strong>Password:</strong> Password user (required)</li>
                        <li><strong>Validate():</strong> Method untuk memvalidasi struct LoginRequest</li>
                    </ul>

                    <h3>📝 Langkah 2: Update Response Struct untuk Login</h3>
                    <p>Update file <code>responses/auth_response.go</code> untuk menambahkan LoginResponse:</p>

                    <pre><code>package responses

import "tokogo/models"

// RegisterResponse struct untuk response register
type RegisterResponse struct {
    User  UserResponse \`json:"user"\`
    Token string       \`json:"token"\`
}

// LoginResponse struct untuk response login
type LoginResponse struct {
    User  UserResponse \`json:"user"\`
    Token string       \`json:"token"\`
}

// UserResponse struct untuk response user (tanpa password)
type UserResponse struct {
    ID        uint   \`json:"id"\`
    Name      string \`json:"name"\`
    Email     string \`json:"email"\`
    Role      string \`json:"role"\`
    CreatedAt string \`json:"created_at"\`
}

// ErrorResponse struct untuk response error
type ErrorResponse struct {
    Error   string \`json:"error"\`
    Message string \`json:"message"\`
}

// SuccessResponse struct untuk response sukses
type SuccessResponse struct {
    Message string      \`json:"message"\`
    Data    interface{} \`json:"data,omitempty"\`
}

// ConvertUserToResponse mengkonversi User model ke UserResponse
func ConvertUserToResponse(user models.User) UserResponse {
    return UserResponse{
        ID:        user.ID,
        Name:      user.Name,
        Email:     user.Email,
        Role:      user.Role,
        CreatedAt: user.CreatedAt.Format("2006-01-02 15:04:05"),
    }
}</code></pre>

                    <h4>Penjelasan LoginResponse:</h4>
                    <ul>
                        <li><strong>LoginResponse:</strong> Response khusus untuk login yang berisi user data dan JWT token</li>
                        <li><strong>User:</strong> Data user tanpa password untuk keamanan</li>
                        <li><strong>Token:</strong> JWT token untuk authentication</li>
                    </ul>

                    <h3>📝 Langkah 3: Update JWT Helper untuk Login</h3>
                    <p>Update file <code>helpers/jwt.go</code> untuk menambahkan ValidateToken:</p>

                    <pre><code>package helpers

import (
    "errors"
    "time"

    "github.com/golang-jwt/jwt"
    "tokogo/models"
)

var jwtSecret = []byte("your-secret-key") // Gunakan dari environment variable

// Claims struct untuk JWT claims
type Claims struct {
    UserID uint   \`json:"user_id"\`
    Email  string \`json:"email"\`
    Role   string \`json:"role"\`
    jwt.StandardClaims
}

// GenerateToken menghasilkan JWT token untuk user
func GenerateToken(user models.User) (string, error) {
    expirationTime := time.Now().Add(24 * time.Hour) // Token berlaku 24 jam
    
    claims := &Claims{
        UserID: user.ID,
        Email:  user.Email,
        Role:   user.Role,
        StandardClaims: jwt.StandardClaims{
            ExpiresAt: expirationTime.Unix(),
            IssuedAt:  time.Now().Unix(),
        },
    }

    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    tokenString, err := token.SignedString(jwtSecret)
    
    if err != nil {
        return "", err
    }

    return tokenString, nil
}

// ValidateToken memvalidasi JWT token
func ValidateToken(tokenString string) (*Claims, error) {
    claims := &Claims{}

    token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
        return jwtSecret, nil
    })

    if err != nil {
        return nil, err
    }

    if !token.Valid {
        return nil, errors.New("invalid token")
    }

    return claims, nil
}</code></pre>

                    <h4>Penjelasan ValidateToken:</h4>
                    <ul>
                        <li><strong>ValidateToken:</strong> Function untuk memvalidasi JWT token yang akan digunakan di middleware</li>
                        <li><strong>Claims:</strong> Mengembalikan data user dari token</li>
                        <li><strong>Error Handling:</strong> Menangani token yang invalid atau expired</li>
                    </ul>

                    <h3>📝 Langkah 4: Update Auth Service untuk Login</h3>
                    <p>Update file <code>services/auth_service.go</code> untuk menambahkan Login function:</p>

                    <pre><code>package services

import (
    "errors"
    "tokogo/helpers"
    "tokogo/models"
    "tokogo/repositories"
    "tokogo/requests"
    "tokogo/responses"
    "golang.org/x/crypto/bcrypt"
)

type AuthService struct {
    authRepo *repositories.AuthRepository
}

// NewAuthService membuat instance baru AuthService
func NewAuthService() *AuthService {
    return &AuthService{
        authRepo: repositories.NewAuthRepository(),
    }
}

// Register mendaftarkan user baru
func (s *AuthService) Register(req requests.RegisterRequest) (*responses.RegisterResponse, error) {
    // Cek apakah email sudah terdaftar
    existingUser, _ := s.authRepo.GetUserByEmail(req.Email)
    if existingUser != nil {
        return nil, errors.New("email already registered")
    }

    // Hash password
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
    if err != nil {
        return nil, errors.New("failed to hash password")
    }

    // Buat user baru
    user := &models.User{
        Name:     req.Username, // Menggunakan Username dari request
        Email:    req.Email,
        Password: string(hashedPassword),
        Role:     "customer", // Default role
    }

    // Simpan ke database
    if err := s.authRepo.CreateUser(user); err != nil {
        return nil, errors.New("failed to create user")
    }

    // Generate JWT token
    token, err := helpers.GenerateToken(*user)
    if err != nil {
        return nil, errors.New("failed to generate token")
    }

    // Return response
    return &responses.RegisterResponse{
        User:  responses.ConvertUserToResponse(*user),
        Token: token,
    }, nil
}

// Login melakukan login user
func (s *AuthService) Login(req requests.LoginRequest) (*responses.LoginResponse, error) {
    // Cari user berdasarkan email
    user, err := s.authRepo.GetUserByEmail(req.Email)
    if err != nil {
        return nil, errors.New("invalid email or password")
    }

    // Verifikasi password
    err = bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(req.Password))
    if err != nil {
        return nil, errors.New("invalid email or password")
    }

    // Generate JWT token
    token, err := helpers.GenerateToken(*user)
    if err != nil {
        return nil, errors.New("failed to generate token")
    }

    // Return response
    return &responses.LoginResponse{
        User:  responses.ConvertUserToResponse(*user),
        Token: token,
    }, nil
}</code></pre>

                    <h4>Penjelasan Login Function:</h4>
                    <ul>
                        <li><strong>Email Lookup:</strong> Mencari user berdasarkan email</li>
                        <li><strong>Password Verification:</strong> Membandingkan password dengan bcrypt</li>
                        <li><strong>JWT Generation:</strong> Membuat JWT token setelah login sukses</li>
                        <li><strong>Error Handling:</strong> Mengembalikan error yang sama untuk keamanan</li>
                    </ul>

                    <h3>📝 Langkah 5: Update Auth Handler untuk Login</h3>
                    <p>Update file <code>handlers/auth_handler.go</code> untuk menambahkan Login handler:</p>

                    <pre><code>package handlers

import (
    "net/http"
    "tokogo/requests"
    "tokogo/responses"
    "tokogo/services"

    "github.com/gin-gonic/gin"
)

type AuthHandler struct {
    authService *services.AuthService
}

// NewAuthHandler membuat instance baru AuthHandler
func NewAuthHandler() *AuthHandler {
    return &AuthHandler{
        authService: services.NewAuthService(),
    }
}

// Register handler untuk registrasi user baru
func (h *AuthHandler) Register(c *gin.Context) {
    var req requests.RegisterRequest

    // Bind dan validasi request
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Validasi menggunakan method Validate()
    if err := req.Validate(); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Panggil service untuk register
    registerResponse, err := h.authService.Register(req)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "register_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusCreated, responses.SuccessResponse{
        Message: "User registered successfully",
        Data:    registerResponse,
    })
}

// Login handler untuk login user
func (h *AuthHandler) Login(c *gin.Context) {
    var req requests.LoginRequest

    // Bind dan validasi request
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Validasi menggunakan method Validate()
    if err := req.Validate(); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Panggil service untuk login
    loginResponse, err := h.authService.Login(req)
    if err != nil {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "login_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Login successful",
        Data:    loginResponse,
    })
}</code></pre>

                    <h4>Penjelasan Login Handler:</h4>
                    <ul>
                        <li><strong>Login Function:</strong> HTTP handler untuk endpoint login</li>
                        <li><strong>Request Binding:</strong> Binding JSON request ke LoginRequest struct</li>
                        <li><strong>Validation:</strong> Validasi menggunakan go-playground/validator</li>
                        <li><strong>Service Call:</strong> Memanggil business logic di service layer</li>
                        <li><strong>Status Code:</strong> 200 OK untuk sukses, 401 Unauthorized untuk error</li>
                    </ul>

                    <h3>📝 Langkah 6: Update Main.go untuk Login</h3>
                    <p>Update file <code>main.go</code> untuk menambahkan route login:</p>

                    <pre><code>package main

import (
    "log"
    "tokogo/config"
    "tokogo/handlers"

    "github.com/gin-contrib/cors"
    "github.com/gin-gonic/gin"
    "github.com/joho/godotenv"
)

func main() {
    // Load environment variables
    if err := godotenv.Load(); err != nil {
        log.Println("No .env file found, using system environment variables")
    }

    // Initialize database
    config.InitDB()

    // Setup Gin router
    r := gin.Default()

    // CORS middleware
    r.Use(cors.New(cors.Config{
        AllowOrigins:     []string{"*"},
        AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
        AllowHeaders:     []string{"*"},
        ExposeHeaders:    []string{"Content-Length"},
        AllowCredentials: true,
    }))

    // Initialize handlers
    authHandler := handlers.NewAuthHandler()

    // Public routes (tidak perlu authentication)
    api := r.Group("/api/v1")
    {
        // Auth routes
        auth := api.Group("/auth")
        {
            auth.POST("/register", authHandler.Register)
            auth.POST("/login", authHandler.Login)
        }
    }

    // Start server
    port := config.GetEnv("SERVER_PORT", "8080")
    log.Printf("Server starting on port %s", port)
    r.Run(":" + port)
}</code></pre>

                    <h4>Penjelasan Main.go Update:</h4>
                    <ul>
                        <li><strong>Login Route:</strong> Menambahkan POST /api/v1/auth/login</li>
                        <li><strong>Handler:</strong> Menggunakan authHandler.Login</li>
                        <li><strong>Public Route:</strong> Login tidak memerlukan authentication</li>
                    </ul>

                    <h3>🧪 Testing API Login</h3>
                    <p>Sekarang mari kita test API login yang sudah kita buat:</p>

                    <h4>1. Login User</h4>
                    <pre><code>POST http://localhost:8080/api/v1/auth/login
Content-Type: application/json

{
    "email": "john@example.com",
    "password": "password123"
}</code></pre>

                    <h4>Response Sukses (200 OK):</h4>
                    <pre><code>{
    "message": "Login successful",
    "data": {
        "user": {
            "id": 1,
            "name": "johndoe",
            "email": "john@example.com",
            "role": "customer",
            "created_at": "2024-01-15 10:30:00"
        },
        "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
    }
}</code></pre>

                    <h4>Response Error - Invalid Credentials (401 Unauthorized):</h4>
                    <pre><code>{
    "error": "login_failed",
    "message": "invalid email or password"
}</code></pre>

                    <h4>Response Error - Validation Error (400 Bad Request):</h4>
                    <pre><code>{
    "error": "validation_error",
    "message": "Key: 'LoginRequest.Email' Error:Field validation for 'Email' failed on the 'email' tag"
}</code></pre>

                    <h3>✅ Checklist Implementasi Login</h3>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>File yang Harus Diupdate:</h4>
                        <ul>
                            <li>✅ requests/auth_request.go (LoginRequest)</li>
                            <li>✅ responses/auth_response.go (LoginResponse)</li>
                            <li>✅ helpers/jwt.go (ValidateToken)</li>
                            <li>✅ services/auth_service.go (Login)</li>
                            <li>✅ handlers/auth_handler.go (Login)</li>
                            <li>✅ main.go (Login route)</li>
                        </ul>
                    </div>

                    <h3>🚀 Cara Menjalankan</h3>
                    <ol>
                        <li>Pastikan MySQL sudah berjalan</li>
                        <li>Pastikan database 'tokogo' sudah dibuat</li>
                        <li>Pastikan ada user yang sudah terdaftar (dari Bab 6)</li>
                        <li>Jalankan: <code>go run main.go</code></li>
                        <li>Test dengan Postman atau curl</li>
                    </ol>

                    <h3>🎯 Fitur Login yang Sudah Diimplementasikan</h3>
                    <ul>
                        <li>✅ User Login dengan validasi email/password</li>
                        <li>✅ Password verification dengan bcrypt</li>
                        <li>✅ JWT token generation setelah login sukses</li>
                        <li>✅ Input validation dengan go-playground/validator</li>
                        <li>✅ Error handling yang proper</li>
                        <li>✅ Response format yang konsisten</li>
                        <li>✅ Security: Error message yang sama untuk keamanan</li>
                    </ul>

                    <h3>🔒 Keamanan yang Diimplementasikan</h3>
                    <ul>
                        <li>✅ Password verification dengan bcrypt</li>
                        <li>✅ JWT token dengan expiration</li>
                        <li>✅ Input validation dengan go-playground/validator</li>
                        <li>✅ SQL injection protection (GORM)</li>
                        <li>✅ CORS configuration</li>
                        <li>✅ Environment variables untuk secret keys</li>
                        <li>✅ Generic error messages untuk keamanan</li>
                    </ul>

                    <h3>🎉 Selamat!</h3>
                    <p>Anda telah berhasil mengimplementasikan modul Login yang lengkap! Sistem login sudah siap untuk digunakan dan dapat diintegrasikan dengan frontend aplikasi.</p>

                    <div style="text-align: center; margin: 3rem 0;">
                        <div style="background: #f8f9fa; border: 1px solid #dee2e6; color: #2c3e50; padding: 2rem; border-radius: 5px; display: inline-block;">
                            <h3 style="color: #2c3e50; margin-bottom: 1rem;">🎯 Siap untuk Bab Selanjutnya?</h3>
                            <p style="color: #495057; margin-bottom: 0;">Di bab selanjutnya, kita akan membuat modul Logout dan middleware authentication untuk melengkapi sistem authentication!</p>
                        </div>
                    </div>
                `
            },
            {
                id: 'chapter8',
                title: 'Bab 8: Modul Authentication - Logout',
                meta: 'Halaman 8 dari 50 • Dibaca 10 menit',
                content: `
                    <h2>🚪 Bab 8: Modul Authentication - Logout</h2>
                    <p>Selamat! Sekarang kita akan menyelesaikan sistem authentication dengan membuat modul Logout dan middleware authentication. Di bab ini, kita akan mengimplementasikan fitur logout user dan middleware untuk melindungi endpoint yang memerlukan authentication.</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">🎯 Apa yang Akan Kita Buat di Bab Ini?</h3>
                        <p style="color: #495057; margin-bottom: 0;">Kita akan membuat sistem logout user, middleware authentication untuk melindungi endpoint, dan endpoint protected yang memerlukan JWT token. Setelah selesai, kita akan test menggunakan Postman.</p>
                    </div>

                    <h3>📋 Prasyarat</h3>
                    <p>Sebelum memulai, pastikan Anda sudah menyelesaikan:</p>
                    <ul>
                        <li>✅ Bab 6: Modul Authentication - Register</li>
                        <li>✅ Bab 7: Modul Authentication - Login</li>
                        <li>✅ User sudah terdaftar dan bisa login</li>
                        <li>✅ JWT token sudah bisa di-generate</li>
                    </ul>

                    <h3>📝 Langkah 1: Buat Middleware Authentication</h3>
                    <p>Buat file <code>middlewares/auth_middleware.go</code> untuk melindungi endpoint yang memerlukan authentication:</p>

                    <pre><code>package middlewares

import (
    "net/http"
    "strings"
    "tokogo/helpers"
    "tokogo/responses"

    "github.com/gin-gonic/gin"
)

// AuthMiddleware middleware untuk memvalidasi JWT token
func AuthMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // Ambil token dari header Authorization
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
                Error:   "unauthorized",
                Message: "Authorization header is required",
            })
            c.Abort()
            return
        }

        // Cek format Bearer token
        tokenParts := strings.Split(authHeader, " ")
        if len(tokenParts) != 2 || tokenParts[0] != "Bearer" {
            c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
                Error:   "unauthorized",
                Message: "Invalid authorization header format",
            })
            c.Abort()
            return
        }

        token := tokenParts[1]

        // Validasi token
        claims, err := helpers.ValidateToken(token)
        if err != nil {
            c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
                Error:   "unauthorized",
                Message: "Invalid or expired token",
            })
            c.Abort()
            return
        }

        // Set user info ke context untuk digunakan di handler
        c.Set("user_id", claims.UserID)
        c.Set("user_email", claims.Email)
        c.Set("user_role", claims.Role)

        c.Next()
    }
}

// AdminMiddleware middleware untuk memvalidasi admin role
func AdminMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // Cek apakah user sudah login (AuthMiddleware harus dipanggil dulu)
        userRole, exists := c.Get("user_role")
        if !exists {
            c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
                Error:   "unauthorized",
                Message: "User not authenticated",
            })
            c.Abort()
            return
        }

        // Cek apakah user adalah admin
        if userRole != "admin" {
            c.JSON(http.StatusForbidden, responses.ErrorResponse{
                Error:   "forbidden",
                Message: "Admin access required",
            })
            c.Abort()
            return
        }

        c.Next()
    }
}</code></pre>

                    <h4>Penjelasan Middleware:</h4>
                    <ul>
                        <li><strong>AuthMiddleware:</strong> Memvalidasi JWT token dan set user info ke context</li>
                        <li><strong>AdminMiddleware:</strong> Memvalidasi apakah user memiliki role admin</li>
                        <li><strong>Authorization Header:</strong> Menggunakan format "Bearer {token}"</li>
                        <li><strong>Context:</strong> Menyimpan user info untuk digunakan di handler</li>
                    </ul>

                    <h3>📝 Langkah 2: Update Auth Service untuk Logout</h3>
                    <p>Update file <code>services/auth_service.go</code> untuk menambahkan Logout function:</p>

                    <pre><code>package services

import (
    "errors"
    "tokogo/helpers"
    "tokogo/models"
    "tokogo/repositories"
    "tokogo/requests"
    "tokogo/responses"
    "golang.org/x/crypto/bcrypt"
)

type AuthService struct {
    authRepo *repositories.AuthRepository
}

// NewAuthService membuat instance baru AuthService
func NewAuthService() *AuthService {
    return &AuthService{
        authRepo: repositories.NewAuthRepository(),
    }
}

// Register mendaftarkan user baru
func (s *AuthService) Register(req requests.RegisterRequest) (*responses.RegisterResponse, error) {
    // Cek apakah email sudah terdaftar
    existingUser, _ := s.authRepo.GetUserByEmail(req.Email)
    if existingUser != nil {
        return nil, errors.New("email already registered")
    }

    // Hash password
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
    if err != nil {
        return nil, errors.New("failed to hash password")
    }

    // Buat user baru
    user := &models.User{
        Name:     req.Username, // Menggunakan Username dari request
        Email:    req.Email,
        Password: string(hashedPassword),
        Role:     "customer", // Default role
    }

    // Simpan ke database
    if err := s.authRepo.CreateUser(user); err != nil {
        return nil, errors.New("failed to create user")
    }

    // Generate JWT token
    token, err := helpers.GenerateToken(*user)
    if err != nil {
        return nil, errors.New("failed to generate token")
    }

    // Return response
    return &responses.RegisterResponse{
        User:  responses.ConvertUserToResponse(*user),
        Token: token,
    }, nil
}

// Login melakukan login user
func (s *AuthService) Login(req requests.LoginRequest) (*responses.LoginResponse, error) {
    // Cari user berdasarkan email
    user, err := s.authRepo.GetUserByEmail(req.Email)
    if err != nil {
        return nil, errors.New("invalid email or password")
    }

    // Verifikasi password
    err = bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(req.Password))
    if err != nil {
        return nil, errors.New("invalid email or password")
    }

    // Generate JWT token
    token, err := helpers.GenerateToken(*user)
    if err != nil {
        return nil, errors.New("failed to generate token")
    }

    // Return response
    return &responses.LoginResponse{
        User:  responses.ConvertUserToResponse(*user),
        Token: token,
    }, nil
}

// Logout melakukan logout user (client-side token removal)
func (s *AuthService) Logout(userID uint) (*responses.LogoutResponse, error) {
    // Untuk stateless JWT, logout dilakukan di client side
    // Server hanya memberikan response sukses
    // Di production, bisa implementasi token blacklist jika diperlukan
    
    return &responses.LogoutResponse{
        Message: "Logout successful",
    }, nil
}

// GetProfile mengambil profile user berdasarkan ID
func (s *AuthService) GetProfile(userID uint) (*responses.UserResponse, error) {
    user, err := s.authRepo.GetUserByID(userID)
    if err != nil {
        return nil, errors.New("user not found")
    }

    return &responses.UserResponse{
        ID:        user.ID,
        Name:      user.Name,
        Email:     user.Email,
        Role:      user.Role,
        CreatedAt: user.CreatedAt.Format("2006-01-02 15:04:05"),
    }, nil
}</code></pre>

                    <h4>Penjelasan Logout Function:</h4>
                    <ul>
                        <li><strong>Stateless Logout:</strong> Untuk JWT stateless, logout dilakukan di client side</li>
                        <li><strong>Token Removal:</strong> Client menghapus token dari storage</li>
                        <li><strong>Server Response:</strong> Server memberikan konfirmasi logout sukses</li>
                        <li><strong>GetProfile:</strong> Function tambahan untuk mengambil profile user</li>
                    </ul>

                    <h3>📝 Langkah 3: Update Response Struct untuk Logout</h3>
                    <p>Update file <code>responses/auth_response.go</code> untuk menambahkan LogoutResponse:</p>

                    <pre><code>package responses

import "tokogo/models"

// RegisterResponse struct untuk response register
type RegisterResponse struct {
    User  UserResponse \`json:"user"\`
    Token string       \`json:"token"\`
}

// LoginResponse struct untuk response login
type LoginResponse struct {
    User  UserResponse \`json:"user"\`
    Token string       \`json:"token"\`
}

// LogoutResponse struct untuk response logout
type LogoutResponse struct {
    Message string \`json:"message"\`
}

// UserResponse struct untuk response user (tanpa password)
type UserResponse struct {
    ID        uint   \`json:"id"\`
    Name      string \`json:"name"\`
    Email     string \`json:"email"\`
    Role      string \`json:"role"\`
    CreatedAt string \`json:"created_at"\`
}

// ErrorResponse struct untuk response error
type ErrorResponse struct {
    Error   string \`json:"error"\`
    Message string \`json:"message"\`
}

// SuccessResponse struct untuk response sukses
type SuccessResponse struct {
    Message string      \`json:"message"\`
    Data    interface{} \`json:"data,omitempty"\`
}

// ConvertUserToResponse mengkonversi User model ke UserResponse
func ConvertUserToResponse(user models.User) UserResponse {
    return UserResponse{
        ID:        user.ID,
        Name:      user.Name,
        Email:     user.Email,
        Role:      user.Role,
        CreatedAt: user.CreatedAt.Format("2006-01-02 15:04:05"),
    }
}</code></pre>

                    <h4>Penjelasan LogoutResponse:</h4>
                    <ul>
                        <li><strong>LogoutResponse:</strong> Response sederhana untuk logout yang berisi message sukses</li>
                        <li><strong>Stateless Design:</strong> Tidak menyimpan state logout di server</li>
                        <li><strong>Client Responsibility:</strong> Client bertanggung jawab menghapus token</li>
                    </ul>

                    <h3>📝 Langkah 4: Update Auth Repository untuk GetUserByID</h3>
                    <p>Update file <code>repositories/auth_repository.go</code> untuk menambahkan GetUserByID:</p>

                    <pre><code>package repositories

import (
    "errors"
    "tokogo/config"
    "tokogo/models"

    "gorm.io/gorm"
)

type AuthRepository struct {
    db *gorm.DB
}

// NewAuthRepository membuat instance baru AuthRepository
func NewAuthRepository() *AuthRepository {
    return &AuthRepository{
        db: config.GetDB(),
    }
}

// CreateUser menyimpan user baru ke database
func (r *AuthRepository) CreateUser(user *models.User) error {
    return r.db.Create(user).Error
}

// GetUserByEmail mengambil user berdasarkan email (untuk cek duplikasi)
func (r *AuthRepository) GetUserByEmail(email string) (*models.User, error) {
    var user models.User
    err := r.db.Where("email = ?", email).First(&user).Error
    
    if err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, errors.New("user not found")
        }
        return nil, err
    }
    
    return &user, nil
}

// GetUserByID mengambil user berdasarkan ID
func (r *AuthRepository) GetUserByID(id uint) (*models.User, error) {
    var user models.User
    err := r.db.Where("id = ?", id).First(&user).Error
    
    if err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, errors.New("user not found")
        }
        return nil, err
    }
    
    return &user, nil
}</code></pre>

                    <h4>Penjelasan GetUserByID:</h4>
                    <ul>
                        <li><strong>GetUserByID:</strong> Function untuk mengambil user berdasarkan ID</li>
                        <li><strong>Error Handling:</strong> Menangani error jika user tidak ditemukan</li>
                        <li><strong>GORM Query:</strong> Menggunakan Where clause untuk mencari berdasarkan ID</li>
                    </ul>

                    <h3>📝 Langkah 5: Update Auth Handler untuk Logout dan GetProfile</h3>
                    <p>Update file <code>handlers/auth_handler.go</code> untuk menambahkan Logout dan GetProfile handler:</p>

                    <pre><code>package handlers

import (
    "net/http"
    "strconv"
    "tokogo/requests"
    "tokogo/responses"
    "tokogo/services"

    "github.com/gin-gonic/gin"
)

type AuthHandler struct {
    authService *services.AuthService
}

// NewAuthHandler membuat instance baru AuthHandler
func NewAuthHandler() *AuthHandler {
    return &AuthHandler{
        authService: services.NewAuthService(),
    }
}

// Register handler untuk registrasi user baru
func (h *AuthHandler) Register(c *gin.Context) {
    var req requests.RegisterRequest

    // Bind dan validasi request
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Validasi menggunakan method Validate()
    if err := req.Validate(); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Panggil service untuk register
    registerResponse, err := h.authService.Register(req)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "register_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusCreated, responses.SuccessResponse{
        Message: "User registered successfully",
        Data:    registerResponse,
    })
}

// Login handler untuk login user
func (h *AuthHandler) Login(c *gin.Context) {
    var req requests.LoginRequest

    // Bind dan validasi request
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Validasi menggunakan method Validate()
    if err := req.Validate(); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Panggil service untuk login
    loginResponse, err := h.authService.Login(req)
    if err != nil {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "login_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Login successful",
        Data:    loginResponse,
    })
}

// Logout handler untuk logout user
func (h *AuthHandler) Logout(c *gin.Context) {
    // Ambil user ID dari context (setelah AuthMiddleware)
    userID, exists := c.Get("user_id")
    if !exists {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "unauthorized",
            Message: "User not authenticated",
        })
        return
    }

    // Panggil service untuk logout
    logoutResponse, err := h.authService.Logout(userID.(uint))
    if err != nil {
        c.JSON(http.StatusInternalServerError, responses.ErrorResponse{
            Error:   "logout_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, logoutResponse)
}

// GetProfile handler untuk mengambil profile user
func (h *AuthHandler) GetProfile(c *gin.Context) {
    // Ambil user ID dari context (setelah AuthMiddleware)
    userID, exists := c.Get("user_id")
    if !exists {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "unauthorized",
            Message: "User not authenticated",
        })
        return
    }

    // Panggil service untuk get profile
    userResponse, err := h.authService.GetProfile(userID.(uint))
    if err != nil {
        c.JSON(http.StatusNotFound, responses.ErrorResponse{
            Error:   "user_not_found",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Profile retrieved successfully",
        Data:    userResponse,
    })
}</code></pre>

                    <h4>Penjelasan Handler Baru:</h4>
                    <ul>
                        <li><strong>Logout Handler:</strong> Menggunakan user_id dari context untuk logout</li>
                        <li><strong>GetProfile Handler:</strong> Mengambil profile user berdasarkan ID dari context</li>
                        <li><strong>Context Usage:</strong> Menggunakan data user yang sudah di-set oleh middleware</li>
                        <li><strong>Error Handling:</strong> Menangani error jika user tidak authenticated</li>
                    </ul>

                    <h3>📝 Langkah 6: Update Main.go untuk Logout dan Protected Routes</h3>
                    <p>Update file <code>main.go</code> untuk menambahkan route logout dan protected routes:</p>

                    <pre><code>package main

import (
    "log"
    "tokogo/config"
    "tokogo/handlers"
    "tokogo/middlewares"

    "github.com/gin-contrib/cors"
    "github.com/gin-gonic/gin"
    "github.com/joho/godotenv"
)

func main() {
    // Load environment variables
    if err := godotenv.Load(); err != nil {
        log.Println("No .env file found, using system environment variables")
    }

    // Initialize database
    config.InitDB()

    // Setup Gin router
    r := gin.Default()

    // CORS middleware
    r.Use(cors.New(cors.Config{
        AllowOrigins:     []string{"*"},
        AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
        AllowHeaders:     []string{"*"},
        ExposeHeaders:    []string{"Content-Length"},
        AllowCredentials: true,
    }))

    // Initialize handlers
    authHandler := handlers.NewAuthHandler()

    // Public routes (tidak perlu authentication)
    api := r.Group("/api/v1")
    {
        // Auth routes
        auth := api.Group("/auth")
        {
            auth.POST("/register", authHandler.Register)
            auth.POST("/login", authHandler.Login)
        }
    }

    // Protected routes (perlu authentication)
    protected := r.Group("/api/v1")
    protected.Use(middlewares.AuthMiddleware())
    {
        // Auth protected routes
        auth := protected.Group("/auth")
        {
            auth.POST("/logout", authHandler.Logout)
            auth.GET("/profile", authHandler.GetProfile)
        }

        // Admin routes (perlu admin role)
        admin := protected.Group("/admin")
        admin.Use(middlewares.AdminMiddleware())
        {
            admin.GET("/dashboard", func(c *gin.Context) {
                c.JSON(200, gin.H{
                    "message": "Welcome to admin dashboard",
                    "user_id": c.GetUint("user_id"),
                })
            })
        }
    }

    // Start server
    port := config.GetEnv("SERVER_PORT", "8080")
    log.Printf("Server starting on port %s", port)
    r.Run(":" + port)
}</code></pre>

                    <h4>Penjelasan Main.go Update:</h4>
                    <ul>
                        <li><strong>Protected Routes:</strong> Menggunakan AuthMiddleware untuk melindungi endpoint</li>
                        <li><strong>Logout Route:</strong> POST /api/v1/auth/logout (protected)</li>
                        <li><strong>Profile Route:</strong> GET /api/v1/auth/profile (protected)</li>
                        <li><strong>Admin Routes:</strong> Menggunakan AdminMiddleware untuk role admin</li>
                        <li><strong>Middleware Chain:</strong> AuthMiddleware -> AdminMiddleware untuk admin routes</li>
                    </ul>

                    <h3>🧪 Testing API Logout dan Protected Routes</h3>
                    <p>Sekarang mari kita test API logout dan protected routes yang sudah kita buat:</p>

                    <h4>1. Login User (untuk mendapatkan token)</h4>
                    <pre><code>POST http://localhost:8080/api/v1/auth/login
Content-Type: application/json

{
    "email": "john@example.com",
    "password": "password123"
}</code></pre>

                    <h4>2. Get Profile (Protected Route)</h4>
                    <pre><code>GET http://localhost:8080/api/v1/auth/profile
Authorization: Bearer {your_jwt_token}</code></pre>

                    <h4>Response Sukses (200 OK):</h4>
                    <pre><code>{
    "message": "Profile retrieved successfully",
    "data": {
        "id": 1,
        "name": "johndoe",
        "email": "john@example.com",
        "role": "customer",
        "created_at": "2024-01-15 10:30:00"
    }
}</code></pre>

                    <h4>3. Logout User</h4>
                    <pre><code>POST http://localhost:8080/api/v1/auth/logout
Authorization: Bearer {your_jwt_token}</code></pre>

                    <h4>Response Sukses (200 OK):</h4>
                    <pre><code>{
    "message": "Logout successful"
}</code></pre>

                    <h4>4. Test Protected Route tanpa Token</h4>
                    <pre><code>GET http://localhost:8080/api/v1/auth/profile</code></pre>

                    <h4>Response Error (401 Unauthorized):</h4>
                    <pre><code>{
    "error": "unauthorized",
    "message": "Authorization header is required"
}</code></pre>

                    <h4>5. Test Admin Route (Customer Role)</h4>
                    <pre><code>GET http://localhost:8080/api/v1/admin/dashboard
Authorization: Bearer {customer_jwt_token}</code></pre>

                    <h4>Response Error (403 Forbidden):</h4>
                    <pre><code>{
    "error": "forbidden",
    "message": "Admin access required"
}</code></pre>

                    <h3>✅ Checklist Implementasi Logout</h3>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>File yang Harus Dibuat:</h4>
                        <ul>
                            <li>✅ middlewares/auth_middleware.go (AuthMiddleware, AdminMiddleware)</li>
                        </ul>
                        
                        <h4>File yang Harus Diupdate:</h4>
                        <ul>
                            <li>✅ responses/auth_response.go (LogoutResponse)</li>
                            <li>✅ repositories/auth_repository.go (GetUserByID)</li>
                            <li>✅ services/auth_service.go (Logout, GetProfile)</li>
                            <li>✅ handlers/auth_handler.go (Logout, GetProfile)</li>
                            <li>✅ main.go (Protected routes, middleware)</li>
                        </ul>
                    </div>

                    <h3>🚀 Cara Menjalankan</h3>
                    <ol>
                        <li>Pastikan MySQL sudah berjalan</li>
                        <li>Pastikan database 'tokogo' sudah dibuat</li>
                        <li>Pastikan ada user yang sudah terdaftar dan bisa login</li>
                        <li>Jalankan: <code>go run main.go</code></li>
                        <li>Test dengan Postman atau curl</li>
                    </ol>

                    <h3>🎯 Fitur Logout yang Sudah Diimplementasikan</h3>
                    <ul>
                        <li>✅ User Logout dengan JWT token validation</li>
                        <li>✅ Middleware Authentication untuk protected routes</li>
                        <li>✅ Middleware Admin untuk admin-only routes</li>
                        <li>✅ Get Profile endpoint yang protected</li>
                        <li>✅ Admin Dashboard endpoint</li>
                        <li>✅ Error handling yang proper</li>
                        <li>✅ Response format yang konsisten</li>
                    </ul>

                    <h3>🔒 Keamanan yang Diimplementasikan</h3>
                    <ul>
                        <li>✅ JWT token validation di middleware</li>
                        <li>✅ Authorization header validation</li>
                        <li>✅ Role-based access control (AdminMiddleware)</li>
                        <li>✅ Protected routes dengan authentication</li>
                        <li>✅ Context-based user information</li>
                        <li>✅ Stateless logout design</li>
                        <li>✅ Proper error messages untuk security</li>
                    </ul>

                    <h3>🎉 Selamat!</h3>
                    <p>Anda telah berhasil mengimplementasikan modul Logout yang lengkap! Sistem authentication sudah lengkap dengan Register, Login, Logout, dan middleware protection. Sistem sudah siap untuk digunakan dan dapat diintegrasikan dengan frontend aplikasi.</p>

                    <div style="text-align: center; margin: 3rem 0;">
                        <div style="background: #f8f9fa; border: 1px solid #dee2e6; color: #2c3e50; padding: 2rem; border-radius: 5px; display: inline-block;">
                            <h3 style="color: #2c3e50; margin-bottom: 1rem;">🎯 Sistem Authentication Lengkap!</h3>
                            <p style="color: #495057; margin-bottom: 0;">Sekarang Anda memiliki sistem authentication yang lengkap dengan Register, Login, Logout, dan middleware protection. Siap untuk melanjutkan ke modul berikutnya!</p>
                        </div>
                    </div>
                `
            },
            {
                id: 'chapter9',
                title: 'Bab 9: Relaksasi & Review Pembelajaran - Modul Authentication',
                meta: 'Halaman 9 dari 50 • Dibaca 15 menit',
                content: `
                    <h2>Bab 9: Relaksasi & Review Pembelajaran - Modul Authentication</h2>
                    <p>Selamat! Anda telah berhasil menyelesaikan modul Authentication yang lengkap (Bab 6-8). Sekarang saatnya untuk beristirahat sejenak dan mengulas kembali semua yang telah dipelajari tentang sistem authentication. Bab ini dirancang untuk membantu otak Anda mengkonsolidasikan pengetahuan authentication yang baru saja diperoleh.</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">🎯 Pencapaian yang Luar Biasa!</h3>
                        <p style="color: #495057; margin-bottom: 0;">Anda telah berhasil membangun sistem authentication yang lengkap dengan Register, Login, Logout, dan middleware protection. Ini adalah pencapaian yang sangat membanggakan!</p>
                    </div>

                    <h3>Ringkasan Pembelajaran Bab 6-8</h3>
                    <p>Sebelum masuk ke pertanyaan review, mari kita ingat kembali perjalanan pembelajaran authentication yang telah kita lalui:</p>

                    <h4>Bab 6: Modul Authentication - Register</h4>
                    <ul>
                        <li>✅ User registration dengan validasi input</li>
                        <li>✅ Password hashing dengan bcrypt</li>
                        <li>✅ Email uniqueness validation</li>
                        <li>✅ Konfirmasi password untuk keamanan</li>
                        <li>✅ JWT token generation setelah registrasi</li>
                        <li>✅ Response format yang konsisten</li>
                        <li>✅ Error handling yang proper</li>
                    </ul>

                    <h4>Bab 7: Modul Authentication - Login</h4>
                    <ul>
                        <li>✅ User login dengan validasi email/password</li>
                        <li>✅ Password verification dengan bcrypt</li>
                        <li>✅ JWT token generation setelah login sukses</li>
                        <li>✅ Input validation dengan go-playground/validator</li>
                        <li>✅ Error handling untuk invalid credentials</li>
                        <li>✅ Security: Error message yang sama untuk keamanan</li>
                        <li>✅ Response format yang konsisten</li>
                    </ul>

                    <h4>Bab 8: Modul Authentication - Logout</h4>
                    <ul>
                        <li>✅ User logout dengan JWT token validation</li>
                        <li>✅ Middleware Authentication untuk protected routes</li>
                        <li>✅ Middleware Admin untuk role-based access control</li>
                        <li>✅ Get Profile endpoint yang protected</li>
                        <li>✅ Admin Dashboard endpoint</li>
                        <li>✅ Authorization header validation</li>
                        <li>✅ Context-based user information</li>
                    </ul>

                    <h3>Pertanyaan Review Interaktif</h3>
                    <p>Mari kita uji pemahaman Anda dengan pertanyaan-pertanyaan yang dirancang untuk mengaktifkan kembali memori dan memperkuat pembelajaran authentication:</p>

                    <div style="background: #f8f9fa; border-left: 4px solid #3498db; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Bagian A: Konsep Dasar Authentication</h4>
                        
                        <p><strong>1. Mengapa kita menggunakan bcrypt untuk hashing password?</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: bcrypt adalah algoritma hashing yang aman dan slow, membuat brute force attack menjadi sangat sulit dan memakan waktu lama.</p>
                        
                        <p><strong>2. Apa perbedaan antara JWT token dan session-based authentication?</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: JWT adalah stateless (tidak menyimpan state di server), sementara session-based menyimpan state di server. JWT lebih scalable untuk distributed systems.</p>
                        
                        <p><strong>3. Mengapa kita memvalidasi konfirmasi password di sisi server?</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: Validasi di server memastikan keamanan dan mencegah user salah ketik password, meskipun sudah ada validasi di client side.</p>
                    </div>

                    <div style="background: #f8f9fa; border-left: 4px solid #e74c3c; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Bagian B: Middleware & Security</h4>
                        
                        <p><strong>4. Bagaimana cara kerja AuthMiddleware dalam melindungi endpoint?</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: AuthMiddleware memvalidasi JWT token dari Authorization header, mengekstrak user info, dan menyimpannya di context untuk digunakan di handler.</p>
                        
                        <p><strong>5. Apa perbedaan antara AuthMiddleware dan AdminMiddleware?</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: AuthMiddleware memvalidasi token dan set user info, sementara AdminMiddleware memvalidasi apakah user memiliki role admin.</p>
                        
                        <p><strong>6. Mengapa kita menggunakan format "Bearer {token}" untuk Authorization header?</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: Ini adalah standar OAuth 2.0 yang memisahkan tipe authentication (Bearer) dengan token, memudahkan parsing dan validasi.</p>
                    </div>

                    <div style="background: #f8f9fa; border-left: 4px solid #f39c12; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Bagian C: Arsitektur & Best Practices</h4>
                        
                        <p><strong>7. Jelaskan alur authentication flow dari register sampai logout!</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: Register → Hash password → Save user → Generate JWT → Login → Validate credentials → Generate JWT → Access protected routes → Logout → Remove token (client-side).</p>
                        
                        <p><strong>8. Mengapa kita menggunakan layered architecture untuk authentication?</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: Separation of concerns, maintainability, testability, dan scalability. Setiap layer memiliki tanggung jawab yang jelas.</p>
                        
                        <p><strong>9. Bagaimana cara implementasi stateless logout dengan JWT?</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: Server memberikan response sukses, client menghapus token dari storage. Untuk production, bisa implementasi token blacklist.</p>
                    </div>

                    <div style="background: #f8f9fa; border-left: 4px solid #27ae60; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Bagian D: Error Handling & Security</h4>
                        
                        <p><strong>10. Mengapa kita memberikan error message yang sama untuk "invalid email or password"?</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: Untuk keamanan, mencegah attacker mengetahui apakah email terdaftar atau tidak, menghindari user enumeration attack.</p>
                        
                        <p><strong>11. Apa yang terjadi jika JWT token expired?</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: ValidateToken akan return error, middleware akan mengembalikan 401 Unauthorized, client harus login ulang.</p>
                        
                        <p><strong>12. Bagaimana cara mengimplementasikan role-based access control?</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: Menggunakan AdminMiddleware yang memvalidasi role dari JWT claims, memberikan akses berbeda berdasarkan role user.</p>
                    </div>

                    <h3>Latihan Praktis</h3>
                    <p>Mari kita lakukan beberapa latihan praktis untuk memperkuat pemahaman:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Latihan 1: Analisis Security</h4>
                        <p>Analisis kode authentication yang sudah dibuat dan identifikasi:</p>
                        <ul>
                            <li>✅ Password hashing dengan bcrypt</li>
                            <li>✅ JWT token dengan expiration</li>
                            <li>✅ Input validation</li>
                            <li>✅ SQL injection protection (GORM)</li>
                            <li>✅ CORS configuration</li>
                            <li>✅ Generic error messages</li>
                        </ul>
                    </div>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Latihan 2: Testing Scenarios</h4>
                        <p>Test berbagai skenario authentication:</p>
                        <ul>
                            <li>✅ Register dengan email yang sudah ada</li>
                            <li>✅ Login dengan password yang salah</li>
                            <li>✅ Akses protected route tanpa token</li>
                            <li>✅ Akses admin route dengan customer role</li>
                            <li>✅ Logout dengan token yang valid</li>
                        </ul>
                    </div>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Latihan 3: Code Review</h4>
                        <p>Review kode authentication dan identifikasi:</p>
                        <ul>
                            <li>✅ Error handling yang konsisten</li>
                            <li>✅ Response format yang seragam</li>
                            <li>✅ Middleware yang reusable</li>
                            <li>✅ Separation of concerns</li>
                            <li>✅ Security best practices</li>
                        </ul>
                    </div>

                    <h3>Teknik Memori untuk Authentication</h3>
                    <p>Berikut adalah teknik memori untuk mengingat konsep-konsep authentication:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Akronim: AUTH-FLOW</h4>
                        <ul>
                            <li><strong>A</strong>uthentication - Verifikasi identitas user</li>
                            <li><strong>U</strong>ser Registration - Pendaftaran user baru</li>
                            <li><strong>T</strong>oken Generation - Pembuatan JWT token</li>
                            <li><strong>H</strong>ashing - Password hashing dengan bcrypt</li>
                            <li><strong>F</strong>low Control - Middleware untuk kontrol akses</li>
                            <li><strong>L</strong>ogin/Logout - Proses masuk dan keluar</li>
                            <li><strong>O</strong>wnership - User ownership data</li>
                            <li><strong>W</strong>eb Security - Keamanan web application</li>
                        </ul>
                    </div>

                    <h3>Self-Assessment</h3>
                    <p>Evaluasi pemahaman Anda tentang modul Authentication:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Kemampuan yang Harus Dikuasai:</h4>
                        <ul>
                            <li>✅ Memahami konsep authentication dan authorization</li>
                            <li>✅ Mampu implementasi user registration dengan validasi</li>
                            <li>✅ Mampu implementasi user login dengan JWT</li>
                            <li>✅ Mampu implementasi user logout</li>
                            <li>✅ Mampu membuat middleware authentication</li>
                            <li>✅ Mampu implementasi role-based access control</li>
                            <li>✅ Mampu testing API authentication</li>
                            <li>✅ Memahami security best practices</li>
                        </ul>
                    </div>

                    <h3>Tips untuk Pengembangan Selanjutnya</h3>
                    <p>Berikut adalah tips untuk mengembangkan sistem authentication lebih lanjut:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Fitur Tambahan yang Bisa Dikembangkan:</h4>
                        <ul>
                            <li>🔐 Password reset functionality</li>
                            <li>🔐 Email verification</li>
                            <li>🔐 Two-factor authentication (2FA)</li>
                            <li>🔐 Refresh token mechanism</li>
                            <li>🔐 Rate limiting untuk login attempts</li>
                            <li>🔐 Account lockout setelah failed attempts</li>
                            <li>🔐 Audit logging untuk security</li>
                            <li>🔐 OAuth integration (Google, Facebook)</li>
                        </ul>
                    </div>

                    <h3>Refleksi Pembelajaran</h3>
                    <p>Mari kita refleksikan apa yang telah dipelajari:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Pencapaian yang Membanggakan:</h4>
                        <ul>
                            <li>🎯 Berhasil membangun sistem authentication yang lengkap</li>
                            <li>🎯 Memahami konsep JWT dan stateless authentication</li>
                            <li>🎯 Mampu implementasi middleware untuk security</li>
                            <li>🎯 Memahami role-based access control</li>
                            <li>🎯 Mampu testing API dengan Postman</li>
                            <li>🎯 Memahami security best practices</li>
                        </ul>
                    </div>

                 

                    <h3>Kata-kata Motivasi</h3>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; margin: 2rem 0; border-radius: 5px; text-align: center;">
                        <p style="font-size: 1.1rem; color: #2c3e50; font-style: italic; margin-bottom: 0;">
                            "Authentication adalah fondasi keamanan aplikasi. Dengan menguasai konsep ini, Anda telah membangun dasar yang kuat untuk mengembangkan aplikasi yang aman dan terpercaya. Teruslah belajar dan eksplorasi fitur-fitur keamanan yang lebih advanced!"
                        </p>
                    </div>

                    <h3>Selamat!</h3>
                    <p>Anda telah berhasil menyelesaikan modul Authentication yang lengkap! Ini adalah pencapaian yang luar biasa. Sistem authentication yang Anda buat sudah siap untuk production dan dapat diintegrasikan dengan frontend aplikasi.</p>

                    <div style="text-align: center; margin: 3rem 0;">
                        <div style="background: #f8f9fa; border: 1px solid #dee2e6; color: #2c3e50; padding: 2rem; border-radius: 5px; display: inline-block;">
                            <h3 style="color: #2c3e50; margin-bottom: 1rem;">🎯 Siap untuk Modul Selanjutnya?</h3>
                            <p style="color: #495057; margin-bottom: 0;">Dengan sistem authentication yang lengkap, Anda siap untuk melanjutkan ke modul berikutnya seperti Product Management atau Shopping Cart!</p>
                        </div>
                    </div>
                `
            },
            {
                id: 'chapter10',
                title: 'Bab 10: Modul CRUD Kategori - Role Admin',
                meta: 'Halaman 10 dari 50 • Dibaca 12 menit',
                content: `
                    <h2>📂 Bab 10: Modul CRUD Kategori - Role Admin</h2>
                    <p>Selamat! Sekarang kita akan membuat modul CRUD (Create, Read, Update, Delete) untuk Kategori yang hanya bisa diakses oleh admin. Di bab ini, kita akan mengimplementasikan sistem manajemen kategori dengan role-based access control.</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">🎯 Apa yang Akan Kita Buat di Bab Ini?</h3>
                        <p style="color: #495057; margin-bottom: 0;">Kita akan membuat sistem CRUD kategori yang lengkap dengan Create, Read, Update, Delete operations. Semua endpoint hanya bisa diakses oleh admin. Setelah selesai, kita akan test menggunakan Postman.</p>
                    </div>

                    <h3>📋 Prasyarat</h3>
                    <p>Sebelum memulai, pastikan Anda sudah menyelesaikan:</p>
                    <ul>
                        <li>✅ Bab 6-8: Modul Authentication (Register, Login, Logout)</li>
                        <li>✅ Bab 9: Review Pembelajaran Authentication</li>
                        <li>✅ Middleware authentication sudah berfungsi</li>
                        <li>✅ AdminMiddleware sudah diimplementasikan</li>
                    </ul>

                    <h3>📊 Database Schema Kategori</h3>
                    <p>Berdasarkan requirement yang diberikan, berikut adalah struktur tabel kategori:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Table: categories</h4>
                        <table style="width: 100%; border-collapse: collapse; margin-top: 1rem;">
                            <thead>
                                <tr style="background: #e9ecef;">
                                    <th style="border: 1px solid #dee2e6; padding: 0.75rem; text-align: left;">Field</th>
                                    <th style="border: 1px solid #dee2e6; padding: 0.75rem; text-align: left;">Type</th>
                                    <th style="border: 1px solid #dee2e6; padding: 0.75rem; text-align: left;">Notes</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">id</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">BIGINT PK</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Auto Increment</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">name</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">VARCHAR</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Nama kategori</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">slug</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">VARCHAR</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">URL-friendly identifier</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">created_at</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">TIMESTAMP</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Waktu dibuat</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">updated_at</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">TIMESTAMP</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Waktu diupdate</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">deleted_at</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">TIMESTAMP</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Soft delete</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <h3>📝 Langkah 1: Buat Model Category</h3>
                    <p>Buat file <code>models/category.go</code> untuk model kategori:</p>

                    <pre><code>package models

import (
    "time"
    "strings"
    "gorm.io/gorm"
)

type Category struct {
    ID        uint           \`gorm:"primaryKey;column:id;type:BIGINT UNSIGNED AUTO_INCREMENT" json:"id"\`
    Name      string         \`gorm:"column:name;type:VARCHAR(255);not null" json:"name"\`
    Slug      string         \`gorm:"column:slug;type:VARCHAR(255);uniqueIndex;not null" json:"slug"\`
    CreatedAt time.Time      \`gorm:"column:created_at;type:TIMESTAMP DEFAULT CURRENT_TIMESTAMP" json:"created_at"\`
    UpdatedAt time.Time      \`gorm:"column:updated_at;type:TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP" json:"updated_at"\`
    DeletedAt gorm.DeletedAt \`gorm:"column:deleted_at;type:TIMESTAMP NULL;index" json:"-"\`
}

// TableName mengembalikan nama tabel untuk model Category
func (Category) TableName() string {
    return "categories"
}

// GenerateSlug menghasilkan slug dari nama kategori
func (c *Category) GenerateSlug() {
    slug := strings.ToLower(c.Name)
    slug = strings.ReplaceAll(slug, " ", "-")
    slug = strings.ReplaceAll(slug, "_", "-")
    c.Slug = slug
}

// BeforeCreate hook untuk generate slug sebelum create
func (c *Category) BeforeCreate(tx *gorm.DB) error {
    c.GenerateSlug()
    return nil
}

// BeforeUpdate hook untuk generate slug sebelum update
func (c *Category) BeforeUpdate(tx *gorm.DB) error {
    c.GenerateSlug()
    return nil
}</code></pre>

                    <h4>Penjelasan Model Category:</h4>
                    <ul>
                        <li><strong>Struct Fields:</strong> Sesuai dengan database schema yang diberikan</li>
                        <li><strong>GORM Tags:</strong> Mapping ke database dengan tipe data yang tepat</li>
                        <li><strong>GenerateSlug:</strong> Function untuk membuat slug dari nama kategori</li>
                        <li><strong>Hooks:</strong> BeforeCreate dan BeforeUpdate untuk auto-generate slug</li>
                        <li><strong>Soft Delete:</strong> Menggunakan gorm.DeletedAt untuk soft delete</li>
                    </ul>

                    <h3>📝 Langkah 2: Buat Request Struct untuk Category</h3>
                    <p>Buat file <code>requests/category_request.go</code> untuk validasi input kategori:</p>

                    <pre><code>package requests

import (
    "errors"
    "github.com/go-playground/validator/v10"
)

// CreateCategoryRequest represents the request structure for creating category
type CreateCategoryRequest struct {
    Name string \`json:"name" validate:"required,min=2,max=100"\`
}

// UpdateCategoryRequest represents the request structure for updating category
type UpdateCategoryRequest struct {
    Name string \`json:"name" validate:"required,min=2,max=100"\`
}

// Validate validates the CreateCategoryRequest using the validator
func (r *CreateCategoryRequest) Validate() error {
    validate := validator.New()
    
    // Validasi struct fields
    if err := validate.Struct(r); err != nil {
        return err
    }
    
    // Validasi custom: nama tidak boleh kosong setelah trim
    if strings.TrimSpace(r.Name) == "" {
        return errors.New("name cannot be empty")
    }
    
    return nil
}

// Validate validates the UpdateCategoryRequest using the validator
func (r *UpdateCategoryRequest) Validate() error {
    validate := validator.New()
    
    // Validasi struct fields
    if err := validate.Struct(r); err != nil {
        return err
    }
    
    // Validasi custom: nama tidak boleh kosong setelah trim
    if strings.TrimSpace(r.Name) == "" {
        return errors.New("name cannot be empty")
    }
    
    return nil
}</code></pre>

                    <h4>Penjelasan Request Struct:</h4>
                    <ul>
                        <li><strong>CreateCategoryRequest:</strong> Untuk membuat kategori baru</li>
                        <li><strong>UpdateCategoryRequest:</strong> Untuk update kategori yang sudah ada</li>
                        <li><strong>Validation:</strong> Nama minimal 2 karakter, maksimal 100 karakter</li>
                        <li><strong>Custom Validation:</strong> Nama tidak boleh kosong setelah trim</li>
                    </ul>

                    <h3>📝 Langkah 3: Buat Response Struct untuk Category</h3>
                    <p>Buat file <code>responses/category_response.go</code> untuk format response kategori:</p>

                    <pre><code>package responses

import "tokogo/models"

// CategoryResponse struct untuk response category
type CategoryResponse struct {
    ID        uint   \`json:"id"\`
    Name      string \`json:"name"\`
    Slug      string \`json:"slug"\`
    CreatedAt string \`json:"created_at"\`
    UpdatedAt string \`json:"updated_at"\`
}

// CategoryListResponse struct untuk response list category
type CategoryListResponse struct {
    Categories []CategoryResponse \`json:"categories"\`
    Total      int                \`json:"total"\`
    Page       int                \`json:"page"\`
    Limit      int                \`json:"limit"\`
}

// ConvertCategoryToResponse mengkonversi Category model ke CategoryResponse
func ConvertCategoryToResponse(category models.Category) CategoryResponse {
    return CategoryResponse{
        ID:        category.ID,
        Name:      category.Name,
        Slug:      category.Slug,
        CreatedAt: category.CreatedAt.Format("2006-01-02 15:04:05"),
        UpdatedAt: category.UpdatedAt.Format("2006-01-02 15:04:05"),
    }
}

// ConvertCategoriesToResponse mengkonversi slice Category ke slice CategoryResponse
func ConvertCategoriesToResponse(categories []models.Category) []CategoryResponse {
    var responses []CategoryResponse
    for _, category := range categories {
        responses = append(responses, ConvertCategoryToResponse(category))
    }
    return responses
}</code></pre>

                    <h4>Penjelasan Response Struct:</h4>
                    <ul>
                        <li><strong>CategoryResponse:</strong> Response untuk single category</li>
                        <li><strong>CategoryListResponse:</strong> Response untuk list category dengan pagination</li>
                        <li><strong>Convert Functions:</strong> Helper functions untuk konversi model ke response</li>
                        <li><strong>Date Formatting:</strong> Format tanggal yang konsisten</li>
                    </ul>

                    <h3>📝 Langkah 4: Buat Category Repository</h3>
                    <p>Buat file <code>repositories/category_repository.go</code> untuk database operations:</p>

                    <pre><code>package repositories

import (
    "errors"
    "tokogo/config"
    "tokogo/models"

    "gorm.io/gorm"
)

type CategoryRepository struct {
    db *gorm.DB
}

// NewCategoryRepository membuat instance baru CategoryRepository
func NewCategoryRepository() *CategoryRepository {
    return &CategoryRepository{
        db: config.GetDB(),
    }
}

// CreateCategory menyimpan category baru ke database
func (r *CategoryRepository) CreateCategory(category *models.Category) error {
    return r.db.Create(category).Error
}

// GetCategoryByID mengambil category berdasarkan ID
func (r *CategoryRepository) GetCategoryByID(id uint) (*models.Category, error) {
    var category models.Category
    err := r.db.Where("id = ?", id).First(&category).Error
    
    if err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, errors.New("category not found")
        }
        return nil, err
    }
    
    return &category, nil
}

// GetCategoryBySlug mengambil category berdasarkan slug
func (r *CategoryRepository) GetCategoryBySlug(slug string) (*models.Category, error) {
    var category models.Category
    err := r.db.Where("slug = ?", slug).First(&category).Error
    
    if err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, errors.New("category not found")
        }
        return nil, err
    }
    
    return &category, nil
}

// GetAllCategories mengambil semua categories dengan pagination
func (r *CategoryRepository) GetAllCategories(page, limit int) ([]models.Category, int64, error) {
    var categories []models.Category
    var total int64

    // Hitung total records
    if err := r.db.Model(&models.Category{}).Count(&total).Error; err != nil {
        return nil, 0, err
    }

    // Ambil data dengan pagination
    offset := (page - 1) * limit
    err := r.db.Offset(offset).Limit(limit).Order("created_at DESC").Find(&categories).Error
    
    return categories, total, err
}

// UpdateCategory mengupdate category berdasarkan ID
func (r *CategoryRepository) UpdateCategory(id uint, category *models.Category) error {
    return r.db.Where("id = ?", id).Updates(category).Error
}

// DeleteCategory menghapus category berdasarkan ID (soft delete)
func (r *CategoryRepository) DeleteCategory(id uint) error {
    return r.db.Where("id = ?", id).Delete(&models.Category{}).Error
}

// CheckCategoryExists mengecek apakah category dengan nama tertentu sudah ada
func (r *CategoryRepository) CheckCategoryExists(name string, excludeID uint) (bool, error) {
    var count int64
    query := r.db.Model(&models.Category{}).Where("name = ?", name)
    
    if excludeID > 0 {
        query = query.Where("id != ?", excludeID)
    }
    
    err := query.Count(&count).Error
    return count > 0, err
}</code></pre>

                    <h4>Penjelasan Category Repository:</h4>
                    <ul>
                        <li><strong>CRUD Operations:</strong> Create, Read, Update, Delete category</li>
                        <li><strong>Pagination:</strong> GetAllCategories dengan pagination support</li>
                        <li><strong>Soft Delete:</strong> DeleteCategory menggunakan soft delete</li>
                        <li><strong>Validation:</strong> CheckCategoryExists untuk cek duplikasi nama</li>
                        <li><strong>Error Handling:</strong> Proper error handling untuk setiap operation</li>
                    </ul>

                    <h3>📝 Langkah 5: Buat Category Service</h3>
                    <p>Buat file <code>services/category_service.go</code> untuk business logic kategori:</p>

                    <pre><code>package services

import (
    "errors"
    "tokogo/models"
    "tokogo/repositories"
    "tokogo/requests"
    "tokogo/responses"
)

type CategoryService struct {
    categoryRepo *repositories.CategoryRepository
}

// NewCategoryService membuat instance baru CategoryService
func NewCategoryService() *CategoryService {
    return &CategoryService{
        categoryRepo: repositories.NewCategoryRepository(),
    }
}

// CreateCategory membuat category baru
func (s *CategoryService) CreateCategory(req requests.CreateCategoryRequest) (*responses.CategoryResponse, error) {
    // Cek apakah nama category sudah ada
    exists, err := s.categoryRepo.CheckCategoryExists(req.Name, 0)
    if err != nil {
        return nil, errors.New("failed to check category existence")
    }
    if exists {
        return nil, errors.New("category name already exists")
    }

    // Buat category baru
    category := &models.Category{
        Name: req.Name,
    }

    // Simpan ke database
    if err := s.categoryRepo.CreateCategory(category); err != nil {
        return nil, errors.New("failed to create category")
    }

    // Return response
    return &responses.CategoryResponse{
        ID:        category.ID,
        Name:      category.Name,
        Slug:      category.Slug,
        CreatedAt: category.CreatedAt.Format("2006-01-02 15:04:05"),
        UpdatedAt: category.UpdatedAt.Format("2006-01-02 15:04:05"),
    }, nil
}

// GetCategoryByID mengambil category berdasarkan ID
func (s *CategoryService) GetCategoryByID(id uint) (*responses.CategoryResponse, error) {
    category, err := s.categoryRepo.GetCategoryByID(id)
    if err != nil {
        return nil, err
    }

    return &responses.CategoryResponse{
        ID:        category.ID,
        Name:      category.Name,
        Slug:      category.Slug,
        CreatedAt: category.CreatedAt.Format("2006-01-02 15:04:05"),
        UpdatedAt: category.UpdatedAt.Format("2006-01-02 15:04:05"),
    }, nil
}

// GetAllCategories mengambil semua categories dengan pagination
func (s *CategoryService) GetAllCategories(page, limit int) (*responses.CategoryListResponse, error) {
    categories, total, err := s.categoryRepo.GetAllCategories(page, limit)
    if err != nil {
        return nil, errors.New("failed to get categories")
    }

    return &responses.CategoryListResponse{
        Categories: responses.ConvertCategoriesToResponse(categories),
        Total:      int(total),
        Page:       page,
        Limit:      limit,
    }, nil
}

// UpdateCategory mengupdate category berdasarkan ID
func (s *CategoryService) UpdateCategory(id uint, req requests.UpdateCategoryRequest) (*responses.CategoryResponse, error) {
    // Cek apakah category ada
    existingCategory, err := s.categoryRepo.GetCategoryByID(id)
    if err != nil {
        return nil, err
    }

    // Cek apakah nama category sudah ada (exclude current category)
    exists, err := s.categoryRepo.CheckCategoryExists(req.Name, id)
    if err != nil {
        return nil, errors.New("failed to check category existence")
    }
    if exists {
        return nil, errors.New("category name already exists")
    }

    // Update category
    existingCategory.Name = req.Name
    if err := s.categoryRepo.UpdateCategory(id, existingCategory); err != nil {
        return nil, errors.New("failed to update category")
    }

    // Get updated category
    updatedCategory, err := s.categoryRepo.GetCategoryByID(id)
    if err != nil {
        return nil, errors.New("failed to get updated category")
    }

    return &responses.CategoryResponse{
        ID:        updatedCategory.ID,
        Name:      updatedCategory.Name,
        Slug:      updatedCategory.Slug,
        CreatedAt: updatedCategory.CreatedAt.Format("2006-01-02 15:04:05"),
        UpdatedAt: updatedCategory.UpdatedAt.Format("2006-01-02 15:04:05"),
    }, nil
}

// DeleteCategory menghapus category berdasarkan ID
func (s *CategoryService) DeleteCategory(id uint) error {
    // Cek apakah category ada
    _, err := s.categoryRepo.GetCategoryByID(id)
    if err != nil {
        return err
    }

    // Hapus category
    if err := s.categoryRepo.DeleteCategory(id); err != nil {
        return errors.New("failed to delete category")
    }

    return nil
}</code></pre>

                    <h4>Penjelasan Category Service:</h4>
                    <ul>
                        <li><strong>CreateCategory:</strong> Business logic untuk membuat kategori baru</li>
                        <li><strong>GetCategoryByID:</strong> Mengambil kategori berdasarkan ID</li>
                        <li><strong>GetAllCategories:</strong> Mengambil semua kategori dengan pagination</li>
                        <li><strong>UpdateCategory:</strong> Business logic untuk update kategori</li>
                        <li><strong>DeleteCategory:</strong> Business logic untuk hapus kategori</li>
                        <li><strong>Validation:</strong> Cek duplikasi nama kategori</li>
                    </ul>

                    <h3>📝 Langkah 6: Buat Category Handler</h3>
                    <p>Buat file <code>handlers/category_handler.go</code> untuk HTTP handlers:</p>

                    <pre><code>package handlers

import (
    "net/http"
    "strconv"
    "tokogo/requests"
    "tokogo/responses"
    "tokogo/services"

    "github.com/gin-gonic/gin"
)

type CategoryHandler struct {
    categoryService *services.CategoryService
}

// NewCategoryHandler membuat instance baru CategoryHandler
func NewCategoryHandler() *CategoryHandler {
    return &CategoryHandler{
        categoryService: services.NewCategoryService(),
    }
}

// CreateCategory handler untuk membuat category baru
func (h *CategoryHandler) CreateCategory(c *gin.Context) {
    var req requests.CreateCategoryRequest

    // Bind dan validasi request
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Validasi menggunakan method Validate()
    if err := req.Validate(); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Panggil service untuk create category
    categoryResponse, err := h.categoryService.CreateCategory(req)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "create_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusCreated, responses.SuccessResponse{
        Message: "Category created successfully",
        Data:    categoryResponse,
    })
}

// GetCategoryByID handler untuk mengambil category berdasarkan ID
func (h *CategoryHandler) GetCategoryByID(c *gin.Context) {
    // Ambil ID dari URL parameter
    idStr := c.Param("id")
    id, err := strconv.ParseUint(idStr, 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "invalid_id",
            Message: "Invalid category ID",
        })
        return
    }

    // Panggil service untuk get category
    categoryResponse, err := h.categoryService.GetCategoryByID(uint(id))
    if err != nil {
        c.JSON(http.StatusNotFound, responses.ErrorResponse{
            Error:   "category_not_found",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Category retrieved successfully",
        Data:    categoryResponse,
    })
}

// GetAllCategories handler untuk mengambil semua categories
func (h *CategoryHandler) GetAllCategories(c *gin.Context) {
    // Ambil query parameters untuk pagination
    pageStr := c.DefaultQuery("page", "1")
    limitStr := c.DefaultQuery("limit", "10")

    page, err := strconv.Atoi(pageStr)
    if err != nil || page < 1 {
        page = 1
    }

    limit, err := strconv.Atoi(limitStr)
    if err != nil || limit < 1 || limit > 100 {
        limit = 10
    }

    // Panggil service untuk get all categories
    categoriesResponse, err := h.categoryService.GetAllCategories(page, limit)
    if err != nil {
        c.JSON(http.StatusInternalServerError, responses.ErrorResponse{
            Error:   "get_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Categories retrieved successfully",
        Data:    categoriesResponse,
    })
}

// UpdateCategory handler untuk mengupdate category
func (h *CategoryHandler) UpdateCategory(c *gin.Context) {
    // Ambil ID dari URL parameter
    idStr := c.Param("id")
    id, err := strconv.ParseUint(idStr, 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "invalid_id",
            Message: "Invalid category ID",
        })
        return
    }

    var req requests.UpdateCategoryRequest

    // Bind dan validasi request
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Validasi menggunakan method Validate()
    if err := req.Validate(); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Panggil service untuk update category
    categoryResponse, err := h.categoryService.UpdateCategory(uint(id), req)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "update_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Category updated successfully",
        Data:    categoryResponse,
    })
}

// DeleteCategory handler untuk menghapus category
func (h *CategoryHandler) DeleteCategory(c *gin.Context) {
    // Ambil ID dari URL parameter
    idStr := c.Param("id")
    id, err := strconv.ParseUint(idStr, 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "invalid_id",
            Message: "Invalid category ID",
        })
        return
    }

    // Panggil service untuk delete category
    err = h.categoryService.DeleteCategory(uint(id))
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "delete_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Category deleted successfully",
        Data:    nil,
    })
}</code></pre>

                    <h4>Penjelasan Category Handler:</h4>
                    <ul>
                        <li><strong>CreateCategory:</strong> HTTP handler untuk membuat kategori baru</li>
                        <li><strong>GetCategoryByID:</strong> HTTP handler untuk mengambil kategori berdasarkan ID</li>
                        <li><strong>GetAllCategories:</strong> HTTP handler untuk mengambil semua kategori dengan pagination</li>
                        <li><strong>UpdateCategory:</strong> HTTP handler untuk update kategori</li>
                        <li><strong>DeleteCategory:</strong> HTTP handler untuk hapus kategori</li>
                        <li><strong>Error Handling:</strong> Proper error handling untuk setiap endpoint</li>
                    </ul>

                    <h3>📝 Langkah 7: Update Main.go untuk Category Routes</h3>
                    <p>Update file <code>main.go</code> untuk menambahkan category routes:</p>

                    <pre><code>package main

import (
    "log"
    "tokogo/config"
    "tokogo/handlers"
    "tokogo/middlewares"

    "github.com/gin-contrib/cors"
    "github.com/gin-gonic/gin"
    "github.com/joho/godotenv"
)

func main() {
    // Load environment variables
    if err := godotenv.Load(); err != nil {
        log.Println("No .env file found, using system environment variables")
    }

    // Initialize database
    config.InitDB()

    // Setup Gin router
    r := gin.Default()

    // CORS middleware
    r.Use(cors.New(cors.Config{
        AllowOrigins:     []string{"*"},
        AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
        AllowHeaders:     []string{"*"},
        ExposeHeaders:    []string{"Content-Length"},
        AllowCredentials: true,
    }))

    // Initialize handlers
    authHandler := handlers.NewAuthHandler()
    categoryHandler := handlers.NewCategoryHandler()

    // Public routes (tidak perlu authentication)
    api := r.Group("/api/v1")
    {
        // Auth routes
        auth := api.Group("/auth")
        {
            auth.POST("/register", authHandler.Register)
            auth.POST("/login", authHandler.Login)
        }
    }

    // Protected routes (perlu authentication)
    protected := r.Group("/api/v1")
    protected.Use(middlewares.AuthMiddleware())
    {
        // Auth protected routes
        auth := protected.Group("/auth")
        {
            auth.POST("/logout", authHandler.Logout)
            auth.GET("/profile", authHandler.GetProfile)
        }

        // Admin routes (perlu admin role)
        admin := protected.Group("/admin")
        admin.Use(middlewares.AdminMiddleware())
        {
            admin.GET("/dashboard", func(c *gin.Context) {
                c.JSON(200, gin.H{
                    "message": "Welcome to admin dashboard",
                    "user_id": c.GetUint("user_id"),
                })
            })

            // Category CRUD routes (admin only)
            categories := admin.Group("/categories")
            {
                categories.POST("", categoryHandler.CreateCategory)
                categories.GET("", categoryHandler.GetAllCategories)
                categories.GET("/:id", categoryHandler.GetCategoryByID)
                categories.PUT("/:id", categoryHandler.UpdateCategory)
                categories.DELETE("/:id", categoryHandler.DeleteCategory)
            }
        }
    }

    // Start server
    port := config.GetEnv("SERVER_PORT", "8080")
    log.Printf("Server starting on port %s", port)
    r.Run(":" + port)
}</code></pre>

                    <h4>Penjelasan Main.go Update:</h4>
                    <ul>
                        <li><strong>Category Handler:</strong> Initialize categoryHandler</li>
                        <li><strong>Admin Routes:</strong> Category routes dalam admin group</li>
                        <li><strong>CRUD Endpoints:</strong> POST, GET, PUT, DELETE untuk categories</li>
                        <li><strong>Middleware Chain:</strong> AuthMiddleware -> AdminMiddleware</li>
                        <li><strong>Route Structure:</strong> /api/v1/admin/categories</li>
                    </ul>

                    <h3>📝 Langkah 8: Update Database Config untuk AutoMigrate</h3>
                    <p>Update file <code>config/database.go</code> untuk menambahkan Category model:</p>

                    <pre><code>package config

import (
    "fmt"
    "log"
    "os"
    "tokogo/models"

    "gorm.io/driver/mysql"
    "gorm.io/gorm"
)

var DB *gorm.DB

// InitDB menginisialisasi koneksi database
func InitDB() {
    var err error

    // Konfigurasi database dari environment variables
    dbHost := GetEnv("DB_HOST", "localhost")
    dbPort := GetEnv("DB_PORT", "3306")
    dbUser := GetEnv("DB_USER", "root")
    dbPassword := GetEnv("DB_PASSWORD", "")
    dbName := GetEnv("DB_NAME", "tokogo")

    // Buat DSN (Data Source Name)
    dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local",
        dbUser, dbPassword, dbHost, dbPort, dbName)

    // Koneksi ke database
    DB, err = gorm.Open(mysql.Open(dsn), &gorm.Config{})
    if err != nil {
        log.Fatal("Failed to connect to database:", err)
    }

    log.Println("Database connected successfully")

    // Auto migrate models
    err = DB.AutoMigrate(
        &models.User{},
        &models.Category{},
    )
    if err != nil {
        log.Fatal("Failed to migrate database:", err)
    }

    log.Println("Database migrated successfully")
}

// GetDB mengembalikan instance database
func GetDB() *gorm.DB {
    return DB
}

// GetEnv mengambil environment variable dengan default value
func GetEnv(key, defaultValue string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return defaultValue
}</code></pre>

                    <h4>Penjelasan Database Config Update:</h4>
                    <ul>
                        <li><strong>AutoMigrate:</strong> Menambahkan &models.Category{} ke AutoMigrate</li>
                        <li><strong>Table Creation:</strong> GORM akan membuat tabel categories otomatis</li>
                        <li><strong>Schema Sync:</strong> Database schema akan sync dengan model</li>
                    </ul>

                    <h3>🧪 Testing API Category CRUD</h3>
                    <p>Sekarang mari kita test API category CRUD yang sudah kita buat:</p>

                    <h4>1. Login sebagai Admin (untuk mendapatkan token)</h4>
                    <pre><code>POST http://localhost:8080/api/v1/auth/login
Content-Type: application/json

{
    "email": "admin@example.com",
    "password": "adminpassword"
}</code></pre>

                    <h4>2. Create Category</h4>
                    <pre><code>POST http://localhost:8080/api/v1/admin/categories
Authorization: Bearer {admin_jwt_token}
Content-Type: application/json

{
    "name": "Electronics"
}</code></pre>

                    <h4>Response Sukses (201 Created):</h4>
                    <pre><code>{
    "message": "Category created successfully",
    "data": {
        "id": 1,
        "name": "Electronics",
        "slug": "electronics",
        "created_at": "2024-01-15 10:30:00",
        "updated_at": "2024-01-15 10:30:00"
    }
}</code></pre>

                    <h4>3. Get All Categories</h4>
                    <pre><code>GET http://localhost:8080/api/v1/admin/categories?page=1&limit=10
Authorization: Bearer {admin_jwt_token}</code></pre>

                    <h4>4. Get Category by ID</h4>
                    <pre><code>GET http://localhost:8080/api/v1/admin/categories/1
Authorization: Bearer {admin_jwt_token}</code></pre>

                    <h4>5. Update Category</h4>
                    <pre><code>PUT http://localhost:8080/api/v1/admin/categories/1
Authorization: Bearer {admin_jwt_token}
Content-Type: application/json

{
    "name": "Electronic Devices"
}</code></pre>

                    <h4>6. Delete Category</h4>
                    <pre><code>DELETE http://localhost:8080/api/v1/admin/categories/1
Authorization: Bearer {admin_jwt_token}</code></pre>

                    <h4>Response Sukses (200 OK):</h4>
                    <pre><code>{
    "message": "Category deleted successfully",
    "data": null
}</code></pre>

                    <h4>7. Test dengan Customer Role (403 Forbidden)</h4>
                    <pre><code>POST http://localhost:8080/api/v1/admin/categories
Authorization: Bearer {customer_jwt_token}
Content-Type: application/json

{
    "name": "Test Category"
}</code></pre>

                    <h4>Response Error (403 Forbidden):</h4>
                    <pre><code>{
    "error": "forbidden",
    "message": "Admin access required"
}</code></pre>

                    <h3>✅ Checklist Implementasi Category CRUD</h3>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>File yang Harus Dibuat:</h4>
                        <ul>
                            <li>✅ models/category.go (Category model)</li>
                            <li>✅ requests/category_request.go (Request structs)</li>
                            <li>✅ responses/category_response.go (Response structs)</li>
                            <li>✅ repositories/category_repository.go (Database operations)</li>
                            <li>✅ services/category_service.go (Business logic)</li>
                            <li>✅ handlers/category_handler.go (HTTP handlers)</li>
                        </ul>
                        
                        <h4>File yang Harus Diupdate:</h4>
                        <ul>
                            <li>✅ config/database.go (AutoMigrate Category)</li>
                            <li>✅ main.go (Category routes)</li>
                        </ul>
                    </div>

                    <h3>🚀 Cara Menjalankan</h3>
                    <ol>
                        <li>Pastikan MySQL sudah berjalan</li>
                        <li>Pastikan database 'tokogo' sudah dibuat</li>
                        <li>Pastikan ada user dengan role admin</li>
                        <li>Jalankan: <code>go run main.go</code></li>
                        <li>Test dengan Postman atau curl</li>
                    </ol>

                    <h3>🎯 Fitur Category CRUD yang Sudah Diimplementasikan</h3>
                    <ul>
                        <li>✅ Create Category dengan validasi nama</li>
                        <li>✅ Read Category (Get by ID, Get All dengan pagination)</li>
                        <li>✅ Update Category dengan validasi nama</li>
                        <li>✅ Delete Category (soft delete)</li>
                        <li>✅ Auto-generate slug dari nama</li>
                        <li>✅ Duplicate name validation</li>
                        <li>✅ Admin-only access control</li>
                        <li>✅ Pagination support</li>
                    </ul>

                    <h3>🔒 Keamanan yang Diimplementasikan</h3>
                    <ul>
                        <li>✅ Admin-only access dengan AdminMiddleware</li>
                        <li>✅ JWT token validation</li>
                        <li>✅ Input validation dengan go-playground/validator</li>
                        <li>✅ SQL injection protection (GORM)</li>
                        <li>✅ Soft delete untuk data integrity</li>
                        <li>✅ Duplicate name prevention</li>
                        <li>✅ Proper error handling</li>
                    </ul>

                    <h3>🎉 Selamat!</h3>
                    <p>Anda telah berhasil mengimplementasikan modul CRUD Kategori yang lengkap! Sistem manajemen kategori sudah siap untuk digunakan dan hanya bisa diakses oleh admin. Fitur ini dapat diintegrasikan dengan modul Product Management di bab selanjutnya.</p>

                    <div style="text-align: center; margin: 3rem 0;">
                        <div style="background: #f8f9fa; border: 1px solid #dee2e6; color: #2c3e50; padding: 2rem; border-radius: 5px; display: inline-block;">
                            <h3 style="color: #2c3e50; margin-bottom: 1rem;">🎯 Siap untuk Modul Selanjutnya?</h3>
                            <p style="color: #495057; margin-bottom: 0;">Dengan sistem CRUD Kategori yang lengkap, Anda siap untuk melanjutkan ke modul Product Management yang akan menggunakan kategori ini!</p>
                        </div>
                    </div>
                `
            },
            {
                id: 'chapter11',
                title: 'Bab 11: Modul CRUD Product - Role Admin',
                meta: 'Halaman 11 dari 50 • Dibaca 15 menit',
                content: `
                    <h2>📦 Bab 11: Modul CRUD Product - Role Admin</h2>
                    <p>Selamat! Sekarang kita akan membuat modul CRUD (Create, Read, Update, Delete) untuk Product yang hanya bisa diakses oleh admin. Di bab ini, kita akan mengimplementasikan sistem manajemen produk dengan role-based access control dan relasi dengan kategori.</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">🎯 Apa yang Akan Kita Buat di Bab Ini?</h3>
                        <p style="color: #495057; margin-bottom: 0;">Kita akan membuat sistem CRUD produk yang lengkap dengan Create, Read, Update, Delete operations. Semua endpoint hanya bisa diakses oleh admin. Produk akan memiliki relasi dengan kategori dan fitur manajemen stok.</p>
                    </div>

                    <h3>📋 Prasyarat</h3>
                    <p>Sebelum memulai, pastikan Anda sudah menyelesaikan:</p>
                    <ul>
                        <li>✅ Bab 6-8: Modul Authentication (Register, Login, Logout)</li>
                        <li>✅ Bab 9: Review Pembelajaran Authentication</li>
                        <li>✅ Bab 10: Modul CRUD Kategori - Role Admin</li>
                        <li>✅ Middleware authentication sudah berfungsi</li>
                        <li>✅ AdminMiddleware sudah diimplementasikan</li>
                        <li>✅ Tabel categories sudah ada di database</li>
                    </ul>

                    <h3>🗄️ Database Schema - Tabel Products</h3>
                    <p>Pertama, kita perlu membuat tabel products dengan struktur sebagai berikut:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>📊 Struktur Tabel Products</h4>
                        <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                            <thead>
                                <tr style="background-color: #e9ecef;">
                                    <th style="border: 1px solid #dee2e6; padding: 0.75rem; text-align: left;">Field</th>
                                    <th style="border: 1px solid #dee2e6; padding: 0.75rem; text-align: left;">Type</th>
                                    <th style="border: 1px solid #dee2e6; padding: 0.75rem; text-align: left;">Constraint</th>
                                    <th style="border: 1px solid #dee2e6; padding: 0.75rem; text-align: left;">Description</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">id</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">BIGINT</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">PK, Auto Increment</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Primary key</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">name</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">VARCHAR</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">NOT NULL</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Nama produk</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">description</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">TEXT</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">NULL</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Deskripsi produk</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">purchase_price</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">DECIMAL(10,2)</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">NOT NULL</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Harga beli</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">selling_price</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">DECIMAL(10,2)</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">NOT NULL</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Harga jual</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">stock</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">INT</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">NOT NULL, DEFAULT 0</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Stok produk</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">category_id</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">BIGINT</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">FK → Categories(id)</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">ID kategori</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">image_url</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">VARCHAR(255)</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">NULL</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">URL gambar produk (opsional)</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">created_at</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">TIMESTAMP</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">DEFAULT CURRENT_TIMESTAMP</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Waktu dibuat</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">updated_at</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">TIMESTAMP</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Waktu diupdate</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <h4>🔧 SQL untuk Membuat Tabel Products</h4>
                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>CREATE TABLE products (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    purchase_price DECIMAL(10,2) NOT NULL,
    selling_price DECIMAL(10,2) NOT NULL,
    stock INT NOT NULL DEFAULT 0,
    category_id BIGINT NOT NULL,
    image_url VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (category_id) REFERENCES categories(id) ON DELETE CASCADE
);</code></pre>

                    <h3>📁 Struktur File yang Akan Dibuat</h3>
                    <p>Kita akan membuat file-file berikut untuk modul Product:</p>
                    <ul>
                        <li><code>models/product.go</code> - Model Product</li>
                        <li><code>requests/product_request.go</code> - Request structs</li>
                        <li><code>responses/product_response.go</code> - Response structs</li>
                        <li><code>repositories/product_repository.go</code> - Database operations</li>
                        <li><code>services/product_service.go</code> - Business logic</li>
                        <li><code>handlers/product_handler.go</code> - HTTP handlers</li>
                    </ul>

                    <h3>🏗️ Langkah 1: Membuat Model Product</h3>
                    <p>Buat file <code>models/product.go</code>:</p>

                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>package models

import "time"

type Product struct {
    ID            uint      \`json:"id" gorm:"primaryKey"\`
    Name          string    \`json:"name" gorm:"not null"\`
    Description   string    \`json:"description"\`
    PurchasePrice float64   \`json:"purchase_price" gorm:"not null;type:decimal(10,2)"\`
    SellingPrice  float64   \`json:"selling_price" gorm:"not null;type:decimal(10,2)"\`
    Stock         int       \`json:"stock" gorm:"not null;default:0"\`
    CategoryID    uint      \`json:"category_id" gorm:"not null"\`
    Category      Category  \`json:"category" gorm:"foreignKey:CategoryID"\`
    ImageURL      string    \`json:"image_url"\`
    CreatedAt     time.Time \`json:"created_at"\`
    UpdatedAt     time.Time \`json:"updated_at"\`
}</code></pre>

                    <h3>📝 Langkah 2: Membuat Request Structs</h3>
                    <p>Buat file <code>requests/product_request.go</code>:</p>

                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>package requests

type CreateProductRequest struct {
    Name          string  \`json:"name" binding:"required,min=3,max=255"\`
    Description   string  \`json:"description"\`
    PurchasePrice float64 \`json:"purchase_price" binding:"required,min=0"\`
    SellingPrice  float64 \`json:"selling_price" binding:"required,min=0"\`
    Stock         int     \`json:"stock" binding:"min=0"\`
    CategoryID    uint    \`json:"category_id" binding:"required"\`
    ImageURL      string  \`json:"image_url"\`
}

type UpdateProductRequest struct {
    Name          string  \`json:"name" binding:"required,min=3,max=255"\`
    Description   string  \`json:"description"\`
    PurchasePrice float64 \`json:"purchase_price" binding:"required,min=0"\`
    SellingPrice  float64 \`json:"selling_price" binding:"required,min=0"\`
    Stock         int     \`json:"stock" binding:"min=0"\`
    CategoryID    uint    \`json:"category_id" binding:"required"\`
    ImageURL      string  \`json:"image_url"\`
}</code></pre>

                    <h3>📤 Langkah 3: Membuat Response Structs</h3>
                    <p>Buat file <code>responses/product_response.go</code>:</p>

                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>package responses

import "time"

type ProductResponse struct {
    ID            uint      \`json:"id"\`
    Name          string    \`json:"name"\`
    Description   string    \`json:"description"\`
    PurchasePrice float64   \`json:"purchase_price"\`
    SellingPrice  float64   \`json:"selling_price"\`
    Stock         int       \`json:"stock"\`
    CategoryID    uint      \`json:"category_id"\`
    CategoryName  string    \`json:"category_name"\`
    ImageURL      string    \`json:"image_url"\`
    CreatedAt     time.Time \`json:"created_at"\`
    UpdatedAt     time.Time \`json:"updated_at"\`
}

type ProductListResponse struct {
    Products []ProductResponse \`json:"products"\`
    Total    int64             \`json:"total"\`
    Page     int               \`json:"page"\`
    Limit    int               \`json:"limit"\`
}</code></pre>

                    <h3>🗄️ Langkah 4: Membuat Repository</h3>
                    <p>Buat file <code>repositories/product_repository.go</code>:</p>

                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>package repositories

import (
    "tokogo/models"
    "gorm.io/gorm"
)

type ProductRepository struct {
    db *gorm.DB
}

func NewProductRepository(db *gorm.DB) *ProductRepository {
    return &ProductRepository{db: db}
}

func (r *ProductRepository) Create(product *models.Product) error {
    return r.db.Create(product).Error
}

func (r *ProductRepository) GetAll(page, limit int) ([]models.Product, int64, error) {
    var products []models.Product
    var total int64

    offset := (page - 1) * limit

    // Count total records
    if err := r.db.Model(&models.Product{}).Count(&total).Error; err != nil {
        return nil, 0, err
    }

    // Get products with pagination
    err := r.db.Preload("Category").
        Offset(offset).
        Limit(limit).
        Find(&products).Error

    return products, total, err
}

func (r *ProductRepository) GetByID(id uint) (*models.Product, error) {
    var product models.Product
    err := r.db.Preload("Category").First(&product, id).Error
    return &product, err
}

func (r *ProductRepository) Update(product *models.Product) error {
    return r.db.Save(product).Error
}

func (r *ProductRepository) Delete(id uint) error {
    return r.db.Delete(&models.Product{}, id).Error
}

func (r *ProductRepository) GetByCategoryID(categoryID uint, page, limit int) ([]models.Product, int64, error) {
    var products []models.Product
    var total int64

    offset := (page - 1) * limit

    // Count total records
    if err := r.db.Model(&models.Product{}).Where("category_id = ?", categoryID).Count(&total).Error; err != nil {
        return nil, 0, err
    }

    // Get products with pagination
    err := r.db.Preload("Category").
        Where("category_id = ?", categoryID).
        Offset(offset).
        Limit(limit).
        Find(&products).Error

    return products, total, err
}</code></pre>

                    <h3>⚙️ Langkah 5: Membuat Service</h3>
                    <p>Buat file <code>services/product_service.go</code>:</p>

                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>package services

import (
    "errors"
    "tokogo/models"
    "tokogo/repositories"
    "tokogo/requests"
    "tokogo/responses"
)

type ProductService struct {
    productRepo *repositories.ProductRepository
    categoryRepo *repositories.CategoryRepository
}

func NewProductService(productRepo *repositories.ProductRepository, categoryRepo *repositories.CategoryRepository) *ProductService {
    return &ProductService{
        productRepo:  productRepo,
        categoryRepo: categoryRepo,
    }
}

func (s *ProductService) CreateProduct(req requests.CreateProductRequest) (*responses.ProductResponse, error) {
    // Validate category exists
    _, err := s.categoryRepo.GetByID(req.CategoryID)
    if err != nil {
        return nil, errors.New("category not found")
    }

    product := &models.Product{
        Name:          req.Name,
        Description:   req.Description,
        PurchasePrice: req.PurchasePrice,
        SellingPrice:  req.SellingPrice,
        Stock:         req.Stock,
        CategoryID:    req.CategoryID,
        ImageURL:      req.ImageURL,
    }

    if err := s.productRepo.Create(product); err != nil {
        return nil, err
    }

    return s.convertToResponse(product), nil
}

func (s *ProductService) GetAllProducts(page, limit int) (*responses.ProductListResponse, error) {
    if page < 1 {
        page = 1
    }
    if limit < 1 {
        limit = 10
    }

    products, total, err := s.productRepo.GetAll(page, limit)
    if err != nil {
        return nil, err
    }

    var productResponses []responses.ProductResponse
    for _, product := range products {
        productResponses = append(productResponses, *s.convertToResponse(&product))
    }

    return &responses.ProductListResponse{
        Products: productResponses,
        Total:    total,
        Page:     page,
        Limit:    limit,
    }, nil
}

func (s *ProductService) GetProductByID(id uint) (*responses.ProductResponse, error) {
    product, err := s.productRepo.GetByID(id)
    if err != nil {
        return nil, err
    }

    return s.convertToResponse(product), nil
}

func (s *ProductService) UpdateProduct(id uint, req requests.UpdateProductRequest) (*responses.ProductResponse, error) {
    // Get existing product
    product, err := s.productRepo.GetByID(id)
    if err != nil {
        return nil, err
    }

    // Validate category exists
    _, err = s.categoryRepo.GetByID(req.CategoryID)
    if err != nil {
        return nil, errors.New("category not found")
    }

    // Update product fields
    product.Name = req.Name
    product.Description = req.Description
    product.PurchasePrice = req.PurchasePrice
    product.SellingPrice = req.SellingPrice
    product.Stock = req.Stock
    product.CategoryID = req.CategoryID
    product.ImageURL = req.ImageURL

    if err := s.productRepo.Update(product); err != nil {
        return nil, err
    }

    return s.convertToResponse(product), nil
}

func (s *ProductService) DeleteProduct(id uint) error {
    // Check if product exists
    _, err := s.productRepo.GetByID(id)
    if err != nil {
        return err
    }

    return s.productRepo.Delete(id)
}

func (s *ProductService) GetProductsByCategory(categoryID uint, page, limit int) (*responses.ProductListResponse, error) {
    if page < 1 {
        page = 1
    }
    if limit < 1 {
        limit = 10
    }

    products, total, err := s.productRepo.GetByCategoryID(categoryID, page, limit)
    if err != nil {
        return nil, err
    }

    var productResponses []responses.ProductResponse
    for _, product := range products {
        productResponses = append(productResponses, *s.convertToResponse(&product))
    }

    return &responses.ProductListResponse{
        Products: productResponses,
        Total:    total,
        Page:     page,
        Limit:    limit,
    }, nil
}

func (s *ProductService) convertToResponse(product *models.Product) *responses.ProductResponse {
    return &responses.ProductResponse{
        ID:            product.ID,
        Name:          product.Name,
        Description:   product.Description,
        PurchasePrice: product.PurchasePrice,
        SellingPrice:  product.SellingPrice,
        Stock:         product.Stock,
        CategoryID:    product.CategoryID,
        CategoryName:  product.Category.Name,
        ImageURL:      product.ImageURL,
        CreatedAt:     product.CreatedAt,
        UpdatedAt:     product.UpdatedAt,
    }
}</code></pre>

                    <h3>🌐 Langkah 6: Membuat Handler</h3>
                    <p>Buat file <code>handlers/product_handler.go</code>:</p>

                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>package handlers

import (
    "net/http"
    "strconv"
    "tokogo/requests"
    "tokogo/services"

    "github.com/gin-gonic/gin"
)

type ProductHandler struct {
    productService *services.ProductService
}

func NewProductHandler(productService *services.ProductService) *ProductHandler {
    return &ProductHandler{
        productService: productService,
    }
}

// CreateProduct godoc
// @Summary Create a new product
// @Description Create a new product (Admin only)
// @Tags Products
// @Accept json
// @Produce json
// @Param product body requests.CreateProductRequest true "Product data"
// @Success 201 {object} responses.ProductResponse
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 403 {object} map[string]string
// @Router /admin/products [post]
func (h *ProductHandler) CreateProduct(c *gin.Context) {
    var req requests.CreateProductRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    product, err := h.productService.CreateProduct(req)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusCreated, product)
}

// GetAllProducts godoc
// @Summary Get all products
// @Description Get all products with pagination (Admin only)
// @Tags Products
// @Produce json
// @Param page query int false "Page number" default(1)
// @Param limit query int false "Items per page" default(10)
// @Success 200 {object} responses.ProductListResponse
// @Failure 401 {object} map[string]string
// @Failure 403 {object} map[string]string
// @Router /admin/products [get]
func (h *ProductHandler) GetAllProducts(c *gin.Context) {
    page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
    limit, _ := strconv.Atoi(c.DefaultQuery("limit", "10"))

    products, err := h.productService.GetAllProducts(page, limit)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusOK, products)
}

// GetProductByID godoc
// @Summary Get product by ID
// @Description Get a specific product by ID (Admin only)
// @Tags Products
// @Produce json
// @Param id path int true "Product ID"
// @Success 200 {object} responses.ProductResponse
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 403 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /admin/products/{id} [get]
func (h *ProductHandler) GetProductByID(c *gin.Context) {
    id, err := strconv.ParseUint(c.Param("id"), 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid product ID"})
        return
    }

    product, err := h.productService.GetProductByID(uint(id))
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": "Product not found"})
        return
    }

    c.JSON(http.StatusOK, product)
}

// UpdateProduct godoc
// @Summary Update product
// @Description Update a product by ID (Admin only)
// @Tags Products
// @Accept json
// @Produce json
// @Param id path int true "Product ID"
// @Param product body requests.UpdateProductRequest true "Product data"
// @Success 200 {object} responses.ProductResponse
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 403 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /admin/products/{id} [put]
func (h *ProductHandler) UpdateProduct(c *gin.Context) {
    id, err := strconv.ParseUint(c.Param("id"), 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid product ID"})
        return
    }

    var req requests.UpdateProductRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    product, err := h.productService.UpdateProduct(uint(id), req)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusOK, product)
}

// DeleteProduct godoc
// @Summary Delete product
// @Description Delete a product by ID (Admin only)
// @Tags Products
// @Produce json
// @Param id path int true "Product ID"
// @Success 200 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 403 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /admin/products/{id} [delete]
func (h *ProductHandler) DeleteProduct(c *gin.Context) {
    id, err := strconv.ParseUint(c.Param("id"), 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid product ID"})
        return
    }

    err = h.productService.DeleteProduct(uint(id))
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": "Product not found"})
        return
    }

    c.JSON(http.StatusOK, gin.H{"message": "Product deleted successfully"})
}

// GetProductsByCategory godoc
// @Summary Get products by category
// @Description Get products by category ID with pagination (Admin only)
// @Tags Products
// @Produce json
// @Param category_id path int true "Category ID"
// @Param page query int false "Page number" default(1)
// @Param limit query int false "Items per page" default(10)
// @Success 200 {object} responses.ProductListResponse
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 403 {object} map[string]string
// @Router /admin/categories/{category_id}/products [get]
func (h *ProductHandler) GetProductsByCategory(c *gin.Context) {
    categoryID, err := strconv.ParseUint(c.Param("category_id"), 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid category ID"})
        return
    }

    page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
    limit, _ := strconv.Atoi(c.DefaultQuery("limit", "10"))

    products, err := h.productService.GetProductsByCategory(uint(categoryID), page, limit)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusOK, products)
}</code></pre>

                    <h3>🔗 Langkah 7: Update main.go</h3>
                    <p>Tambahkan routes untuk product di <code>main.go</code>:</p>

                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>// Import tambahan
import (
    "tokogo/handlers"
    "tokogo/repositories"
    "tokogo/services"
    // ... existing imports
)

// Di dalam fungsi main(), tambahkan setelah category routes:
// Product routes (Admin only)
productRepo := repositories.NewProductRepository(db)
productService := services.NewProductService(productRepo, categoryRepo)
productHandler := handlers.NewProductHandler(productService)

adminRoutes := r.Group("/admin")
adminRoutes.Use(middlewares.AuthMiddleware())
adminRoutes.Use(middlewares.AdminMiddleware())

// Product routes
adminRoutes.POST("/products", productHandler.CreateProduct)
adminRoutes.GET("/products", productHandler.GetAllProducts)
adminRoutes.GET("/products/:id", productHandler.GetProductByID)
adminRoutes.PUT("/products/:id", productHandler.UpdateProduct)
adminRoutes.DELETE("/products/:id", productHandler.DeleteProduct)
adminRoutes.GET("/categories/:category_id/products", productHandler.GetProductsByCategory)</code></pre>

                    <h3>🧪 Testing dengan Postman</h3>
                    <p>Sekarang kita akan test semua endpoint product. Pastikan Anda sudah login sebagai admin dan mendapatkan JWT token.</p>

                    <h4>1. Create Product</h4>
                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>POST /admin/products
Headers:
Authorization: Bearer YOUR_JWT_TOKEN
Content-Type: application/json

Body:
{
    "name": "Laptop Gaming ASUS",
    "description": "Laptop gaming dengan spesifikasi tinggi",
    "purchase_price": 8000000,
    "selling_price": 10000000,
    "stock": 5,
    "category_id": 1,
    "image_url": "https://example.com/laptop.jpg"
}</code></pre>

                    <h4>2. Get All Products</h4>
                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>GET /admin/products?page=1&limit=10
Headers:
Authorization: Bearer YOUR_JWT_TOKEN</code></pre>

                    <h4>3. Get Product by ID</h4>
                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>GET /admin/products/1
Headers:
Authorization: Bearer YOUR_JWT_TOKEN</code></pre>

                    <h4>4. Update Product</h4>
                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>PUT /admin/products/1
Headers:
Authorization: Bearer YOUR_JWT_TOKEN
Content-Type: application/json

Body:
{
    "name": "Laptop Gaming ASUS ROG",
    "description": "Laptop gaming dengan spesifikasi tinggi dan RGB keyboard",
    "purchase_price": 8500000,
    "selling_price": 10500000,
    "stock": 3,
    "category_id": 1,
    "image_url": "https://example.com/laptop-rog.jpg"
}</code></pre>

                    <h4>5. Delete Product</h4>
                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>DELETE /admin/products/1
Headers:
Authorization: Bearer YOUR_JWT_TOKEN</code></pre>

                    <h4>6. Get Products by Category</h4>
                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>GET /admin/categories/1/products?page=1&limit=10
Headers:
Authorization: Bearer YOUR_JWT_TOKEN</code></pre>

                    <h3>✅ Checklist Implementasi</h3>
                    <p>Pastikan Anda telah menyelesaikan semua langkah berikut:</p>
                    <ul>
                        <li>✅ Membuat tabel products di database</li>
                        <li>✅ Membuat model Product di models/product.go</li>
                        <li>✅ Membuat request structs di requests/product_request.go</li>
                        <li>✅ Membuat response structs di responses/product_response.go</li>
                        <li>✅ Membuat repository di repositories/product_repository.go</li>
                        <li>✅ Membuat service di services/product_service.go</li>
                        <li>✅ Membuat handler di handlers/product_handler.go</li>
                        <li>✅ Menambahkan routes di main.go</li>
                        <li>✅ Test semua endpoint dengan Postman</li>
                    </ul>

                    <h3>🎯 Fitur yang Telah Diimplementasikan</h3>
                    <ul>
                        <li>✅ <strong>Create Product</strong> - Membuat produk baru dengan validasi</li>
                        <li>✅ <strong>Read Products</strong> - Melihat daftar produk dengan pagination</li>
                        <li>✅ <strong>Read Product by ID</strong> - Melihat detail produk berdasarkan ID</li>
                        <li>✅ <strong>Update Product</strong> - Mengupdate data produk</li>
                        <li>✅ <strong>Delete Product</strong> - Menghapus produk</li>
                        <li>✅ <strong>Get Products by Category</strong> - Melihat produk berdasarkan kategori</li>
                        <li>✅ <strong>Admin Role Protection</strong> - Semua endpoint hanya bisa diakses admin</li>
                        <li>✅ <strong>Input Validation</strong> - Validasi input menggunakan Gin binding</li>
                        <li>✅ <strong>Database Relations</strong> - Relasi dengan tabel categories</li>
                        <li>✅ <strong>Error Handling</strong> - Penanganan error yang baik</li>
                    </ul>

                    <div style="background: #d4edda; border: 1px solid #c3e6cb; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4 style="color: #155724; margin-bottom: 1rem;">🎉 Selamat! Modul CRUD Product Telah Selesai</h4>
                        <p style="color: #155724; margin-bottom: 0;">Anda telah berhasil mengimplementasikan sistem CRUD Product yang lengkap dengan role-based access control. Sistem ini siap untuk digunakan dalam aplikasi toko online Anda!</p>
                    </div>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>🎯 Preview Bab 12: Modul CRUD Customer - Role Admin</h4>
                        <p>Di bab selanjutnya, kita akan:</p>
                        <ul>
                            <li>Membuat sistem CRUD Customer untuk admin</li>
                            <li>Implementasi manajemen data pelanggan</li>
                            <li>Validasi dan keamanan data customer</li>
                            <li>Testing endpoint customer dengan Postman</li>
                        </ul>
                        <p style="color: #495057; margin-bottom: 0;">Dengan sistem CRUD Product yang lengkap, Anda siap untuk melanjutkan ke modul Customer Management!</p>
                    </div>
                `
            }
        ];

        // Current chapter index
        let currentChapterIndex = 0;

        // Font size control
        let currentFontSize = 16;
        const fontSizeDisplay = document.getElementById('fontSize');

        function increaseFont() {
            currentFontSize = Math.min(currentFontSize + 2, 24);
            const contentBody = document.getElementById('contentBody');
            if (contentBody) {
                contentBody.style.fontSize = currentFontSize + 'px';
            }
            fontSizeDisplay.textContent = currentFontSize + 'px';
        }

        function decreaseFont() {
            currentFontSize = Math.max(currentFontSize - 2, 12);
            const contentBody = document.getElementById('contentBody');
            if (contentBody) {
                contentBody.style.fontSize = currentFontSize + 'px';
            }
            fontSizeDisplay.textContent = currentFontSize + 'px';
        }

        // Chapter management functions
        function renderChapterList() {
            const chapterList = document.getElementById('chapterList');
            chapterList.innerHTML = '';
            
            chapters.forEach((chapter, index) => {
                const li = document.createElement('li');
                li.className = 'chapter-item';
                
                const a = document.createElement('a');
                a.href = `#${chapter.id}`;
                a.className = 'chapter-link';
                a.textContent = chapter.title;
                a.onclick = (e) => {
                    e.preventDefault();
                    showChapter(index);
                };
                
                li.appendChild(a);
                chapterList.appendChild(li);
            });
        }

        function renderChapter(index) {
            const chapter = chapters[index];
            const contentArea = document.getElementById('contentArea');
            
            contentArea.innerHTML = `
                <div class="content-header">
                    <h1 class="chapter-title">${chapter.title}</h1>
                    <div class="chapter-meta">${chapter.meta}</div>
                </div>
                <div class="content-body" id="contentBody">
                    ${chapter.content}
                </div>
                <div class="navigation">
                    <button class="nav-btn" ${index === 0 ? 'disabled' : ''} onclick="showChapter(${index - 1})">← Sebelumnya</button>
                    <button class="nav-btn" ${index === chapters.length - 1 ? 'disabled' : ''} onclick="showChapter(${index + 1})">Selanjutnya →</button>
                </div>
            `;
            
            // Apply font size to new content
            const contentBody = document.getElementById('contentBody');
            if (contentBody) {
                contentBody.style.fontSize = currentFontSize + 'px';
            }
        }

        function showChapter(index) {
            if (index >= 0 && index < chapters.length) {
                currentChapterIndex = index;
                renderChapter(index);
                updateActiveChapter();
                
                // Scroll to top
                window.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });
            }
        }

        function updateActiveChapter() {
            document.querySelectorAll('.chapter-link').forEach((link, index) => {
                link.classList.toggle('active', index === currentChapterIndex);
            });
        }

        // Function to add new chapter easily
        function addChapter(title, meta, content) {
            const newChapter = {
                id: `chapter${chapters.length + 1}`,
                title: title,
                meta: meta,
                content: content
            };
            chapters.push(newChapter);
            renderChapterList();
            return newChapter;
        }

        // Example of how to add a new chapter:
        // addChapter(
        //     'Bab 3: Struktur Project',
        //     'Halaman 3 dari 50 • Dibaca 10 menit',
        //     '<h2>Struktur Project yang Baik</h2><p>Konten bab 3...</p>'
        // );

        // Dark mode toggle
        function toggleDarkMode() {
            const body = document.body;
            const header = document.getElementById('header');
            const logo = document.getElementById('logo');
            const logoSubtitle = document.getElementById('logoSubtitle');
            const themeIcon = document.getElementById('themeIcon');
            const themeText = document.getElementById('themeText');
            const themeToggle = document.getElementById('themeToggle');
            
            body.classList.toggle('dark-mode');
            header.classList.toggle('dark');
            logo.classList.toggle('dark');
            logoSubtitle.classList.toggle('dark');
            themeToggle.classList.toggle('dark');
            
            if (body.classList.contains('dark-mode')) {
                themeIcon.textContent = '☀️';
                themeText.textContent = 'Light';
            } else {
                themeIcon.textContent = '🌙';
                themeText.textContent = 'Dark';
            }
            
            // Save theme preference to localStorage
            localStorage.setItem('darkMode', body.classList.contains('dark-mode'));
        }

        // Load theme preference from localStorage
        function loadThemePreference() {
            const savedTheme = localStorage.getItem('darkMode');
            if (savedTheme === 'true') {
                toggleDarkMode();
            }
        }

        // Sidebar toggle
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('show');
        }

        // Progress bar
        function updateProgress() {
            const scrollTop = window.pageYOffset;
            const docHeight = document.body.scrollHeight - window.innerHeight;
            const scrollPercent = (scrollTop / docHeight) * 100;
            document.getElementById('progressBar').style.width = scrollPercent + '%';
        }

        // Event listeners
        window.addEventListener('scroll', function() {
            updateProgress();
        });
        
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize the ebook
            renderChapterList();
            showChapter(0); // Start with first chapter
            updateProgress();
            loadThemePreference(); // Load saved theme preference
        });

        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', function(e) {
            const sidebar = document.getElementById('sidebar');
            const sidebarToggle = document.querySelector('.sidebar-toggle');
            
            if (window.innerWidth <= 768 && 
                sidebar && 
                !sidebar.contains(e.target) && 
                !sidebarToggle.contains(e.target) && 
                sidebar.classList.contains('show')) {
                sidebar.classList.remove('show');
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case '=':
                    case '+':
                        e.preventDefault();
                        increaseFont();
                        break;
                    case '-':
                        e.preventDefault();
                        decreaseFont();
                        break;
                }
            }
        });
    </script>
</body>
</html>
