<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Golang From Hero To Hero - Membangun API Mini Toko Online</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #ffffff;
            overflow-x: hidden;
        }

        html {
            scroll-behavior: smooth;
        }

        /* Header */
        .header {
            background: #ffffff;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            padding: 1rem 0;
            transition: all 0.3s ease;
        }

        .header.dark {
            background: #1f2937;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 2rem;
        }

        .logo-section {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: bold;
            color: #2c3e50;
            transition: color 0.3s ease;
        }

        .logo.dark {
            color: #f9fafb;
        }

        .logo-subtitle {
            font-size: 0.875rem;
            color: #6b7280;
            font-weight: 500;
            transition: color 0.3s ease;
        }

        .logo-subtitle.dark {
            color: #9ca3af;
        }

        .header-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .font-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn:hover {
            background: #2980b9;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: #95a5a6;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
        }

        .theme-toggle {
            background: #f8f9fa;
            color: #495057;
            border: 1px solid #dee2e6;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            box-shadow: none;
        }

        .theme-toggle:hover {
            background: #e9ecef;
            border-color: #adb5bd;
            transform: none;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .theme-toggle.dark {
            background: #343a40;
            color: #f8f9fa;
            border-color: #495057;
        }

        .theme-toggle.dark:hover {
            background: #495057;
            border-color: #6c757d;
        }

        /* Main Layout */
        .main-container {
            display: flex;
            max-width: 1200px;
            margin: 0 auto;
            margin-top: 80px;
            min-height: calc(100vh - 80px);
        }

        /* Sidebar */
        .sidebar {
            width: 250px;
            background: #f8f9fa;
            border-right: 1px solid #e9ecef;
            padding: 1.5rem 1rem;
            position: fixed;
            left: 0;
            top: 80px;
            height: calc(100vh - 80px);
            overflow-y: auto;
            transition: transform 0.3s ease;
        }

        .sidebar h3 {
            font-size: 1rem;
            margin-bottom: 1rem;
            color: #2c3e50;
            font-weight: 600;
        }

        .sidebar.hidden {
            transform: translateX(-100%);
        }

        .sidebar-toggle {
            display: none;
            position: fixed;
            top: 100px;
            left: 20px;
            z-index: 1001;
            background: #3498db;
            color: white;
            border: none;
            padding: 0.5rem;
            border-radius: 5px;
            cursor: pointer;
        }

        .chapter-list {
            list-style: none;
        }

        .chapter-item {
            margin-bottom: 0.25rem;
        }

        .chapter-link {
            display: block;
            padding: 0.5rem 0.75rem;
            color: #2c3e50;
            text-decoration: none;
            border-radius: 3px;
            transition: background 0.3s;
            font-size: 0.9rem;
            line-height: 1.3;
        }

        .chapter-link:hover,
        .chapter-link.active {
            background: #3498db;
            color: white;
        }

        /* Content Area */
        .content {
            flex: 1;
            margin-left: 250px;
            padding: 2rem;
            background: white;
        }

        .content-header {
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid #e9ecef;
        }

        .chapter-title {
            font-size: 2rem;
            color: #2c3e50;
            margin-bottom: 0.5rem;
        }

        .chapter-meta {
            color: #7f8c8d;
            font-size: 0.9rem;
        }

        .content-body {
            font-size: 1.1rem;
            line-height: 1.8;
            max-width: 800px;
            margin: 0 auto;
        }

        .content-body h1,
        .content-body h2,
        .content-body h3 {
            color: #2c3e50;
            margin: 2rem 0 1rem 0;
        }

        .content-body h1 {
            font-size: 1.8rem;
        }

        .content-body h2 {
            font-size: 1.5rem;
        }

        .content-body h3 {
            font-size: 1.3rem;
        }

        .content-body p {
            margin-bottom: 1.5rem;
            text-align: justify;
        }

        .content-body blockquote {
            border-left: 4px solid #3498db;
            padding-left: 1.5rem;
            margin: 2rem 0;
            font-style: italic;
            color: #555;
        }

        .content-body ul,
        .content-body ol {
            margin: 1rem 0 1rem 2rem;
        }

        .content-body li {
            margin-bottom: 0.5rem;
        }

        .content-body pre {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 1rem;
            margin: 1rem 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .content-body code {
            background: #f8f9fa;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            color: #e74c3c;
        }

        .content-body pre code {
            background: none;
            padding: 0;
            color: #2c3e50;
        }

        .content-body a {
            color: #3498db;
            text-decoration: none;
        }

        .content-body a:hover {
            text-decoration: underline;
        }

        /* Navigation */
        .navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid #e9ecef;
        }

        .nav-btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 1rem 2rem;
            border-radius: 5px;
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
            transition: background 0.3s;
        }

        .nav-btn:hover {
            background: #2980b9;
        }

        .nav-btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }

        /* Progress Bar */
        .progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            width: 0%;
            height: 3px;
            background: #3498db;
            z-index: 1001;
            transition: width 0.3s ease;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .sidebar {
                transform: translateX(-100%);
            }

            .sidebar.show {
                transform: translateX(0);
            }

            .sidebar-toggle {
                display: block;
            }

            .content {
                margin-left: 0;
                padding: 1rem;
            }

            .header-content {
                padding: 0 1rem;
            }

            .chapter-title {
                font-size: 1.5rem;
            }

            .content-body {
                font-size: 1rem;
            }

            .navigation {
                flex-direction: column;
                gap: 1rem;
            }

            .nav-btn {
                text-align: center;
            }
        }

        /* Dark Mode Support */
        body.dark-mode {
            background-color: #111827;
            color: #f9fafb;
        }

        body.dark-mode .header {
            background: #1f2937;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        body.dark-mode .sidebar {
            background: #1f2937;
            border-right-color: #374151;
        }

        body.dark-mode .content {
            background: #111827;
        }

        body.dark-mode .content-header {
            border-bottom-color: #374151;
        }

        body.dark-mode .chapter-title {
            color: #f9fafb;
        }

        body.dark-mode .content-body h1,
        body.dark-mode .content-body h2,
        body.dark-mode .content-body h3 {
            color: #f9fafb;
        }

        body.dark-mode .navigation {
            border-top-color: #374151;
        }

        body.dark-mode .chapter-link {
            color: #d1d5db;
        }

        body.dark-mode .chapter-link:hover,
        body.dark-mode .chapter-link.active {
            background: #3b82f6;
            color: white;
        }

        body.dark-mode .content-body {
            color: #e5e7eb;
        }

        body.dark-mode .content-body blockquote {
            border-left-color: #3b82f6;
            color: #d1d5db;
        }

        body.dark-mode .content-body pre {
            background: #1f2937;
            border-color: #374151;
            color: #f9fafb;
        }

        body.dark-mode .content-body code {
            background: #1f2937;
            color: #fbbf24;
        }

        body.dark-mode .content-body pre code {
            background: none;
            color: #f9fafb;
        }

        body.dark-mode .content-body a {
            color: #60a5fa;
        }

        body.dark-mode .nav-btn {
            background: #3b82f6;
        }

        body.dark-mode .nav-btn:hover {
            background: #2563eb;
        }

        body.dark-mode .nav-btn:disabled {
            background: #6b7280;
        }

        /* Print Styles */
        @media print {
            .header,
            .sidebar,
            .navigation,
            .sidebar-toggle {
                display: none;
            }

            .content {
                margin-left: 0;
                padding: 0;
            }

            .content-body {
                font-size: 12pt;
                line-height: 1.5;
            }
        }
    </style>
</head>
<body>
    <!-- Progress Bar -->
    <div class="progress-bar" id="progressBar"></div>

    <!-- Header -->
    <header class="header" id="header">
        <div class="header-content">
            <div class="logo-section">
                <div class="logo" id="logo">Golang From Hero To Hero</div>
                <div class="logo-subtitle" id="logoSubtitle">Membangun API Mini Toko Online</div>
            </div>
            <div class="header-controls">
                <div class="font-controls">
                    <button class="btn btn-secondary" onclick="decreaseFont()">
                        <span>A-</span>
                    </button>
                    <span id="fontSize" class="text-sm font-medium">16px</span>
                    <button class="btn btn-secondary" onclick="increaseFont()">
                        <span>A+</span>
                    </button>
                </div>
                <button class="theme-toggle" id="themeToggle" onclick="toggleDarkMode()">
                    <span id="themeIcon">üåô</span>
                    <span id="themeText">Dark</span>
                </button>
            </div>
        </div>
    </header>

    <!-- Sidebar Toggle -->
    <button class="sidebar-toggle" onclick="toggleSidebar()">‚ò∞</button>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Sidebar -->
        <nav class="sidebar" id="sidebar">
            <h3>Daftar Isi</h3>
            <ul class="chapter-list" id="chapterList">
                <!-- Chapters will be populated by JavaScript -->
            </ul>
        </nav>

        <!-- Content Area -->
        <main class="content" id="contentArea">
            <!-- Content will be populated by JavaScript -->
        </main>
    </div>

    <script>
        // Chapter data structure - Easy to add new chapters
        const chapters = [
            {
                id: 'preface',
                title: 'Kata Pengantar',
                meta: 'Halaman 0 dari 55 ‚Ä¢ Dibaca 5 menit',
                content: `
                    <div style="text-align: center; margin-bottom: 3rem;">
                        <h1 style="color: #333; font-size: 2.5rem; margin-bottom: 1rem; font-weight: bold;">Golang From Hero To Hero</h1>
                        <h2 style="color: #666; font-size: 1.5rem; margin-bottom: 2rem; font-weight: 500;">Membangun API Mini Toko Online</h2>
                    </div>

                    <p style="font-style: italic; text-align: center; margin-bottom: 2rem; color: #666;">
                        Bismillahirrahmannirrahiim.<br>
                        Assalamu'alaikum Warahmatullahi Wabarakatuh.
                    </p>

                    <hr style="border: none; border-top: 1px solid #ccc; margin: 2rem 0;">

                    <p style="line-height: 1.8; margin-bottom: 1.5rem; text-align: justify;">
                        Alhamdulillah, segala puji dan syukur penulis panjatkan kehadirat Tuhan Yang Maha Esa. Dengan rahmat dan karunia-Nya, penulis dapat menyelesaikan buku yang berjudul <strong>"Golang From Hero To Hero - Membangun API Mini Toko Online"</strong>. Penulis telah berusaha semaksimal mungkin dalam menyusun buku ini.
                    </p>

                    <p style="line-height: 1.8; margin-bottom: 1.5rem; text-align: justify;">
                        Penulis menyadari bahwa dalam penyusunan buku ini masih terdapat kekurangan dan kesalahan. Oleh karena itu, penulis mengharapkan kritik dan saran yang membangun dari pembaca untuk perbaikan di masa yang akan datang.
                    </p>

                    <p style="line-height: 1.8; margin-bottom: 1.5rem; text-align: justify;">
                        Buku ini merupakan hasil karya komersial yang penulis jual dengan harga yang terjangkau. Penulis dengan hormat meminta agar pembaca tidak menyebarluaskan buku ini tanpa seizin penulis dan menghargai karya intelektual dengan tidak melakukan pembajakan.
                    </p>

                    <p style="line-height: 1.8; margin-bottom: 1.5rem; text-align: justify;">
                        Semoga buku ini dapat bermanfaat dan mudah dipahami oleh semua pembaca. Selamat belajar dan semoga sukses dalam perjalanan menjadi developer yang handal!
                    </p>

                    <div style="text-align: right; margin-top: 3rem;">
                        <p style="margin-bottom: 0.5rem;"><strong>Mohamad Romadhon</strong></p>
                        <p style="margin-bottom: 0.5rem;">Fullstack Developer</p>
                        <p style="margin-bottom: 0;">Universitas Paramadina</p>
                    </div>
                `
            },
            {
                id: 'chapter0',
                title: 'Dasar-Dasar Golang',
                meta: 'Halaman 1 dari 55 ‚Ä¢ Dibaca 15 menit',
                content: `
                    <h2>üöÄ Dasar-Dasar Golang untuk Pemula</h2>
                    <p>Sebelum kita mulai membangun API toko online, mari kita pelajari dasar-dasar bahasa pemrograman Go terlebih dahulu. Bab ini akan memberikan fondasi yang kuat untuk memahami konsep-konsep yang akan kita gunakan dalam project API toko.</p>

                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 1.5rem; border-radius: 5px; margin: 1.5rem 0;">
                        <h3 style="color: #2e7d32; margin-bottom: 1rem;">üéØ Tujuan Pembelajaran</h3>
                        <p style="color: #2e7d32; margin-bottom: 0;">Setelah menyelesaikan bab ini, Anda akan memahami sintaks dasar Go, struktur program, tipe data, fungsi, dan konsep-konsep penting yang akan digunakan dalam project API toko.</p>
                    </div>

                    <h3>üìù Apa itu Go?</h3>
                    <p>Go (atau Golang) adalah bahasa pemrograman yang dikembangkan oleh Google pada tahun 2009. Go dirancang untuk:</p>
                    <ul>
                        <li><strong>Kesederhanaan:</strong> Sintaks yang bersih dan mudah dipahami</li>
                        <li><strong>Performansi Tinggi:</strong> Kompilasi cepat dan eksekusi yang efisien</li>
                        <li><strong>Concurrency:</strong> Built-in support untuk concurrent programming</li>
                        <li><strong>Garbage Collection:</strong> Manajemen memori otomatis</li>
                        <li><strong>Cross-platform:</strong> Bisa berjalan di berbagai sistem operasi</li>
                    </ul>

                    <h3>üèóÔ∏è Struktur Program Go</h3>
                    <p>Setiap program Go dimulai dengan package declaration dan import statements:</p>

                    <pre><code>package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}</code></pre>

                    <div style="background: #fff3cd; border: 1px solid #ffc107; padding: 1rem; border-radius: 5px; margin: 1rem 0;">
                        <h4>üí° Penjelasan Kode:</h4>
                        <ul>
                            <li><code>package main</code> - Mendeklarasikan bahwa ini adalah program utama yang bisa dijalankan</li>
                            <li><code>import "fmt"</code> - Mengimpor package fmt untuk input/output</li>
                            <li><code>func main()</code> - Fungsi utama yang akan dieksekusi pertama kali</li>
                        </ul>
                    </div>

                    <h3>üìä Tipe Data Dasar</h3>
                    <p>Go memiliki beberapa tipe data dasar yang penting untuk diketahui:</p>

                    <h4>1. Tipe Data Numerik</h4>
                    <pre><code>var age int = 25           // Integer
var price float64 = 99.99  // Float
var isActive bool = true   // Boolean</code></pre>

                    <h4>2. Tipe Data String</h4>
                    <pre><code>var name string = "John Doe"
var message = "Hello, Go!"  // Type inference</code></pre>

                    <h4>3. Konstanta</h4>
                    <pre><code>const PI = 3.14159
const APP_NAME = "Tokogo"</code></pre>

                    <h3>üîß Variabel dan Deklarasi</h3>
                    <p>Ada beberapa cara untuk mendeklarasikan variabel di Go:</p>

                    <h4>1. Deklarasi Eksplisit</h4>
                    <pre><code>var username string
var userAge int
var isLoggedIn bool</code></pre>

                    <h4>2. Deklarasi dengan Inisialisasi</h4>
                    <pre><code>var username string = "john_doe"
var userAge int = 30
var isLoggedIn bool = true</code></pre>

                    <h4>3. Short Declaration (Paling Umum)</h4>
                    <pre><code>username := "john_doe"
userAge := 30
isLoggedIn := true</code></pre>

                    <h3>üéØ Fungsi (Functions)</h3>
                    <p>Fungsi adalah blok kode yang dapat dipanggil berulang kali. Berikut contoh-contoh fungsi:</p>

                    <h4>1. Fungsi Sederhana</h4>
                    <pre><code>func greet() {
    fmt.Println("Hello, World!")
}</code></pre>

                    <h4>2. Fungsi dengan Parameter</h4>
                    <pre><code>func greetUser(name string) {
    fmt.Printf("Hello, %s!\n", name)
}</code></pre>

                    <h4>3. Fungsi dengan Return Value</h4>
                    <pre><code>func add(a, b int) int {
    return a + b
}

func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, fmt.Errorf("division by zero")
    }
    return a / b, nil
}</code></pre>

                    <h3>üì¶ Struct dan Method</h3>
                    <p>Struct adalah tipe data yang dapat mengelompokkan beberapa field. Ini sangat penting untuk API development:</p>

                    <h4>1. Definisi Struct</h4>
                    <pre><code>type User struct {
    ID       int    \`json:"id"\`
    Username string \`json:"username"\`
    Email    string \`json:"email"\`
    Age      int    \`json:"age"\`
}</code></pre>

                    <h4>2. Method pada Struct</h4>
                    <pre><code>func (u User) GetDisplayName() string {
    return fmt.Sprintf("%s (%s)", u.Username, u.Email)
}

func (u *User) UpdateAge(newAge int) {
    u.Age = newAge
}</code></pre>

                    <h4>3. Penggunaan Struct</h4>
                    <pre><code>user := User{
    ID:       1,
    Username: "john_doe",
    Email:    "john@example.com",
    Age:      25,
}

fmt.Println(user.GetDisplayName())
user.UpdateAge(26)</code></pre>

                    <h3>üîÑ Control Flow</h3>
                    <p>Go mendukung berbagai struktur kontrol seperti if, for, dan switch:</p>

                    <h4>1. If Statement</h4>
                    <pre><code>age := 18
if age >= 18 {
    fmt.Println("Dewasa")
} else if age >= 13 {
    fmt.Println("Remaja")
} else {
    fmt.Println("Anak-anak")
}</code></pre>

                    <h4>2. For Loop</h4>
                    <pre><code>// Traditional for loop
for i := 0; i < 5; i++ {
    fmt.Println(i)
}

// Range loop
fruits := []string{"apple", "banana", "orange"}
for index, fruit := range fruits {
    fmt.Printf("%d: %s\n", index, fruit)
}</code></pre>

                    <h4>3. Switch Statement</h4>
                    <pre><code>day := "Monday"
switch day {
case "Monday":
    fmt.Println("Hari kerja")
case "Saturday", "Sunday":
    fmt.Println("Hari libur")
default:
    fmt.Println("Hari biasa")
}</code></pre>

                    <h3>üìã Slice dan Map</h3>
                    <p>Slice dan Map adalah struktur data yang sangat berguna dalam Go:</p>

                    <h4>1. Slice (Dynamic Array)</h4>
                    <pre><code>// Deklarasi slice
var numbers []int
numbers = append(numbers, 1, 2, 3, 4, 5)

// Slice literal
fruits := []string{"apple", "banana", "orange"}

// Akses elemen
fmt.Println(fruits[0])        // apple
fmt.Println(fruits[1:3])      // [banana orange]
fmt.Println(len(fruits))      // 3</code></pre>

                    <h4>2. Map (Key-Value Store)</h4>
                    <pre><code>// Deklarasi map
var userScores map[string]int
userScores = make(map[string]int)

// Map literal
userScores = map[string]int{
    "john":  95,
    "jane":  87,
    "bob":   92,
}

// Akses dan modifikasi
fmt.Println(userScores["john"])  // 95
userScores["alice"] = 88
delete(userScores, "bob")</code></pre>

                    <h3>üö® Error Handling</h3>
                    <p>Go menggunakan explicit error handling yang sangat penting untuk API development:</p>

                    <pre><code>func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, fmt.Errorf("cannot divide by zero")
    }
    return a / b, nil
}

func main() {
    result, err := divide(10, 2)
    if err != nil {
        fmt.Printf("Error: %v\n", err)
        return
    }
    fmt.Printf("Result: %.2f\n", result)
}</code></pre>

                    <h3>üì¶ Package dan Import</h3>
                    <p>Go menggunakan sistem package untuk mengorganisir kode:</p>

                    <h4>1. Standard Library Packages</h4>
                    <pre><code>import (
    "fmt"      // Formatting dan I/O
    "net/http" // HTTP client dan server
    "encoding/json" // JSON encoding/decoding
    "database/sql"  // Database operations
)</code></pre>

                    <h4>2. Third-party Packages</h4>
                    <pre><code>import (
    "github.com/gorilla/mux"  // HTTP router
    "github.com/joho/godotenv" // Environment variables
)</code></pre>

                    <h3>üåê HTTP Server Dasar</h3>
                    <p>Go memiliki built-in HTTP server yang sangat powerful untuk membuat API:</p>

                    <pre><code>package main

import (
    "fmt"
    "net/http"
)

func helloHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Hello, World!")
}

func main() {
    http.HandleFunc("/", helloHandler)
    fmt.Println("Server running on :8080")
    http.ListenAndServe(":8080", nil)
}</code></pre>

                    <h3>üîß JSON Handling</h3>
                    <p>JSON sangat penting untuk API development. Go memiliki built-in support untuk JSON:</p>

                    <pre><code>type Product struct {
    ID    int    \`json:"id"\`
    Name  string \`json:"name"\`
    Price float64 \`json:"price"\`
}

func main() {
    // Struct ke JSON
    product := Product{ID: 1, Name: "Laptop", Price: 999.99}
    jsonData, _ := json.Marshal(product)
    fmt.Println(string(jsonData))
    
    // JSON ke Struct
    jsonString := \`{"id":2,"name":"Mouse","price":25.99}\`
    var newProduct Product
    json.Unmarshal([]byte(jsonString), &newProduct)
    fmt.Printf("%+v\n", newProduct)
}</code></pre>

                    <div style="background: #d1ecf1; border: 1px solid #bee5eb; padding: 1.5rem; border-radius: 5px; margin: 1.5rem 0;">
                        <h3 style="color: #0c5460; margin-bottom: 1rem;">üí° Tips Penting untuk API Development</h3>
                        <ul style="color: #0c5460;">
                            <li><strong>Gunakan struct tags:</strong> \`json:"field_name"\` untuk mapping JSON</li>
                            <li><strong>Error handling:</strong> Selalu handle error dengan proper error checking</li>
                            <li><strong>HTTP methods:</strong> Gunakan GET, POST, PUT, DELETE sesuai dengan operasi</li>
                            <li><strong>Status codes:</strong> Return HTTP status code yang sesuai (200, 201, 400, 404, 500)</li>
                            <li><strong>Validation:</strong> Validasi input data sebelum memproses</li>
                        </ul>
                    </div>

                    <h3>üéØ Latihan Praktis</h3>
                    <p>Mari kita buat program sederhana untuk melatih konsep-konsep yang telah dipelajari:</p>

                    <pre><code>package main

import (
    "encoding/json"
    "fmt"
    "net/http"
)

type User struct {
    ID       int    \`json:"id"\`
    Username string \`json:"username"\`
    Email    string \`json:"email"\`
}

var users []User

func getUsersHandler(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(users)
}

func createUserHandler(w http.ResponseWriter, r *http.Request) {
    var newUser User
    if err := json.NewDecoder(r.Body).Decode(&newUser); err != nil {
        http.Error(w, "Invalid JSON", http.StatusBadRequest)
        return
    }
    
    newUser.ID = len(users) + 1
    users = append(users, newUser)
    
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(newUser)
}

func main() {
    // Sample data
    users = []User{
        {ID: 1, Username: "john_doe", Email: "john@example.com"},
        {ID: 2, Username: "jane_smith", Email: "jane@example.com"},
    }
    
    http.HandleFunc("/users", func(w http.ResponseWriter, r *http.Request) {
        switch r.Method {
        case "GET":
            getUsersHandler(w, r)
        case "POST":
            createUserHandler(w, r)
        default:
            http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        }
    })
    
    fmt.Println("Server running on :8080")
    http.ListenAndServe(":8080", nil)
}</code></pre>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; border-radius: 5px; margin: 1.5rem 0;">
                        <h3 style="color: #495057; margin-bottom: 1rem;">üéØ Ringkasan Pembelajaran</h3>
                        <p style="color: #495057; margin-bottom: 1rem;">Selamat! Anda telah mempelajari dasar-dasar Go yang akan sangat berguna dalam project API toko. Konsep-konsep yang telah dipelajari:</p>
                        <ul style="color: #495057;">
                            <li>‚úÖ Struktur program Go dan package system</li>
                            <li>‚úÖ Tipe data dasar dan deklarasi variabel</li>
                            <li>‚úÖ Fungsi dan method</li>
                            <li>‚úÖ Struct untuk modeling data</li>
                            <li>‚úÖ Control flow (if, for, switch)</li>
                            <li>‚úÖ Slice dan Map untuk data collection</li>
                            <li>‚úÖ Error handling yang explicit</li>
                            <li>‚úÖ HTTP server dasar</li>
                            <li>‚úÖ JSON handling untuk API</li>
                        </ul>
                        <p style="color: #495057; margin-bottom: 0;"><strong>Sekarang Anda siap untuk memulai project API toko online!</strong> Mari kita lanjutkan ke Bab 1 untuk setup project dan implementasi yang lebih advanced.</p>
                    </div>
                `
            },
            {
                id: 'chapter1',
                title: 'Bab 1: Pengenalan',
                meta: 'Halaman 2 dari 55 ‚Ä¢ Dibaca 8 menit',
                content: `
                    <h2>Selamat Datang di Tutorial API Mini Toko Online dengan Go</h2>
                    <p>Dalam tutorial ini, kita akan belajar membuat API mini toko online menggunakan bahasa pemrograman Go. Go adalah bahasa pemrograman yang dikembangkan oleh Google yang terkenal dengan performa tinggi, kesederhanaan, dan kemudahan dalam pengembangan aplikasi web.</p>

                    <h3>Apa yang Akan Kita Pelajari?</h3>
                    <p>Sepanjang tutorial ini, kita akan membangun API toko online yang lengkap dengan fitur-fitur berikut:</p>

                    <ul>
                        <li><strong>Setup Project:</strong> Inisialisasi project dengan Go modules</li>
                        <li><strong>HTTP Server:</strong> Membuat server HTTP dengan Go standard library</li>
                        <li><strong>API Endpoints:</strong> Endpoint untuk CRUD operations (Create, Read, Update, Delete)</li>
                        <li><strong>Database Integration:</strong> Koneksi dan operasi database</li>
                        <li><strong>Middleware:</strong> Authentication, logging, dan error handling</li>
                        <li><strong>Testing:</strong> Unit testing dan integration testing</li>
                        <li><strong>Deployment:</strong> Cara deploy aplikasi ke production</li>
                    </ul>

                    <h3>Prasyarat</h3>
                    <p>Sebelum memulai, pastikan Anda telah menginstall:</p>

                    <ul>
                        <li><strong>Go 1.19+</strong> - Download dari <a href="https://golang.org/dl/" target="_blank">golang.org</a></li>
                        <li><strong>Git</strong> - Untuk version control</li>
                        <li><strong>Text Editor/IDE</strong> - VS Code, GoLand, atau editor favorit Anda</li>
                        <li><strong>Postman/Insomnia</strong> - Untuk testing API (opsional)</li>
                    </ul>

                    <h3>Tutorial Pertama: Install Go Modules</h3>
                    <p>Langkah pertama dalam membuat API mini toko online adalah menginisialisasi project dengan Go modules. Go modules adalah sistem manajemen dependensi resmi untuk Go yang memungkinkan kita mengelola package dan versi dengan mudah.</p>

                    <h4>Langkah 1: Buat Direktori Project</h4>
                    <p>Buat direktori baru untuk project kita:</p>

                    <pre><code>mkdir tokogo
cd tokogo</code></pre>

                    <h4>Langkah 2: Inisialisasi Go Module</h4>
                    <p>Jalankan perintah berikut untuk menginisialisasi Go module:</p>

                    <pre><code>go mod init tokogo</code></pre>

                    <p>Perintah ini akan membuat file <code>go.mod</code> di direktori project. File ini berisi informasi tentang module kita, termasuk nama module dan versi Go yang digunakan.</p>

                    <h4>Struktur File go.mod</h4>
                    <p>Setelah menjalankan perintah di atas, Anda akan melihat file <code>go.mod</code> dengan isi seperti ini:</p>

                    <pre><code>module tokogo

go 1.25.1</code></pre>

                    <p>File ini menunjukkan bahwa:</p>
                    <ul>
                        <li>Nama module kita adalah <code>tokogo</code></li>
                        <li>Kita menggunakan Go versi 1.25.1</li>
                    </ul>

                    <h4>Langkah 3: Verifikasi Setup</h4>
                    <p>Untuk memastikan setup berhasil, jalankan perintah berikut:</p>

                    <pre><code>go version</code></pre>

                    <p>Anda seharusnya melihat output yang menunjukkan versi Go yang terinstall.</p>

                    <blockquote>
                        <strong>Tips:</strong> Go modules memungkinkan kita untuk mengelola dependensi dengan mudah. Ketika kita mengimport package dari repository lain, Go akan otomatis menambahkannya ke file go.mod dan membuat file go.sum untuk verifikasi checksum.
                    </blockquote>

                    <h3>Langkah Selanjutnya</h3>
                    <p>Sekarang kita telah berhasil menginisialisasi project dengan Go modules. Di bab selanjutnya, kita akan belajar tentang struktur project yang baik dan mulai membangun HTTP server pertama kita.</p>

                    <p>Pastikan Anda telah memahami konsep Go modules sebelum melanjutkan ke bab berikutnya, karena ini adalah fondasi penting untuk pengembangan aplikasi Go modern.</p>
                `
            },
            {
                id: 'chapter2',
                title: 'Bab 2: Install Dependency',
                meta: 'Halaman 3 dari 55 ‚Ä¢ Dibaca 6 menit',
                content: `
                    <h2>Menginstall Dependencies untuk API Toko Online</h2>
                    <p>Setelah berhasil menginisialisasi project dengan Go modules, langkah selanjutnya adalah menginstall dependencies (package) yang dibutuhkan untuk membangun API mini toko online. Dependencies ini akan membantu kita dalam berbagai aspek pengembangan, mulai dari HTTP server hingga database operations.</p>

                    <h3>Dependencies yang Akan Kita Install</h3>
                    <p>Berikut adalah daftar dependencies yang akan kita gunakan dalam project ini:</p>

                    <ul>
                        <li><strong>Gin Framework:</strong> HTTP web framework yang cepat dan ringan</li>
                        <li><strong>GORM:</strong> Object-Relational Mapping library untuk Go</li>
                        <li><strong>MySQL Driver:</strong> Driver untuk koneksi ke database MySQL</li>
                        <li><strong>CORS Middleware:</strong> Untuk menangani Cross-Origin Resource Sharing</li>
                        <li><strong>Godotenv:</strong> Untuk memuat environment variables dari file .env</li>
                        <li><strong>JWT:</strong> Untuk implementasi JSON Web Token authentication</li>
                    </ul>

                    <h3>Langkah-langkah Instalasi</h3>
                    <p>Jalankan perintah-perintah berikut satu per satu di terminal dalam direktori project <code>tokogo</code>:</p>

                    <h4>1. Install Gin Framework</h4>
                    <p>Gin adalah HTTP web framework yang sangat populer di Go karena performanya yang tinggi dan kemudahan penggunaannya.</p>
                    <pre><code>go get -u github.com/gin-gonic/gin</code></pre>

                    <h4>2. Install GORM</h4>
                    <p>GORM adalah ORM library yang powerful untuk Go, memudahkan kita dalam berinteraksi dengan database.</p>
                    <pre><code>go get -u gorm.io/gorm</code></pre>

                    <h4>3. Install MySQL Driver untuk GORM</h4>
                    <p>Driver ini diperlukan untuk koneksi ke database MySQL.</p>
                    <pre><code>go get -u gorm.io/driver/mysql</code></pre>

                    <h4>4. Install CORS Middleware</h4>
                    <p>CORS middleware diperlukan untuk menangani request dari frontend yang berbeda domain.</p>
                    <pre><code>go get -u github.com/gin-contrib/cors</code></pre>

                    <h4>5. Install Godotenv</h4>
                    <p>Godotenv membantu kita memuat environment variables dari file .env untuk konfigurasi aplikasi.</p>
                    <pre><code>go get -u github.com/joho/godotenv</code></pre>

                    <h4>6. Install JWT Library</h4>
                    <p>JWT library untuk implementasi authentication dan authorization.</p>
                    <pre><code>go get github.com/golang-jwt/jwt</code></pre>

                    <h4>7. Install Validator Library</h4>
                    <p>Validator library untuk validasi input data dengan binding tags.</p>
                    <pre><code>go get github.com/go-playground/validator/v10@v10.26.0</code></pre>

                    <h3>Verifikasi Instalasi</h3>
                    <p>Setelah menjalankan semua perintah di atas, periksa file <code>go.mod</code> untuk memastikan semua dependencies telah terinstall:</p>

                    <pre><code>cat go.mod</code></pre>

                    <p>File <code>go.mod</code> Anda seharusnya terlihat seperti ini:</p>

                    <pre><code>module tokogo

go 1.25.1

require (
    github.com/gin-contrib/cors v1.4.0
    github.com/gin-gonic/gin v1.9.1
    github.com/go-playground/validator/v10 v10.26.0
    github.com/golang-jwt/jwt v3.2.2+incompatible
    github.com/joho/godotenv v1.4.0
    gorm.io/driver/mysql v1.5.1
    gorm.io/gorm v1.25.2
)</code></pre>

                    <h3>Penjelasan Setiap Dependency</h3>

                    <h4>üîß Gin Framework</h4>
                    <p><strong>Fungsi:</strong> HTTP web framework yang menyediakan routing, middleware, dan fitur-fitur web development lainnya.</p>
                    <p><strong>Keunggulan:</strong> Performa tinggi, sintaks yang sederhana, dan ekosistem yang luas.</p>

                    <h4>üóÑÔ∏è GORM</h4>
                    <p><strong>Fungsi:</strong> Object-Relational Mapping yang memudahkan operasi database dengan sintaks Go yang natural.</p>
                    <p><strong>Keunggulan:</strong> Auto-migration, associations, hooks, dan dukungan untuk berbagai database.</p>

                    <h4>üê¨ MySQL Driver</h4>
                    <p><strong>Fungsi:</strong> Driver resmi untuk koneksi ke database MySQL melalui GORM.</p>
                    <p><strong>Keunggulan:</strong> Optimized untuk performa dan kompatibilitas dengan MySQL.</p>

                    <h4>üåê CORS Middleware</h4>
                    <p><strong>Fungsi:</strong> Menangani Cross-Origin Resource Sharing untuk komunikasi dengan frontend.</p>
                    <p><strong>Keunggulan:</strong> Konfigurasi yang fleksibel dan mudah digunakan.</p>

                    <h4>‚öôÔ∏è Godotenv</h4>
                    <p><strong>Fungsi:</strong> Memuat environment variables dari file .env untuk konfigurasi aplikasi.</p>
                    <p><strong>Keunggulan:</strong> Memisahkan konfigurasi dari kode, meningkatkan keamanan.</p>

                    <h4>üîê JWT Library</h4>
                    <p><strong>Fungsi:</strong> Implementasi JSON Web Token untuk authentication dan authorization.</p>
                    <p><strong>Keunggulan:</strong> Stateless authentication, aman, dan mudah diimplementasikan.</p>

                    <h4>‚úÖ Validator Library</h4>
                    <p><strong>Fungsi:</strong> Library untuk validasi input data dengan binding tags yang powerful.</p>
                    <p><strong>Keunggulan:</strong> Validasi otomatis, fleksibel, dan terintegrasi dengan Gin framework.</p>

                    <blockquote>
                        <strong>Tips:</strong> Gunakan flag <code>-u</code> pada perintah <code>go get</code> untuk mengupdate ke versi terbaru dari dependencies yang sudah ada. Ini memastikan kita menggunakan versi yang paling up-to-date dan aman.
                    </blockquote>

                    <h3>File go.sum</h3>
                    <p>Setelah instalasi, Go akan otomatis membuat file <code>go.sum</code> yang berisi checksum untuk verifikasi integritas dependencies. File ini penting untuk memastikan konsistensi dependencies di berbagai environment.</p>

                    <h3>Langkah Selanjutnya</h3>
                    <p>Sekarang kita telah berhasil menginstall semua dependencies yang dibutuhkan. Di bab selanjutnya, kita akan belajar tentang struktur project yang baik dan mulai membuat file-file dasar untuk aplikasi kita.</p>

                    <p>Pastikan semua dependencies terinstall dengan benar sebelum melanjutkan ke bab berikutnya, karena kita akan menggunakan semua package ini dalam pengembangan API.</p>
                `
            },
            {
                id: 'chapter3',
                title: 'Bab 3: Struktur Folder',
                meta: 'Halaman 4 dari 55 ‚Ä¢ Dibaca 7 menit',
                content: `
                    <h2>Struktur Folder Project API Toko Online</h2>
                    <p>Setelah berhasil menginstall dependencies, langkah selanjutnya adalah membuat struktur folder yang baik dan terorganisir. Struktur folder yang rapi akan memudahkan pengembangan, maintenance, dan kolaborasi dalam tim.</p>

                    <h3>Struktur Folder yang Akan Kita Buat</h3>
                    <p>Berikut adalah struktur folder yang akan kita gunakan untuk project API mini toko online. <strong>File-file yang ditampilkan hanya sebagai contoh dan gambaran</strong> - yang penting adalah memahami struktur foldernya saja:</p>

                    <pre><code>tokogo/
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îî‚îÄ‚îÄ config.go
‚îú‚îÄ‚îÄ handlers/
‚îÇ   ‚îú‚îÄ‚îÄ auth.go
‚îÇ   ‚îú‚îÄ‚îÄ product.go
‚îÇ   ‚îî‚îÄ‚îÄ user.go
‚îú‚îÄ‚îÄ helpers/
‚îÇ   ‚îú‚îÄ‚îÄ jwt.go
‚îÇ   ‚îú‚îÄ‚îÄ response.go
‚îÇ   ‚îî‚îÄ‚îÄ validator.go
‚îú‚îÄ‚îÄ middlewares/
‚îÇ   ‚îú‚îÄ‚îÄ auth.go
‚îÇ   ‚îú‚îÄ‚îÄ cors.go
‚îÇ   ‚îî‚îÄ‚îÄ logger.go
‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îú‚îÄ‚îÄ product.go
‚îÇ   ‚îî‚îÄ‚îÄ user.go
‚îú‚îÄ‚îÄ repositories/
‚îÇ   ‚îú‚îÄ‚îÄ product.go
‚îÇ   ‚îî‚îÄ‚îÄ user.go
‚îú‚îÄ‚îÄ requests/
‚îÇ   ‚îú‚îÄ‚îÄ auth_request.go
‚îÇ   ‚îú‚îÄ‚îÄ product_request.go
‚îÇ   ‚îî‚îÄ‚îÄ user_request.go
‚îú‚îÄ‚îÄ responses/
‚îÇ   ‚îú‚îÄ‚îÄ auth_response.go
‚îÇ   ‚îú‚îÄ‚îÄ product_response.go
‚îÇ   ‚îî‚îÄ‚îÄ user_response.go
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ auth.go
‚îÇ   ‚îú‚îÄ‚îÄ product.go
‚îÇ   ‚îî‚îÄ‚îÄ user.go
‚îú‚îÄ‚îÄ main.go
‚îú‚îÄ‚îÄ .env
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ go.mod
‚îú‚îÄ‚îÄ go.sum
‚îî‚îÄ‚îÄ README.md</code></pre>

                    <h3>Penjelasan Setiap Folder</h3>
                    <p><em>Catatan: Nama file yang disebutkan di bawah ini hanya sebagai contoh. Yang penting adalah memahami fungsi setiap folder.</em></p>

                    <h4>üìÅ config/</h4>
                    <p><strong>Fungsi:</strong> Berisi konfigurasi aplikasi dan environment variables</p>
                    <p><strong>Contoh file:</strong> <code>config.go</code> - Load dan manage konfigurasi dari .env</p>

                    <h4>üìÅ handlers/</h4>
                    <p><strong>Fungsi:</strong> HTTP handlers (controllers) yang menangani request dari client</p>
                    <p><strong>Contoh file:</strong></p>
                    <ul>
                        <li><code>auth.go</code> - Handler untuk authentication (login, register)</li>
                        <li><code>product.go</code> - Handler untuk CRUD produk</li>
                        <li><code>user.go</code> - Handler untuk manajemen user</li>
                    </ul>

                    <h4>üìÅ helpers/</h4>
                    <p><strong>Fungsi:</strong> Utility functions dan helper yang bisa digunakan di seluruh aplikasi</p>
                    <p><strong>Contoh file:</strong></p>
                    <ul>
                        <li><code>jwt.go</code> - JWT token generation dan validation</li>
                        <li><code>response.go</code> - Standard response format</li>
                        <li><code>validator.go</code> - Custom validation functions</li>
                    </ul>

                    <h4>üìÅ middlewares/</h4>
                    <p><strong>Fungsi:</strong> Middleware functions untuk intercept request/response</p>
                    <p><strong>Contoh file:</strong></p>
                    <ul>
                        <li><code>auth.go</code> - Authentication middleware</li>
                        <li><code>cors.go</code> - CORS configuration</li>
                        <li><code>logger.go</code> - Request logging</li>
                    </ul>

                    <h4>üìÅ models/</h4>
                    <p><strong>Fungsi:</strong> Data models/structs yang merepresentasikan database tables</p>
                    <p><strong>Contoh file:</strong></p>
                    <ul>
                        <li><code>product.go</code> - Product model struct</li>
                        <li><code>user.go</code> - User model struct</li>
                    </ul>

                    <h4>üìÅ repositories/</h4>
                    <p><strong>Fungsi:</strong> Data access layer untuk berinteraksi dengan database</p>
                    <p><strong>Contoh file:</strong></p>
                    <ul>
                        <li><code>product.go</code> - Product database operations</li>
                        <li><code>user.go</code> - User database operations</li>
                    </ul>

                    <h4>üìÅ requests/</h4>
                    <p><strong>Fungsi:</strong> Request structs untuk validasi input dari client</p>
                    <p><strong>Contoh file:</strong></p>
                    <ul>
                        <li><code>auth_request.go</code> - Login/Register request structs</li>
                        <li><code>product_request.go</code> - Product CRUD request structs</li>
                        <li><code>user_request.go</code> - User management request structs</li>
                    </ul>

                    <h4>üìÅ responses/</h4>
                    <p><strong>Fungsi:</strong> Response structs untuk format output yang konsisten</p>
                    <p><strong>Contoh file:</strong></p>
                    <ul>
                        <li><code>auth_response.go</code> - Authentication response structs</li>
                        <li><code>product_response.go</code> - Product response structs</li>
                        <li><code>user_response.go</code> - User response structs</li>
                    </ul>

                    <h4>üìÅ services/</h4>
                    <p><strong>Fungsi:</strong> Business logic layer yang mengatur alur aplikasi</p>
                    <p><strong>Contoh file:</strong></p>
                    <ul>
                        <li><code>auth.go</code> - Authentication business logic</li>
                        <li><code>product.go</code> - Product business logic</li>
                        <li><code>user.go</code> - User business logic</li>
                    </ul>

                    <h4>üìÑ main.go</h4>
                    <p><strong>Fungsi:</strong> Entry point aplikasi yang menjalankan HTTP server</p>
                    <p><strong>Isi:</strong> Server setup, route configuration, dan middleware setup</p>

                    <h3>Langkah-langkah Membuat Struktur Folder</h3>

                    <h4>1. Buat Folder Utama</h4>
                    <p>Pastikan Anda sudah berada di direktori project <code>tokogo</code>:</p>
                    <pre><code>pwd
# Output: /path/to/your/project/tokogo</code></pre>

                    <h4>2. Buat Struktur Folder</h4>
                    <p>Jalankan perintah berikut untuk membuat semua folder sekaligus:</p>
                    <pre><code>mkdir -p config
mkdir -p handlers
mkdir -p helpers
mkdir -p middlewares
mkdir -p models
mkdir -p repositories
mkdir -p requests
mkdir -p responses
mkdir -p services</code></pre>

                    <h4>3. Verifikasi Struktur</h4>
                    <p>Gunakan command <code>tree</code> untuk melihat struktur folder:</p>
                    <pre><code>tree -d</code></pre>

                    <p>Jika <code>tree</code> tidak tersedia, gunakan:</p>
                    <pre><code>find . -type d | sort</code></pre>

                    <h3>File-file Konfigurasi</h3>

                    <h4>.env</h4>
                    <p>File untuk menyimpan environment variables:</p>
                    <pre><code># Database Configuration
DB_HOST=localhost
DB_PORT=3306
DB_USER=root
DB_PASSWORD=password
DB_NAME=tokogo

# Server Configuration
SERVER_PORT=8080
JWT_SECRET=your-secret-key

# Environment
ENV=development</code></pre>

                    <h4>.gitignore</h4>
                    <p>File untuk mengabaikan file tertentu dari Git:</p>
                    <pre><code># Binaries for programs and plugins
*.exe
*.exe~
*.dll
*.so
*.dylib

# Test binary, built with \`go test -c\`
*.test

# Output of the go coverage tool
*.out

# Dependency directories
vendor/

# Go workspace file
go.work

# Environment variables
.env
.env.local

# IDE files
.vscode/
.idea/
*.swp
*.swo

# OS generated files
.DS_Store
Thumbs.db</code></pre>

                    <h3>Arsitektur Pattern yang Digunakan</h3>

                    <h4>üèóÔ∏è Layered Architecture</h4>
                    <p>Struktur ini mengikuti prinsip Layered Architecture dengan pemisahan layer yang jelas:</p>
                    <ul>
                        <li><strong>Handlers:</strong> Layer presentasi (HTTP requests/responses)</li>
                        <li><strong>Services:</strong> Layer business logic</li>
                        <li><strong>Repositories:</strong> Layer data access</li>
                        <li><strong>Models:</strong> Data structures</li>
                        <li><strong>Requests/Responses:</strong> Data transfer objects</li>
                        <li><strong>Helpers:</strong> Utility functions</li>
                        <li><strong>Middlewares:</strong> Cross-cutting concerns</li>
                    </ul>

                    <h4>üîÑ Dependency Flow</h4>
                    <p>Alur dependency mengalir dari luar ke dalam:</p>
                    <pre><code>Handlers ‚Üí Services ‚Üí Repositories ‚Üí Database
    ‚Üì         ‚Üì         ‚Üì
Requests  Responses  Models</code></pre>

                    <h4>üìã Request/Response Pattern</h4>
                    <p>Struktur ini menggunakan pattern Request/Response yang memisahkan:</p>
                    <ul>
                        <li><strong>Requests:</strong> Input validation dan data binding</li>
                        <li><strong>Responses:</strong> Output formatting dan serialization</li>
                        <li><strong>Models:</strong> Database entities</li>
                    </ul>

                    <blockquote>
                        <strong>Tips:</strong> Struktur folder ini mengikuti standar Go project layout yang direkomendasikan oleh komunitas Go. Ini akan memudahkan developer lain untuk memahami dan berkontribusi pada project.
                    </blockquote>

                    <h3>Langkah Selanjutnya</h3>
                    <p>Sekarang kita telah berhasil membuat struktur folder yang rapi dan terorganisir. Di bab selanjutnya, kita akan mulai membuat file-file dasar dan mengimplementasikan HTTP server pertama kita menggunakan Gin framework.</p>

                    <p><strong>Catatan Penting:</strong> File-file yang akan kita buat di bab selanjutnya mungkin memiliki nama atau struktur yang berbeda dengan contoh di atas. Yang penting adalah memahami konsep dan fungsi setiap folder. Struktur folder yang kita buat ini akan menjadi fondasi untuk pengembangan selanjutnya.</p>
                `
            },
            {
                id: 'chapter4',
                title: 'Bab 4: Konfigurasi Kode',
                meta: 'Halaman 5 dari 55 ‚Ä¢ Dibaca 8 menit',
                content: `
                    <h2>Konfigurasi Kode dan Environment Variables</h2>
                    <p>Setelah membuat struktur folder, langkah selanjutnya adalah membuat file-file konfigurasi yang akan mengatur environment variables dan koneksi database. Konfigurasi yang baik akan memudahkan deployment dan maintenance aplikasi.</p>

                    <h3>Langkah-langkah yang Akan Kita Lakukan</h3>
                    <p>Sebelum membuat file konfigurasi, kita perlu memastikan database MySQL sudah siap. Berikut urutan yang akan kita lakukan:</p>
                    <ol>
                        <li><strong>Setup Database MySQL</strong> - Membuat database dan user</li>
                        <li><strong>File .env</strong> - Environment variables</li>
                        <li><strong>config/env.go</strong> - Helper function untuk membaca environment variables</li>
                        <li><strong>config/database.go</strong> - Konfigurasi koneksi database</li>
                    </ol>

                    <h3>1. Setup Database MySQL</h3>
                    <p>Sebelum membuat konfigurasi, kita perlu memastikan database MySQL sudah berjalan dan database 'tokogo' sudah dibuat. Ada 2 cara yang bisa digunakan:</p>

                    <h4>üîß Cara 1: Menggunakan Command Line (CMD/Terminal)</h4>
                    <p>Jika Anda sudah familiar dengan command line, cara ini lebih cepat:</p>

                    <h5>Langkah 1: Buka MySQL Command Line</h5>
                    <p>Buka Command Prompt atau Terminal, lalu login ke MySQL:</p>
                    <pre><code>mysql -u root -p</code></pre>
                    <p>Masukkan password MySQL Anda (jika ada). Jika tidak ada password, langsung tekan Enter.</p>

                    <h5>Langkah 2: Buat Database</h5>
                    <p>Setelah berhasil login, buat database 'tokogo':</p>
                    <pre><code>CREATE DATABASE tokogo;</code></pre>

                    <h5>Langkah 3: Verifikasi Database</h5>
                    <p>Pastikan database berhasil dibuat:</p>
                    <pre><code>SHOW DATABASES;</code></pre>
                    <p>Anda seharusnya melihat 'tokogo' dalam daftar database.</p>

                    <h5>Langkah 4: Keluar dari MySQL</h5>
                    <pre><code>EXIT;</code></pre>

                    <h4>üåê Cara 2: Menggunakan phpMyAdmin (Lebih Mudah untuk Pemula)</h4>
                    <p>Jika Anda menggunakan XAMPP, WAMP, atau Laragon, cara ini lebih mudah:</p>

                    <h5>Langkah 1: Buka phpMyAdmin</h5>
                    <p>Buka browser dan akses: <code>http://localhost/phpmyadmin</code></p>

                    <h5>Langkah 2: Buat Database Baru</h5>
                    <p>Klik tab "Databases" di bagian atas, lalu:</p>
                    <ol>
                        <li>Masukkan nama database: <code>tokogo</code></li>
                        <li>Pilih Collation: <code>utf8mb4_unicode_ci</code> (opsional)</li>
                        <li>Klik tombol "Create"</li>
                    </ol>

                    <h5>Langkah 3: Verifikasi</h5>
                    <p>Database 'tokogo' akan muncul di sidebar kiri, klik untuk memastikan database kosong dan siap digunakan.</p>

                    <h4>‚ö†Ô∏è Troubleshooting</h4>
                    <p>Jika mengalami masalah:</p>
                    <ul>
                        <li><strong>MySQL tidak berjalan:</strong> Pastikan XAMPP/WAMP/Laragon sudah di-start</li>
                        <li><strong>Access denied:</strong> Coba tanpa password atau reset password MySQL</li>
                        <li><strong>Database sudah ada:</strong> Tidak masalah, bisa langsung digunakan</li>
                    </ul>

                    <blockquote>
                        <strong>Tips untuk Pemula:</strong> Jika Anda baru belajar, gunakan phpMyAdmin karena lebih visual dan mudah. Command line bisa dipelajari nanti setelah familiar dengan database.
                    </blockquote>

                    <h3>2. Membuat File .env</h3>
                    <p>File .env berisi environment variables yang akan digunakan oleh aplikasi. Buat file ini di root directory project:</p>

                    <pre><code># Database Configuration
DB_HOST=localhost
DB_PORT=3306
DB_USER=root
DB_PASSWORD=
DB_NAME=tokogo

# Server Configuration
SERVER_PORT=8080
JWT_SECRET=your-super-secret-jwt-key-here

# Environment
ENV=development</code></pre>

                    <h4>Penjelasan Environment Variables:</h4>
                    <ul>
                        <li><strong>DB_HOST:</strong> Host database (localhost untuk development)</li>
                        <li><strong>DB_PORT:</strong> Port database MySQL (default 3306)</li>
                        <li><strong>DB_USER:</strong> Username database</li>
                        <li><strong>DB_PASSWORD:</strong> Password database (kosong jika tidak ada)</li>
                        <li><strong>DB_NAME:</strong> Nama database yang akan digunakan</li>
                        <li><strong>SERVER_PORT:</strong> Port untuk HTTP server</li>
                        <li><strong>JWT_SECRET:</strong> Secret key untuk JWT token (ganti dengan key yang aman)</li>
                        <li><strong>ENV:</strong> Environment aplikasi (development/production)</li>
                    </ul>

                    <h3>3. Membuat File config/env.go</h3>
                    <p>File ini berisi helper function untuk membaca environment variables dengan default value:</p>

                    <pre><code>package config

import "os"

func GetEnv(key, defaultVal string) string {
    if value, exists := os.LookupEnv(key); exists && value != "" {
        return value
    }
    return defaultVal
}</code></pre>

                    <h4>Penjelasan Function GetEnv:</h4>
                    <ul>
                        <li><strong>Parameter key:</strong> Nama environment variable</li>
                        <li><strong>Parameter defaultVal:</strong> Nilai default jika environment variable tidak ditemukan</li>
                        <li><strong>Return:</strong> Nilai environment variable atau default value</li>
                    </ul>

                    <h3>4. Membuat File config/database.go</h3>
                    <p>File ini berisi konfigurasi koneksi database menggunakan GORM:</p>

                    <pre><code>package config

import (
    "fmt"
    "time"

    "tokogo/models"

    "gorm.io/driver/mysql"
    "gorm.io/gorm"
    "gorm.io/gorm/schema"
)

var DB *gorm.DB

func InitDB() {
    // Ambil konfigurasi database dari environment variables
    dbUser := GetEnv("DB_USER", "root")
    dbPassword := GetEnv("DB_PASSWORD", "")
    dbHost := GetEnv("DB_HOST", "localhost")
    dbPort := GetEnv("DB_PORT", "3306")
    dbName := GetEnv("DB_NAME", "tokogo")

    // Buat DSN (Data Source Name) untuk koneksi MySQL
    dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local",
        dbUser, dbPassword, dbHost, dbPort, dbName)

    var err error

    // Buka koneksi database menggunakan GORM
    DB, err = gorm.Open(mysql.Open(dsn), &gorm.Config{
        NamingStrategy: schema.NamingStrategy{
            SingularTable: true, // Gunakan nama table singular
        },
    })
    if err != nil {
        panic(fmt.Sprintf("Failed to connect to database: %v", err))
    }

    // Konfigurasi connection pool
    sqlDB, err := DB.DB()
    if err != nil {
        panic("Failed to get database instance!")
    }

    // Set connection pool settings
    sqlDB.SetMaxOpenConns(10)    // Maksimal 10 koneksi terbuka
    sqlDB.SetMaxIdleConns(5)     // Maksimal 5 koneksi idle
    sqlDB.SetConnMaxLifetime(time.Hour) // Maksimal 1 jam lifetime

    // Auto migrate model User (akan kita buat di bab selanjutnya)
    if err := DB.AutoMigrate(&models.User{}); err != nil {
        panic(fmt.Sprintf("AutoMigrate failed: %v", err))
    }
}</code></pre>

                    <h4>Penjelasan Konfigurasi Database:</h4>
                    <ul>
                        <li><strong>DSN:</strong> Data Source Name untuk koneksi MySQL</li>
                        <li><strong>SingularTable:</strong> Menggunakan nama table singular (user bukan users)</li>
                        <li><strong>Connection Pool:</strong> Mengatur jumlah koneksi maksimal</li>
                        <li><strong>AutoMigrate:</strong> Otomatis membuat/update table berdasarkan model</li>
                    </ul>

                    <h3>5. Membuat File .gitignore</h3>
                    <p>Pastikan file .env tidak di-commit ke Git untuk keamanan:</p>

                    <pre><code># Environment variables
.env
.env.local
.env.production

# Binaries
*.exe
*.exe~
*.dll
*.so
*.dylib

# Test binary
*.test

# Go workspace file
go.work

# IDE files
.vscode/
.idea/
*.swp
*.swo

# OS generated files
.DS_Store
Thumbs.db</code></pre>

                    <h3>6. Load Environment Variables di main.go</h3>
                    <p>Untuk menggunakan godotenv, kita perlu memuat file .env di awal aplikasi:</p>

                    <pre><code>package main

import (
    "log"

    "github.com/joho/godotenv"
    "tokogo/config"
)

func main() {
    // Load environment variables dari file .env
    if err := godotenv.Load(); err != nil {
        log.Println("No .env file found, using system environment variables")
    }

    // Initialize database connection
    config.InitDB()
    
    // Rest of your application code...
}</code></pre>

                    <h3>Keunggulan Konfigurasi Ini</h3>

                    <h4>üîí Keamanan</h4>
                    <ul>
                        <li>Environment variables tidak di-commit ke Git</li>
                        <li>Konfigurasi berbeda untuk development dan production</li>
                        <li>Secret keys tidak ter-expose di kode</li>
                    </ul>

                    <h4>‚öôÔ∏è Fleksibilitas</h4>
                    <ul>
                        <li>Mudah mengubah konfigurasi tanpa mengubah kode</li>
                        <li>Default values untuk development</li>
                        <li>Support multiple environments</li>
                    </ul>

                    <h4>üöÄ Deployment</h4>
                    <ul>
                        <li>Mudah deploy ke server dengan environment variables</li>
                        <li>Konfigurasi database yang optimal</li>
                        <li>Connection pooling untuk performa</li>
                    </ul>

                    <blockquote>
                        <strong>Tips:</strong> Selalu gunakan environment variables untuk konfigurasi yang sensitif seperti database credentials dan JWT secret. Jangan pernah hardcode nilai-nilai ini di kode.
                    </blockquote>

                    <h3>7. Verifikasi Setup Database</h3>
                    <p>Setelah membuat semua file konfigurasi, mari kita verifikasi bahwa setup database sudah benar:</p>

                    <h4>‚úÖ Checklist Verifikasi:</h4>
                    <ul>
                        <li>‚úÖ MySQL server sudah berjalan (XAMPP/WAMP/Laragon sudah di-start)</li>
                        <li>‚úÖ Database 'tokogo' sudah dibuat</li>
                        <li>‚úÖ File .env sudah dibuat dengan konfigurasi yang benar</li>
                        <li>‚úÖ File config/env.go sudah dibuat</li>
                        <li>‚úÖ File config/database.go sudah dibuat</li>
                        <li>‚úÖ File .gitignore sudah dibuat</li>
                    </ul>

                    <h4>üß™ Test Koneksi Database (Opsional)</h4>
                    <p>Jika ingin memastikan koneksi database berfungsi, buat file test sederhana:</p>

                    <pre><code>package main

import (
    "fmt"
    "log"

    "github.com/joho/godotenv"
    "tokogo/config"
)

func main() {
    // Load environment variables
    if err := godotenv.Load(); err != nil {
        log.Println("No .env file found, using system environment variables")
    }

    // Test database connection
    fmt.Println("Testing database connection...")
    config.InitDB()
    fmt.Println("‚úÖ Database connection successful!")
}</code></pre>

                    <p>Jalankan dengan: <code>go run main.go</code></p>

                    <h3>Langkah Selanjutnya</h3>
                    <p>Sekarang kita telah berhasil membuat konfigurasi dasar untuk aplikasi. Di bab selanjutnya, kita akan membuat model User dan mulai mengimplementasikan HTTP server dengan Gin framework.</p>

                    <p><strong>Catatan Penting:</strong> Pastikan semua checklist di atas sudah terpenuhi sebelum melanjutkan ke bab selanjutnya. Jika ada error saat test koneksi database, periksa kembali konfigurasi MySQL dan file .env Anda.</p>
                `
            },
            {
                id: 'chapter5',
                title: 'Bab 5: Relaksasi & Review',
                meta: 'Halaman 6 dari 55 ‚Ä¢ Dibaca 12 menit',
                content: `
                    <h2>Bab Relaksasi & Review Pembelajaran</h2>
                    <p>Selamat! Anda telah menyelesaikan 4 bab pertama dari tutorial API Mini Toko Online dengan Go. Sekarang saatnya untuk beristirahat sejenak dan mengulas kembali semua yang telah dipelajari. Bab ini dirancang untuk membantu otak Anda mengkonsolidasikan pengetahuan yang baru saja diperoleh.</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">üß† Mengapa Review Penting?</h3>
                        <p style="color: #495057; margin-bottom: 0;">Penelitian menunjukkan bahwa mengulang materi dalam 24 jam pertama dapat meningkatkan retensi memori hingga 80%. Mari kita manfaatkan momen ini untuk memperkuat pemahaman Anda!</p>
                    </div>

                    <h3>Ringkasan Pembelajaran Bab 1-4</h3>
                    <p>Sebelum masuk ke pertanyaan review, mari kita ingat kembali perjalanan pembelajaran yang telah kita lalui:</p>

                    <h4>Bab 1: Pengenalan Go Modules</h4>
                    <ul>
                        <li>‚úÖ Memahami konsep Go modules dan manajemen dependensi</li>
                        <li>‚úÖ Inisialisasi project dengan <code>go mod init tokogo</code></li>
                        <li>‚úÖ Struktur file <code>go.mod</code> dan <code>go.sum</code></li>
                        <li>‚úÖ Prasyarat pengembangan Go (Go 1.19+, Git, IDE)</li>
                    </ul>

                    <h4>Bab 2: Install Dependencies</h4>
                    <ul>
                        <li>‚úÖ Gin Framework untuk HTTP web framework</li>
                        <li>‚úÖ GORM untuk Object-Relational Mapping</li>
                        <li>‚úÖ MySQL Driver untuk koneksi database</li>
                        <li>‚úÖ CORS Middleware untuk Cross-Origin Resource Sharing</li>
                        <li>‚úÖ Godotenv untuk environment variables</li>
                        <li>‚úÖ JWT Library untuk authentication</li>
                    </ul>

                    <h4>Bab 3: Struktur Folder</h4>
                    <ul>
                        <li>‚úÖ Layered Architecture pattern</li>
                        <li>‚úÖ Pemisahan concerns (handlers, services, repositories)</li>
                        <li>‚úÖ Request/Response pattern</li>
                        <li>‚úÖ Dependency flow yang jelas</li>
                        <li>‚úÖ Struktur folder yang scalable</li>
                    </ul>

                    <h4>Bab 4: Konfigurasi Kode</h4>
                    <ul>
                        <li>‚úÖ Setup database MySQL</li>
                        <li>‚úÖ Environment variables dengan file .env</li>
                        <li>‚úÖ Konfigurasi koneksi database dengan GORM</li>
                        <li>‚úÖ Connection pooling untuk performa</li>
                        <li>‚úÖ Auto-migration untuk database schema</li>
                    </ul>

                    <h3>Pertanyaan Review Interaktif</h3>
                    <p>Mari kita uji pemahaman Anda dengan pertanyaan-pertanyaan yang dirancang untuk mengaktifkan kembali memori dan memperkuat pembelajaran:</p>

                    <div style="background: #f8f9fa; border-left: 4px solid #3498db; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Bagian A: Konsep Dasar Go Modules</h4>
                        
                        <p><strong>1. Apa fungsi utama dari file go.mod dalam project Go?</strong></p>
                        <p style="color: #666; font-style: italic;">üí° Petunjuk: Pikirkan tentang manajemen dependensi dan versi...</p>
                        
                        <p><strong>2. Mengapa kita menggunakan flag -u pada perintah go get?</strong></p>
                        <p style="color: #666; font-style: italic;">üí° Petunjuk: Apa yang terjadi jika kita tidak menggunakan flag ini?</p>
                        
                        <p><strong>3. Apa perbedaan antara go.mod dan go.sum?</strong></p>
                        <p style="color: #666; font-style: italic;">üí° Petunjuk: Satu untuk metadata, satu untuk keamanan...</p>
                    </div>

                    <div style="background: #f8f9fa; border-left: 4px solid #e74c3c; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Bagian B: Dependencies & Framework</h4>
                        
                        <p><strong>4. Mengapa kita memilih Gin Framework dibanding HTTP server bawaan Go?</strong></p>
                        <p style="color: #666; font-style: italic;">üí° Petunjuk: Pikirkan tentang routing, middleware, dan kemudahan...</p>
                        
                        <p><strong>5. Apa keunggulan GORM dibanding menulis SQL query manual?</strong></p>
                        <p style="color: #666; font-style: italic;">üí° Petunjuk: Auto-migration, associations, hooks...</p>
                        
                        <p><strong>6. Kapan kita membutuhkan CORS middleware?</strong></p>
                        <p style="color: #666; font-style: italic;">üí° Petunjuk: Frontend dan backend di domain berbeda...</p>
                        
                        <p><strong>7. Mengapa JWT lebih baik dari session-based authentication untuk API?</strong></p>
                        <p style="color: #666; font-style: italic;">üí° Petunjuk: Stateless, scalable, cross-domain...</p>
                    </div>

                    <div style="background: #f8f9fa; border-left: 4px solid #f39c12; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Bagian C: Arsitektur & Struktur</h4>
                        
                        <p><strong>8. Jelaskan alur dependency flow dalam arsitektur yang kita buat!</strong></p>
                        <p style="color: #666; font-style: italic;">üí° Petunjuk: Handlers ‚Üí Services ‚Üí Repositories ‚Üí Database</p>
                        
                        <p><strong>9. Mengapa kita memisahkan requests dan responses dari models?</strong></p>
                        <p style="color: #666; font-style: italic;">üí° Petunjuk: Validasi input, format output, keamanan...</p>
                        
                        <p><strong>10. Apa fungsi dari folder helpers dan middlewares?</strong></p>
                        <p style="color: #666; font-style: italic;">üí° Petunjuk: Satu untuk utility, satu untuk intercept...</p>
                        
                        <p><strong>11. Bagaimana Layered Architecture membantu dalam maintenance code?</strong></p>
                        <p style="color: #666; font-style: italic;">üí° Petunjuk: Separation of concerns, testability...</p>
                    </div>

                    <div style="background: #f8f9fa; border-left: 4px solid #27ae60; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Bagian D: Konfigurasi & Database</h4>
                        
                        <p><strong>12. Mengapa kita menggunakan environment variables untuk konfigurasi?</strong></p>
                        <p style="color: #666; font-style: italic;">üí° Petunjuk: Keamanan, fleksibilitas, deployment...</p>
                        
                        <p><strong>13. Apa fungsi dari connection pooling dalam database?</strong></p>
                        <p style="color: #666; font-style: italic;">üí° Petunjuk: Performa, resource management...</p>
                        
                        <p><strong>14. Mengapa kita menggunakan AutoMigrate di GORM?</strong></p>
                        <p style="color: #666; font-style: italic;">üí° Petunjuk: Schema management, development speed...</p>
                        
                        <p><strong>15. Apa yang terjadi jika file .env tidak ditemukan saat aplikasi berjalan?</strong></p>
                        <p style="color: #666; font-style: italic;">üí° Petunjuk: Fallback ke system environment variables...</p>
                    </div>

                    <h3>üéØ Latihan Praktis</h3>
                    <p>Sekarang mari kita praktikkan dengan beberapa latihan yang akan memperkuat pemahaman Anda:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>üíª Latihan 1: Membuat Project Baru</h4>
                        <p><strong>Tantangan:</strong> Buat project Go baru dengan nama "my-shop-api" dan install minimal 3 dependencies yang berbeda dari yang sudah kita pelajari.</p>
                        <p><strong>Langkah:</strong></p>
                        <ol>
                            <li>Buat direktori baru</li>
                            <li>Inisialisasi Go module</li>
                            <li>Install 3 dependencies baru (bisa dari <a href="https://pkg.go.dev/" target="_blank">pkg.go.dev</a>)</li>
                            <li>Verifikasi file go.mod dan go.sum</li>
                        </ol>
                    </div>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>üèóÔ∏è Latihan 2: Merancang Struktur Folder</h4>
                        <p><strong>Tantangan:</strong> Rancang struktur folder untuk aplikasi "blog-api" yang memiliki fitur artikel, komentar, dan user management.</p>
                        <p><strong>Pertimbangkan:</strong></p>
                        <ul>
                            <li>Berapa banyak folder yang dibutuhkan?</li>
                            <li>Bagaimana dependency flow-nya?</li>
                            <li>File apa saja yang ada di setiap folder?</li>
                        </ul>
                    </div>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>‚öôÔ∏è Latihan 3: Konfigurasi Environment</h4>
                        <p><strong>Tantangan:</strong> Buat file .env untuk aplikasi production dengan konfigurasi yang aman.</p>
                        <p><strong>Include:</strong></p>
                        <ul>
                            <li>Database configuration (production)</li>
                            <li>Server configuration</li>
                            <li>Security keys</li>
                            <li>External API keys</li>
                        </ul>
                    </div>

                    <h3>üß† Teknik Memori untuk Developer</h3>
                    <p>Sebagai bonus, berikut beberapa teknik yang bisa membantu Anda mengingat konsep-konsep programming:</p>

                    <h4>üîó Association Technique</h4>
                    <p>Hubungkan konsep baru dengan yang sudah familiar:</p>
                    <ul>
                        <li><strong>Go Modules</strong> ‚Üí seperti <strong>package.json</strong> di Node.js</li>
                        <li><strong>GORM</strong> ‚Üí seperti <strong>Eloquent</strong> di Laravel</li>
                        <li><strong>Gin Framework</strong> ‚Üí seperti <strong>Express.js</strong> di Node.js</li>
                        <li><strong>Environment Variables</strong> ‚Üí seperti <strong>config files</strong> di framework lain</li>
                    </ul>

                    <h4>üéØ Spaced Repetition</h4>
                    <p>Jadwal review yang optimal:</p>
                    <ul>
                        <li><strong>Hari 1:</strong> Review setelah 24 jam (sekarang!)</li>
                        <li><strong>Hari 3:</strong> Review singkat konsep utama</li>
                        <li><strong>Minggu 1:</strong> Praktik dengan project kecil</li>
                        <li><strong>Bulan 1:</strong> Implementasi dalam project real</li>
                    </ul>

                    <h4>üí° Active Recall</h4>
                    <p>Coba jawab pertanyaan tanpa melihat materi:</p>
                    <ul>
                        <li>Tutup ebook dan coba jelaskan Go modules</li>
                        <li>Gambarkan struktur folder tanpa melihat</li>
                        <li>List dependencies yang sudah diinstall</li>
                    </ul>

                    <h3>üéâ Refleksi Pembelajaran</h3>
                    <p>Mari kita refleksikan apa yang telah dipelajari:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #2c3e50;">üìä Self-Assessment</h4>
                        <p><strong>Rate pemahaman Anda (1-5):</strong></p>
                        <ul style="color: #495057;">
                            <li>Go Modules: ___/5</li>
                            <li>Dependencies Management: ___/5</li>
                            <li>Project Structure: ___/5</li>
                            <li>Database Configuration: ___/5</li>
                        </ul>
                        <p style="color: #495057;"><strong>Area yang perlu diperkuat:</strong> _________________</p>
                    </div>

                    <h3>üöÄ Persiapan Bab Selanjutnya</h3>
                    <p>Setelah beristirahat dan review, kita akan melanjutkan ke bab yang lebih menarik:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>üéØ Preview Bab 6: Model & Database Schema</h4>
                        <p>Di bab selanjutnya, kita akan:</p>
                        <ul>
                            <li>‚úÖ Membuat model User dengan GORM</li>
                            <li>‚úÖ Implementasi database schema</li>
                            <li>‚úÖ Validasi data dengan struct tags</li>
                            <li>‚úÖ Relationship antar model</li>
                        </ul>
                    </div>

                    <blockquote style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 1rem; margin: 2rem 0;">
                        <strong>üí° Tips untuk Bab Selanjutnya:</strong> Pastikan Anda sudah memahami konsep struct di Go dan basic database operations. Jika belum, luangkan waktu 10 menit untuk review materi Go fundamentals tentang struct dan interface.
                    </blockquote>

                    <h3>üéä Selamat!</h3>
                    <p>Anda telah berhasil menyelesaikan review bab 1-4! Otak Anda sekarang telah mengkonsolidasikan pengetahuan tentang Go modules, dependencies, project structure, dan database configuration. Ini adalah fondasi yang kuat untuk melanjutkan perjalanan pengembangan API.</p>

                  
                `
            },
            {
                id: 'chapter6',
                title: 'Bab 6: Modul Authentication - Register',
                meta: 'Halaman 7 dari 55 ‚Ä¢ Dibaca 8 menit',
                content: `
                    <h2>üîê Bab 6: Modul Authentication - Register</h2>
                    <p>Selamat! Sekarang kita akan mulai membangun fitur authentication yang merupakan fondasi keamanan untuk API toko online. Kita akan mulai dengan modul Register terlebih dahulu, kemudian dilanjutkan dengan Login dan Logout di bab-bab selanjutnya.</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">üéØ Apa yang Akan Kita Buat di Bab Ini?</h3>
                        <p style="color: #495057; margin-bottom: 0;">Kita akan membuat sistem register user baru dengan validasi, password hashing, dan JWT token generation. Setelah selesai, kita akan test menggunakan Postman.</p>
                    </div>

                    <h3>üìã Database Schema User</h3>
                    <p>Berikut adalah struktur database untuk user:</p>

                    <pre><code>CREATE TABLE user (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    role ENUM('customer', 'admin') DEFAULT 'customer',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL
);</code></pre>

                    <h3>üèóÔ∏è Struktur File yang Akan Kita Buat</h3>
                    <p>Kita akan mengikuti struktur pattern folder yang sudah ada. Berikut file-file yang akan kita buat:</p>

                    <pre><code>tokogo/
‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îî‚îÄ‚îÄ user.go                    # User model struct
‚îú‚îÄ‚îÄ requests/
‚îÇ   ‚îî‚îÄ‚îÄ auth_request.go           # Request structs untuk auth
‚îú‚îÄ‚îÄ responses/
‚îÇ   ‚îî‚îÄ‚îÄ auth_response.go          # Response structs untuk auth
‚îú‚îÄ‚îÄ repositories/
‚îÇ   ‚îî‚îÄ‚îÄ auth_repository.go        # Database operations
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îî‚îÄ‚îÄ auth_service.go           # Business logic
‚îú‚îÄ‚îÄ handlers/
‚îÇ   ‚îî‚îÄ‚îÄ auth_handler.go           # HTTP handlers
‚îú‚îÄ‚îÄ helpers/
‚îÇ   ‚îî‚îÄ‚îÄ jwt.go                    # JWT helper functions
‚îî‚îÄ‚îÄ middlewares/
    ‚îî‚îÄ‚îÄ auth.go                   # Authentication middleware</code></pre>

                    <h3>üìù Langkah 1: Membuat User Model</h3>
                    <p>Pertama, kita buat model User di file <code>models/user.go</code>:</p>

                    <pre><code>package models

import (
    "time"
    "gorm.io/gorm"
)

type User struct {
    ID        uint           \`gorm:"primaryKey;column:id;type:BIGINT UNSIGNED AUTO_INCREMENT" json:"id"\`
    Name      string         \`gorm:"column:name;type:VARCHAR(255);not null" json:"name"\`
    Email     string         \`gorm:"column:email;type:VARCHAR(255);uniqueIndex;not null" json:"email"\`
    Password  string         \`gorm:"column:password;type:VARCHAR(255);not null" json:"-"\` // Hidden dari JSON response
    Role      string         \`gorm:"column:role;type:ENUM('customer','admin');default:'customer'" json:"role"\`
    CreatedAt time.Time      \`gorm:"column:created_at;type:TIMESTAMP DEFAULT CURRENT_TIMESTAMP" json:"created_at"\`
    UpdatedAt time.Time      \`gorm:"column:updated_at;type:TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP" json:"updated_at"\`
    DeletedAt gorm.DeletedAt \`gorm:"column:deleted_at;type:TIMESTAMP NULL;index" json:"-"\`
}

// TableName mengembalikan nama tabel untuk model User
func (User) TableName() string {
    return "user"
}</code></pre>

                    <h4>Penjelasan Model User:</h4>
                    <ul>
                        <li><strong>ID:</strong> Primary key dengan auto increment</li>
                        <li><strong>Name:</strong> Nama user (required)</li>
                        <li><strong>Email:</strong> Email unik (required)</li>
                        <li><strong>Password:</strong> Password yang di-hash (hidden dari JSON)</li>
                        <li><strong>Role:</strong> Enum dengan nilai 'customer' atau 'admin'</li>
                        <li><strong>Timestamps:</strong> created_at, updated_at, deleted_at</li>
                    </ul>

                    <h3>üìù Langkah 2: Membuat Request Struct untuk Register</h3>
                    <p>Buat file <code>requests/auth_request.go</code> untuk validasi input register:</p>

                    <pre><code>package requests

import (
    "errors"
    "github.com/go-playground/validator/v10"
)

// RegisterRequest represents the request structure for user registration
type RegisterRequest struct {
    Username        string \`json:"username" validate:"required,min=3,max=50"\`
    Email           string \`json:"email" validate:"required,email"\`
    Password        string \`json:"password" validate:"required,min=6"\`
    ConfirmPassword string \`json:"confirm_password" validate:"required,min=6"\`
}

// Validate validates the RegisterRequest using the validator
func (r *RegisterRequest) Validate() error {
    validate := validator.New()
    
    // Validasi struct fields
    if err := validate.Struct(r); err != nil {
        return err
    }
    
    // Validasi custom: password dan confirm_password harus sama
    if r.Password != r.ConfirmPassword {
        return errors.New("password and confirm_password must match")
    }
    
    return nil
}</code></pre>

                    <h4>Penjelasan RegisterRequest:</h4>
                    <ul>
                        <li><strong>Username:</strong> Nama pengguna dengan validasi min 3, max 50 karakter</li>
                        <li><strong>Email:</strong> Email dengan format yang valid</li>
                        <li><strong>Password:</strong> Password minimal 6 karakter</li>
                        <li><strong>ConfirmPassword:</strong> Konfirmasi password yang harus sama dengan password</li>
                        <li><strong>Validate():</strong> Method untuk memvalidasi struct dan memastikan password sama dengan confirm_password</li>
                    </ul>

                    <h4>Validasi yang Digunakan:</h4>
                    <ul>
                        <li><strong>required:</strong> Field wajib diisi</li>
                        <li><strong>email:</strong> Format email yang valid</li>
                        <li><strong>min=3,max=50:</strong> Username minimal 3, maksimal 50 karakter</li>
                        <li><strong>min=6:</strong> Password dan ConfirmPassword minimal 6 karakter</li>
                        <li><strong>Custom Validation:</strong> Password dan ConfirmPassword harus sama</li>
                    </ul>

                    <h3>üìù Langkah 3: Membuat Response Struct untuk Register</h3>
                    <p>Buat file <code>responses/auth_response.go</code> untuk format response register:</p>

                    <pre><code>package responses

import "tokogo/models"

// RegisterResponse struct untuk response register
type RegisterResponse struct {
    User  UserResponse \`json:"user"\`
    Token string       \`json:"token"\`
}

// UserResponse struct untuk response user (tanpa password)
type UserResponse struct {
    ID        uint   \`json:"id"\`
    Name      string \`json:"name"\`
    Email     string \`json:"email"\`
    Role      string \`json:"role"\`
    CreatedAt string \`json:"created_at"\`
}

// ErrorResponse struct untuk response error
type ErrorResponse struct {
    Error   string \`json:"error"\`
    Message string \`json:"message"\`
}

// SuccessResponse struct untuk response sukses
type SuccessResponse struct {
    Message string      \`json:"message"\`
    Data    interface{} \`json:"data,omitempty"\`
}

// ConvertUserToResponse mengkonversi User model ke UserResponse
func ConvertUserToResponse(user models.User) UserResponse {
    return UserResponse{
        ID:        user.ID,
        Name:      user.Name,
        Email:     user.Email,
        Role:      user.Role,
        CreatedAt: user.CreatedAt.Format("2006-01-02 15:04:05"),
    }
}</code></pre>

                    <h4>Penjelasan Response Structs:</h4>
                    <ul>
                        <li><strong>RegisterResponse:</strong> Response khusus untuk register yang berisi user data dan JWT token</li>
                        <li><strong>UserResponse:</strong> Data user tanpa password untuk keamanan</li>
                        <li><strong>ErrorResponse:</strong> Format response untuk error</li>
                        <li><strong>SuccessResponse:</strong> Format response untuk sukses</li>
                        <li><strong>ConvertUserToResponse:</strong> Helper function untuk konversi model ke response</li>
                    </ul>

                    <h3>üìù Langkah 4: Membuat JWT Helper untuk Register</h3>
                    <p>Buat file <code>helpers/jwt.go</code> untuk JWT operations:</p>

                    <pre><code>package helpers

import (
    "time"

    "github.com/golang-jwt/jwt"
    "tokogo/models"
)

var jwtSecret = []byte("your-secret-key") // Gunakan dari environment variable

// Claims struct untuk JWT claims
type Claims struct {
    UserID uint   \`json:"user_id"\`
    Email  string \`json:"email"\`
    Role   string \`json:"role"\`
    jwt.StandardClaims
}

// GenerateToken menghasilkan JWT token untuk user
func GenerateToken(user models.User) (string, error) {
    expirationTime := time.Now().Add(24 * time.Hour) // Token berlaku 24 jam
    
    claims := &Claims{
        UserID: user.ID,
        Email:  user.Email,
        Role:   user.Role,
        StandardClaims: jwt.StandardClaims{
            ExpiresAt: expirationTime.Unix(),
            IssuedAt:  time.Now().Unix(),
        },
    }

    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    tokenString, err := token.SignedString(jwtSecret)
    
    if err != nil {
        return "", err
    }

    return tokenString, nil
}</code></pre>

                    <h4>Penjelasan JWT Helper:</h4>
                    <ul>
                        <li><strong>Claims:</strong> Struct yang berisi data user dalam JWT token</li>
                        <li><strong>GenerateToken:</strong> Function untuk membuat JWT token setelah user berhasil register</li>
                        <li><strong>ExpirationTime:</strong> Token berlaku selama 24 jam</li>
                        <li><strong>jwtSecret:</strong> Secret key untuk signing token (sebaiknya dari environment variable)</li>
                    </ul>

                    <h3>üìù Langkah 5: Membuat Auth Repository untuk Register</h3>
                    <p>Buat file <code>repositories/auth_repository.go</code> untuk database operations register:</p>

                    <pre><code>package repositories

import (
    "errors"
    "tokogo/config"
    "tokogo/models"
    "gorm.io/gorm"
)

type AuthRepository struct {
    db *gorm.DB
}

// NewAuthRepository membuat instance baru AuthRepository
func NewAuthRepository() *AuthRepository {
    return &AuthRepository{
        db: config.DB,
    }
}

// CreateUser membuat user baru
func (r *AuthRepository) CreateUser(user *models.User) error {
    return r.db.Create(user).Error
}

// GetUserByEmail mengambil user berdasarkan email (untuk cek duplikasi)
func (r *AuthRepository) GetUserByEmail(email string) (*models.User, error) {
    var user models.User
    err := r.db.Where("email = ?", email).First(&user).Error
    
    if err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, errors.New("user not found")
        }
        return nil, err
    }
    
    return &user, nil
}</code></pre>

                    <h4>Penjelasan Auth Repository:</h4>
                    <ul>
                        <li><strong>CreateUser:</strong> Function untuk menyimpan user baru ke database</li>
                        <li><strong>GetUserByEmail:</strong> Function untuk mengecek apakah email sudah terdaftar</li>
                        <li><strong>NewAuthRepository:</strong> Constructor untuk membuat instance repository</li>
                        <li><strong>Error Handling:</strong> Menangani error jika user tidak ditemukan</li>
                    </ul>

                    <h3>üìù Langkah 6: Membuat Auth Service untuk Register</h3>
                    <p>Buat file <code>services/auth_service.go</code> untuk business logic register:</p>

                    <pre><code>package services

import (
    "errors"
    "tokogo/helpers"
    "tokogo/models"
    "tokogo/repositories"
    "tokogo/requests"
    "tokogo/responses"
    "golang.org/x/crypto/bcrypt"
)

type AuthService struct {
    authRepo *repositories.AuthRepository
}

// NewAuthService membuat instance baru AuthService
func NewAuthService() *AuthService {
    return &AuthService{
        authRepo: repositories.NewAuthRepository(),
    }
}

// Register mendaftarkan user baru
func (s *AuthService) Register(req requests.RegisterRequest) (*responses.RegisterResponse, error) {
    // Cek apakah email sudah terdaftar
    existingUser, _ := s.authRepo.GetUserByEmail(req.Email)
    if existingUser != nil {
        return nil, errors.New("email already registered")
    }

    // Hash password
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
    if err != nil {
        return nil, errors.New("failed to hash password")
    }

    // Buat user baru
    user := &models.User{
        Name:     req.Username, // Menggunakan Username dari request
        Email:    req.Email,
        Password: string(hashedPassword),
        Role:     "customer", // Default role
    }

    // Simpan ke database
    if err := s.authRepo.CreateUser(user); err != nil {
        return nil, errors.New("failed to create user")
    }

    // Generate JWT token
    token, err := helpers.GenerateToken(*user)
    if err != nil {
        return nil, errors.New("failed to generate token")
    }

    // Return response
    return &responses.RegisterResponse{
        User:  responses.ConvertUserToResponse(*user),
        Token: token,
    }, nil
}</code></pre>

                    <h4>Penjelasan Auth Service Register:</h4>
                    <ul>
                        <li><strong>Register Function:</strong> Business logic untuk registrasi user baru</li>
                        <li><strong>Email Check:</strong> Mengecek apakah email sudah terdaftar</li>
                        <li><strong>Password Hashing:</strong> Menggunakan bcrypt untuk hash password</li>
                        <li><strong>User Creation:</strong> Membuat user baru dengan role default "customer"</li>
                        <li><strong>JWT Generation:</strong> Membuat JWT token setelah user berhasil dibuat</li>
                        <li><strong>Response:</strong> Mengembalikan user data dan token</li>
                    </ul>

                    <h3>üìù Langkah 7: Membuat Auth Handler untuk Register</h3>
                    <p>Buat file <code>handlers/auth_handler.go</code> untuk HTTP handler register:</p>

                    <pre><code>package handlers

import (
    "net/http"
    "tokogo/requests"
    "tokogo/responses"
    "tokogo/services"
    "github.com/gin-gonic/gin"
)

type AuthHandler struct {
    authService *services.AuthService
}

// NewAuthHandler membuat instance baru AuthHandler
func NewAuthHandler() *AuthHandler {
    return &AuthHandler{
        authService: services.NewAuthService(),
    }
}

// Register handler untuk registrasi user baru
func (h *AuthHandler) Register(c *gin.Context) {
    var req requests.RegisterRequest
    
    // Bind dan validasi request
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Validasi menggunakan method Validate()
    if err := req.Validate(); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Panggil service untuk register
    registerResponse, err := h.authService.Register(req)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "register_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusCreated, responses.SuccessResponse{
        Message: "User registered successfully",
        Data:    registerResponse,
    })
}</code></pre>

                    <h4>Penjelasan Auth Handler Register:</h4>
                    <ul>
                        <li><strong>Register Function:</strong> HTTP handler untuk endpoint register</li>
                        <li><strong>ShouldBindJSON:</strong> Binding JSON request ke struct</li>
                        <li><strong>Validate():</strong> Validasi menggunakan go-playground/validator</li>
                        <li><strong>Service Call:</strong> Memanggil business logic di service layer</li>
                        <li><strong>Response:</strong> Mengembalikan response sukses atau error</li>
                        <li><strong>Status Code:</strong> 201 Created untuk sukses, 400 Bad Request untuk error</li>
                    </ul>

                    <h3>üìù Langkah 8: Update Main.go untuk Register</h3>
                    <p>Update file <code>main.go</code> untuk setup route register:</p>

                    <pre><code>package main

import (
    "log"
    "tokogo/config"
    "tokogo/handlers"
    "github.com/gin-contrib/cors"
    "github.com/gin-gonic/gin"
    "github.com/joho/godotenv"
)

func main() {
    // Load environment variables
    if err := godotenv.Load(); err != nil {
        log.Println("No .env file found, using system environment variables")
    }

    // Initialize database
    config.InitDB()

    // Setup Gin router
    r := gin.Default()

    // CORS middleware
    r.Use(cors.New(cors.Config{
        AllowOrigins:     []string{"*"},
        AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
        AllowHeaders:     []string{"*"},
        ExposeHeaders:    []string{"Content-Length"},
        AllowCredentials: true,
    }))

    // Initialize handlers
    authHandler := handlers.NewAuthHandler()

    // Public routes (tidak perlu authentication)
    api := r.Group("/api/v1")
    {
        // Auth routes
        auth := api.Group("/auth")
        {
            auth.POST("/register", authHandler.Register)
        }
    }

    // Start server
    port := config.GetEnv("SERVER_PORT", "8080")
    log.Printf("Server starting on port %s", port)
    r.Run(":" + port)
}</code></pre>

                    <h4>Penjelasan Main.go:</h4>
                    <ul>
                        <li><strong>Database Init:</strong> Menginisialisasi koneksi database</li>
                        <li><strong>CORS Setup:</strong> Konfigurasi CORS untuk frontend</li>
                        <li><strong>Route Setup:</strong> Setup route untuk register endpoint</li>
                        <li><strong>Server Start:</strong> Menjalankan server di port yang ditentukan</li>
                    </ul>

                    <h3>üìù Langkah 9: Update Database Configuration</h3>
                    <p>Update file <code>config/database.go</code> untuk include User model:</p>

                    <pre><code>// Auto migrate model User
if err := DB.AutoMigrate(&models.User{}); err != nil {
    panic(fmt.Sprintf("AutoMigrate failed: %v", err))
}</code></pre>

                    <h4>Penjelasan Database Configuration:</h4>
                    <ul>
                        <li><strong>AutoMigrate:</strong> Otomatis membuat/update table user berdasarkan model</li>
                        <li><strong>Error Handling:</strong> Panic jika migration gagal</li>
                    </ul>

                    <h3>üß™ Testing API Register</h3>
                    <p>Sekarang mari kita test API register yang sudah kita buat:</p>

                    <h4>1. Register User Baru</h4>
                    <pre><code>POST http://localhost:8080/api/v1/auth/register
Content-Type: application/json

{
    "username": "johndoe",
    "email": "john@example.com",
    "password": "password123",
    "confirm_password": "password123"
}</code></pre>

                    <h4>Response Sukses (201 Created):</h4>
                    <pre><code>{
    "message": "User registered successfully",
    "data": {
        "user": {
            "id": 1,
            "name": "johndoe",
            "email": "john@example.com",
            "role": "customer",
            "created_at": "2024-01-15 10:30:00"
        },
        "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
    }
}</code></pre>

                    <h4>Response Error (400 Bad Request):</h4>
                    <pre><code>{
    "error": "validation_error",
    "message": "Key: 'RegisterRequest.Email' Error:Field validation for 'Email' failed on the 'email' tag"
}</code></pre>

                    <h4>Response Error - Password Tidak Sama:</h4>
                    <pre><code>{
    "error": "validation_error",
    "message": "password and confirm_password must match"
}</code></pre>

                    <h4>Response Error - Email Sudah Terdaftar:</h4>
                    <pre><code>{
    "error": "register_failed",
    "message": "email already registered"
}</code></pre>

                    <h3>üîß Environment Variables</h3>
                    <p>Pastikan file <code>.env</code> Anda memiliki konfigurasi berikut:</p>

                    <pre><code># Database Configuration
DB_HOST=localhost
DB_PORT=3306
DB_USER=root
DB_PASSWORD=
DB_NAME=tokogo

# Server Configuration
SERVER_PORT=8080
JWT_SECRET=your-super-secret-jwt-key-here

# Environment
ENV=development</code></pre>

                    <h3>üì¶ Dependencies yang Dibutuhkan</h3>
                    <p>Pastikan Anda sudah menginstall dependencies berikut:</p>

                    <pre><code>go get golang.org/x/crypto/bcrypt</code></pre>

                    <h3>‚úÖ Checklist Implementasi Register</h3>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>File yang Harus Dibuat:</h4>
                        <ul>
                            <li>‚úÖ models/user.go</li>
                            <li>‚úÖ requests/auth_request.go (RegisterRequest)</li>
                            <li>‚úÖ responses/auth_response.go (RegisterResponse)</li>
                            <li>‚úÖ helpers/jwt.go (GenerateToken)</li>
                            <li>‚úÖ repositories/auth_repository.go (CreateUser, GetUserByEmail)</li>
                            <li>‚úÖ services/auth_service.go (Register)</li>
                            <li>‚úÖ handlers/auth_handler.go (Register)</li>
                        </ul>
                        
                        <h4>File yang Harus Diupdate:</h4>
                        <ul>
                            <li>‚úÖ config/database.go (AutoMigrate User)</li>
                            <li>‚úÖ main.go (Register route)</li>
                            <li>‚úÖ .env (JWT_SECRET)</li>
                        </ul>
                    </div>

                    <h3>üöÄ Cara Menjalankan</h3>
                    <ol>
                        <li>Pastikan MySQL sudah berjalan</li>
                        <li>Pastikan database 'tokogo' sudah dibuat</li>
                        <li>Jalankan: <code>go run main.go</code></li>
                        <li>Test dengan Postman atau curl</li>
                    </ol>

                    <h3>üéØ Fitur Register yang Sudah Diimplementasikan</h3>
                    <ul>
                        <li>‚úÖ User Registration dengan validasi</li>
                        <li>‚úÖ Password hashing dengan bcrypt</li>
                        <li>‚úÖ JWT token generation</li>
                        <li>‚úÖ Email uniqueness check</li>
                        <li>‚úÖ Input validation dengan go-playground/validator</li>
                        <li>‚úÖ Error handling yang proper</li>
                        <li>‚úÖ Response format yang konsisten</li>
                    </ul>

                    <h3>üîí Keamanan yang Sudah Diimplementasikan</h3>
                    <ul>
                        <li>‚úÖ Password hashing dengan bcrypt</li>
                        <li>‚úÖ JWT token dengan expiration</li>
                        <li>‚úÖ Input validation dengan go-playground/validator</li>
                        <li>‚úÖ SQL injection protection (GORM)</li>
                        <li>‚úÖ CORS configuration</li>
                        <li>‚úÖ Environment variables untuk secret keys</li>
                    </ul>

                    <h3>üéâ Selamat!</h3>
                    <p>Anda telah berhasil mengimplementasikan modul Register yang lengkap! Sistem register sudah siap untuk digunakan dan dapat diintegrasikan dengan frontend aplikasi.</p>

                    <div style="text-align: center; margin: 3rem 0;">
                        <div style="background: #f8f9fa; border: 1px solid #dee2e6; color: #2c3e50; padding: 2rem; border-radius: 5px; display: inline-block;">
                            <h3 style="color: #2c3e50; margin-bottom: 1rem;">üéØ Siap untuk Bab Selanjutnya?</h3>
                            <p style="color: #495057; margin-bottom: 0;">Di bab selanjutnya, kita akan membuat modul Login untuk melengkapi sistem authentication!</p>
                        </div>
                    </div>
                `
            },
            {
                id: 'chapter7',
                title: 'Bab 7: Modul Authentication - Login',
                meta: 'Halaman 8 dari 55 ‚Ä¢ Dibaca 8 menit',
                content: `
                    <h2>üîê Bab 7: Modul Authentication - Login</h2>
                    <p>Selamat! Sekarang kita akan melanjutkan dengan modul Login untuk melengkapi sistem authentication. Di bab ini, kita akan mengimplementasikan fitur login user yang sudah terdaftar dengan validasi email dan password.</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">üéØ Apa yang Akan Kita Buat di Bab Ini?</h3>
                        <p style="color: #495057; margin-bottom: 0;">Kita akan membuat sistem login user dengan validasi email/password, password verification, dan JWT token generation. Setelah selesai, kita akan test menggunakan Postman.</p>
                    </div>

                    <h3>üìã Prasyarat</h3>
                    <p>Sebelum memulai, pastikan Anda sudah menyelesaikan:</p>
                    <ul>
                        <li>‚úÖ Bab 6: Modul Authentication - Register</li>
                        <li>‚úÖ User sudah terdaftar di database</li>
                        <li>‚úÖ File-file authentication sudah dibuat</li>
                    </ul>

                    <h3>üìù Langkah 1: Update Request Struct untuk Login</h3>
                    <p>Update file <code>requests/auth_request.go</code> untuk menambahkan LoginRequest:</p>

                    <pre><code>package requests

import "github.com/go-playground/validator/v10"

// RegisterRequest represents the request structure for user registration
type RegisterRequest struct {
    Username string \`json:"username" validate:"required,min=3,max=50"\`
    Email    string \`json:"email" validate:"required,email"\`
    Password string \`json:"password" validate:"required,min=6"\`
}

// LoginRequest represents the request structure for user login
type LoginRequest struct {
    Email    string \`json:"email" validate:"required,email"\`
    Password string \`json:"password" validate:"required"\`
}

// Validate validates the RegisterRequest using the validator
func (r *RegisterRequest) Validate() error {
    validate := validator.New()
    return validate.Struct(r)
}

// Validate validates the LoginRequest using the validator
func (r *LoginRequest) Validate() error {
    validate := validator.New()
    return validate.Struct(r)
}</code></pre>

                    <h4>Penjelasan LoginRequest:</h4>
                    <ul>
                        <li><strong>Email:</strong> Email user yang akan login (required, format email valid)</li>
                        <li><strong>Password:</strong> Password user (required)</li>
                        <li><strong>Validate():</strong> Method untuk memvalidasi struct LoginRequest</li>
                    </ul>

                    <h3>üìù Langkah 2: Update Response Struct untuk Login</h3>
                    <p>Update file <code>responses/auth_response.go</code> untuk menambahkan LoginResponse:</p>

                    <pre><code>package responses

import "tokogo/models"

// RegisterResponse struct untuk response register
type RegisterResponse struct {
    User  UserResponse \`json:"user"\`
    Token string       \`json:"token"\`
}

// LoginResponse struct untuk response login
type LoginResponse struct {
    User  UserResponse \`json:"user"\`
    Token string       \`json:"token"\`
}

// UserResponse struct untuk response user (tanpa password)
type UserResponse struct {
    ID        uint   \`json:"id"\`
    Name      string \`json:"name"\`
    Email     string \`json:"email"\`
    Role      string \`json:"role"\`
    CreatedAt string \`json:"created_at"\`
}

// ErrorResponse struct untuk response error
type ErrorResponse struct {
    Error   string \`json:"error"\`
    Message string \`json:"message"\`
}

// SuccessResponse struct untuk response sukses
type SuccessResponse struct {
    Message string      \`json:"message"\`
    Data    interface{} \`json:"data,omitempty"\`
}

// ConvertUserToResponse mengkonversi User model ke UserResponse
func ConvertUserToResponse(user models.User) UserResponse {
    return UserResponse{
        ID:        user.ID,
        Name:      user.Name,
        Email:     user.Email,
        Role:      user.Role,
        CreatedAt: user.CreatedAt.Format("2006-01-02 15:04:05"),
    }
}</code></pre>

                    <h4>Penjelasan LoginResponse:</h4>
                    <ul>
                        <li><strong>LoginResponse:</strong> Response khusus untuk login yang berisi user data dan JWT token</li>
                        <li><strong>User:</strong> Data user tanpa password untuk keamanan</li>
                        <li><strong>Token:</strong> JWT token untuk authentication</li>
                    </ul>

                    <h3>üìù Langkah 3: Update JWT Helper untuk Login</h3>
                    <p>Update file <code>helpers/jwt.go</code> untuk menambahkan ValidateToken:</p>

                    <pre><code>package helpers

import (
    "errors"
    "time"

    "github.com/golang-jwt/jwt"
    "tokogo/models"
)

var jwtSecret = []byte("your-secret-key") // Gunakan dari environment variable

// Claims struct untuk JWT claims
type Claims struct {
    UserID uint   \`json:"user_id"\`
    Email  string \`json:"email"\`
    Role   string \`json:"role"\`
    jwt.StandardClaims
}

// GenerateToken menghasilkan JWT token untuk user
func GenerateToken(user models.User) (string, error) {
    expirationTime := time.Now().Add(24 * time.Hour) // Token berlaku 24 jam
    
    claims := &Claims{
        UserID: user.ID,
        Email:  user.Email,
        Role:   user.Role,
        StandardClaims: jwt.StandardClaims{
            ExpiresAt: expirationTime.Unix(),
            IssuedAt:  time.Now().Unix(),
        },
    }

    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    tokenString, err := token.SignedString(jwtSecret)
    
    if err != nil {
        return "", err
    }

    return tokenString, nil
}

// ValidateToken memvalidasi JWT token
func ValidateToken(tokenString string) (*Claims, error) {
    claims := &Claims{}

    token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
        return jwtSecret, nil
    })

    if err != nil {
        return nil, err
    }

    if !token.Valid {
        return nil, errors.New("invalid token")
    }

    return claims, nil
}</code></pre>

                    <h4>Penjelasan ValidateToken:</h4>
                    <ul>
                        <li><strong>ValidateToken:</strong> Function untuk memvalidasi JWT token yang akan digunakan di middleware</li>
                        <li><strong>Claims:</strong> Mengembalikan data user dari token</li>
                        <li><strong>Error Handling:</strong> Menangani token yang invalid atau expired</li>
                    </ul>

                    <h3>üìù Langkah 4: Update Auth Service untuk Login</h3>
                    <p>Update file <code>services/auth_service.go</code> untuk menambahkan Login function:</p>

                    <pre><code>package services

import (
    "errors"
    "tokogo/helpers"
    "tokogo/models"
    "tokogo/repositories"
    "tokogo/requests"
    "tokogo/responses"
    "golang.org/x/crypto/bcrypt"
)

type AuthService struct {
    authRepo *repositories.AuthRepository
}

// NewAuthService membuat instance baru AuthService
func NewAuthService() *AuthService {
    return &AuthService{
        authRepo: repositories.NewAuthRepository(),
    }
}

// Register mendaftarkan user baru
func (s *AuthService) Register(req requests.RegisterRequest) (*responses.RegisterResponse, error) {
    // Cek apakah email sudah terdaftar
    existingUser, _ := s.authRepo.GetUserByEmail(req.Email)
    if existingUser != nil {
        return nil, errors.New("email already registered")
    }

    // Hash password
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
    if err != nil {
        return nil, errors.New("failed to hash password")
    }

    // Buat user baru
    user := &models.User{
        Name:     req.Username, // Menggunakan Username dari request
        Email:    req.Email,
        Password: string(hashedPassword),
        Role:     "customer", // Default role
    }

    // Simpan ke database
    if err := s.authRepo.CreateUser(user); err != nil {
        return nil, errors.New("failed to create user")
    }

    // Generate JWT token
    token, err := helpers.GenerateToken(*user)
    if err != nil {
        return nil, errors.New("failed to generate token")
    }

    // Return response
    return &responses.RegisterResponse{
        User:  responses.ConvertUserToResponse(*user),
        Token: token,
    }, nil
}

// Login melakukan login user
func (s *AuthService) Login(req requests.LoginRequest) (*responses.LoginResponse, error) {
    // Cari user berdasarkan email
    user, err := s.authRepo.GetUserByEmail(req.Email)
    if err != nil {
        return nil, errors.New("invalid email or password")
    }

    // Verifikasi password
    err = bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(req.Password))
    if err != nil {
        return nil, errors.New("invalid email or password")
    }

    // Generate JWT token
    token, err := helpers.GenerateToken(*user)
    if err != nil {
        return nil, errors.New("failed to generate token")
    }

    // Return response
    return &responses.LoginResponse{
        User:  responses.ConvertUserToResponse(*user),
        Token: token,
    }, nil
}</code></pre>

                    <h4>Penjelasan Login Function:</h4>
                    <ul>
                        <li><strong>Email Lookup:</strong> Mencari user berdasarkan email</li>
                        <li><strong>Password Verification:</strong> Membandingkan password dengan bcrypt</li>
                        <li><strong>JWT Generation:</strong> Membuat JWT token setelah login sukses</li>
                        <li><strong>Error Handling:</strong> Mengembalikan error yang sama untuk keamanan</li>
                    </ul>

                    <h3>üìù Langkah 5: Update Auth Handler untuk Login</h3>
                    <p>Update file <code>handlers/auth_handler.go</code> untuk menambahkan Login handler:</p>

                    <pre><code>package handlers

import (
    "net/http"
    "tokogo/requests"
    "tokogo/responses"
    "tokogo/services"

    "github.com/gin-gonic/gin"
)

type AuthHandler struct {
    authService *services.AuthService
}

// NewAuthHandler membuat instance baru AuthHandler
func NewAuthHandler() *AuthHandler {
    return &AuthHandler{
        authService: services.NewAuthService(),
    }
}

// Register handler untuk registrasi user baru
func (h *AuthHandler) Register(c *gin.Context) {
    var req requests.RegisterRequest

    // Bind dan validasi request
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Validasi menggunakan method Validate()
    if err := req.Validate(); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Panggil service untuk register
    registerResponse, err := h.authService.Register(req)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "register_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusCreated, responses.SuccessResponse{
        Message: "User registered successfully",
        Data:    registerResponse,
    })
}

// Login handler untuk login user
func (h *AuthHandler) Login(c *gin.Context) {
    var req requests.LoginRequest

    // Bind dan validasi request
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Validasi menggunakan method Validate()
    if err := req.Validate(); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Panggil service untuk login
    loginResponse, err := h.authService.Login(req)
    if err != nil {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "login_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Login successful",
        Data:    loginResponse,
    })
}</code></pre>

                    <h4>Penjelasan Login Handler:</h4>
                    <ul>
                        <li><strong>Login Function:</strong> HTTP handler untuk endpoint login</li>
                        <li><strong>Request Binding:</strong> Binding JSON request ke LoginRequest struct</li>
                        <li><strong>Validation:</strong> Validasi menggunakan go-playground/validator</li>
                        <li><strong>Service Call:</strong> Memanggil business logic di service layer</li>
                        <li><strong>Status Code:</strong> 200 OK untuk sukses, 401 Unauthorized untuk error</li>
                    </ul>

                    <h3>üìù Langkah 6: Update Main.go untuk Login</h3>
                    <p>Update file <code>main.go</code> untuk menambahkan route login:</p>

                    <pre><code>package main

import (
    "log"
    "tokogo/config"
    "tokogo/handlers"

    "github.com/gin-contrib/cors"
    "github.com/gin-gonic/gin"
    "github.com/joho/godotenv"
)

func main() {
    // Load environment variables
    if err := godotenv.Load(); err != nil {
        log.Println("No .env file found, using system environment variables")
    }

    // Initialize database
    config.InitDB()

    // Setup Gin router
    r := gin.Default()

    // CORS middleware
    r.Use(cors.New(cors.Config{
        AllowOrigins:     []string{"*"},
        AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
        AllowHeaders:     []string{"*"},
        ExposeHeaders:    []string{"Content-Length"},
        AllowCredentials: true,
    }))

    // Initialize handlers
    authHandler := handlers.NewAuthHandler()

    // Public routes (tidak perlu authentication)
    api := r.Group("/api/v1")
    {
        // Auth routes
        auth := api.Group("/auth")
        {
            auth.POST("/register", authHandler.Register)
            auth.POST("/login", authHandler.Login)
        }
    }

    // Start server
    port := config.GetEnv("SERVER_PORT", "8080")
    log.Printf("Server starting on port %s", port)
    r.Run(":" + port)
}</code></pre>

                    <h4>Penjelasan Main.go Update:</h4>
                    <ul>
                        <li><strong>Login Route:</strong> Menambahkan POST /api/v1/auth/login</li>
                        <li><strong>Handler:</strong> Menggunakan authHandler.Login</li>
                        <li><strong>Public Route:</strong> Login tidak memerlukan authentication</li>
                    </ul>

                    <h3>üß™ Testing API Login</h3>
                    <p>Sekarang mari kita test API login yang sudah kita buat:</p>

                    <h4>1. Login User</h4>
                    <pre><code>POST http://localhost:8080/api/v1/auth/login
Content-Type: application/json

{
    "email": "john@example.com",
    "password": "password123"
}</code></pre>

                    <h4>Response Sukses (200 OK):</h4>
                    <pre><code>{
    "message": "Login successful",
    "data": {
        "user": {
            "id": 1,
            "name": "johndoe",
            "email": "john@example.com",
            "role": "customer",
            "created_at": "2024-01-15 10:30:00"
        },
        "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
    }
}</code></pre>

                    <h4>Response Error - Invalid Credentials (401 Unauthorized):</h4>
                    <pre><code>{
    "error": "login_failed",
    "message": "invalid email or password"
}</code></pre>

                    <h4>Response Error - Validation Error (400 Bad Request):</h4>
                    <pre><code>{
    "error": "validation_error",
    "message": "Key: 'LoginRequest.Email' Error:Field validation for 'Email' failed on the 'email' tag"
}</code></pre>

                    <h3>‚úÖ Checklist Implementasi Login</h3>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>File yang Harus Diupdate:</h4>
                        <ul>
                            <li>‚úÖ requests/auth_request.go (LoginRequest)</li>
                            <li>‚úÖ responses/auth_response.go (LoginResponse)</li>
                            <li>‚úÖ helpers/jwt.go (ValidateToken)</li>
                            <li>‚úÖ services/auth_service.go (Login)</li>
                            <li>‚úÖ handlers/auth_handler.go (Login)</li>
                            <li>‚úÖ main.go (Login route)</li>
                        </ul>
                    </div>

                    <h3>üöÄ Cara Menjalankan</h3>
                    <ol>
                        <li>Pastikan MySQL sudah berjalan</li>
                        <li>Pastikan database 'tokogo' sudah dibuat</li>
                        <li>Pastikan ada user yang sudah terdaftar (dari Bab 6)</li>
                        <li>Jalankan: <code>go run main.go</code></li>
                        <li>Test dengan Postman atau curl</li>
                    </ol>

                    <h3>üéØ Fitur Login yang Sudah Diimplementasikan</h3>
                    <ul>
                        <li>‚úÖ User Login dengan validasi email/password</li>
                        <li>‚úÖ Password verification dengan bcrypt</li>
                        <li>‚úÖ JWT token generation setelah login sukses</li>
                        <li>‚úÖ Input validation dengan go-playground/validator</li>
                        <li>‚úÖ Error handling yang proper</li>
                        <li>‚úÖ Response format yang konsisten</li>
                        <li>‚úÖ Security: Error message yang sama untuk keamanan</li>
                    </ul>

                    <h3>üîí Keamanan yang Diimplementasikan</h3>
                    <ul>
                        <li>‚úÖ Password verification dengan bcrypt</li>
                        <li>‚úÖ JWT token dengan expiration</li>
                        <li>‚úÖ Input validation dengan go-playground/validator</li>
                        <li>‚úÖ SQL injection protection (GORM)</li>
                        <li>‚úÖ CORS configuration</li>
                        <li>‚úÖ Environment variables untuk secret keys</li>
                        <li>‚úÖ Generic error messages untuk keamanan</li>
                    </ul>

                    <h3>üéâ Selamat!</h3>
                    <p>Anda telah berhasil mengimplementasikan modul Login yang lengkap! Sistem login sudah siap untuk digunakan dan dapat diintegrasikan dengan frontend aplikasi.</p>

                    <div style="text-align: center; margin: 3rem 0;">
                        <div style="background: #f8f9fa; border: 1px solid #dee2e6; color: #2c3e50; padding: 2rem; border-radius: 5px; display: inline-block;">
                            <h3 style="color: #2c3e50; margin-bottom: 1rem;">üéØ Siap untuk Bab Selanjutnya?</h3>
                            <p style="color: #495057; margin-bottom: 0;">Di bab selanjutnya, kita akan membuat modul Logout dan middleware authentication untuk melengkapi sistem authentication!</p>
                        </div>
                    </div>
                `
            },
            {
                id: 'chapter8',
                title: 'Bab 8: Modul Authentication - Logout',
                meta: 'Halaman 9 dari 55 ‚Ä¢ Dibaca 10 menit',
                content: `
                    <h2>üö™ Bab 8: Modul Authentication - Logout</h2>
                    <p>Selamat! Sekarang kita akan menyelesaikan sistem authentication dengan membuat modul Logout dan middleware authentication. Di bab ini, kita akan mengimplementasikan fitur logout user dan middleware untuk melindungi endpoint yang memerlukan authentication.</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">üéØ Apa yang Akan Kita Buat di Bab Ini?</h3>
                        <p style="color: #495057; margin-bottom: 0;">Kita akan membuat sistem logout user, middleware authentication untuk melindungi endpoint, dan endpoint protected yang memerlukan JWT token. Setelah selesai, kita akan test menggunakan Postman.</p>
                    </div>

                    <h3>üìã Prasyarat</h3>
                    <p>Sebelum memulai, pastikan Anda sudah menyelesaikan:</p>
                    <ul>
                        <li>‚úÖ Bab 6: Modul Authentication - Register</li>
                        <li>‚úÖ Bab 7: Modul Authentication - Login</li>
                        <li>‚úÖ User sudah terdaftar dan bisa login</li>
                        <li>‚úÖ JWT token sudah bisa di-generate</li>
                    </ul>

                    <h3>üìù Langkah 1: Buat Middleware Authentication</h3>
                    <p>Buat file <code>middlewares/auth_middleware.go</code> untuk melindungi endpoint yang memerlukan authentication:</p>

                    <pre><code>package middlewares

import (
    "net/http"
    "strings"
    "tokogo/helpers"
    "tokogo/responses"

    "github.com/gin-gonic/gin"
)

// AuthMiddleware middleware untuk memvalidasi JWT token
func AuthMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // Ambil token dari header Authorization
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
                Error:   "unauthorized",
                Message: "Authorization header is required",
            })
            c.Abort()
            return
        }

        // Cek format Bearer token
        tokenParts := strings.Split(authHeader, " ")
        if len(tokenParts) != 2 || tokenParts[0] != "Bearer" {
            c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
                Error:   "unauthorized",
                Message: "Invalid authorization header format",
            })
            c.Abort()
            return
        }

        token := tokenParts[1]

        // Validasi token
        claims, err := helpers.ValidateToken(token)
        if err != nil {
            c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
                Error:   "unauthorized",
                Message: "Invalid or expired token",
            })
            c.Abort()
            return
        }

        // Set user info ke context untuk digunakan di handler
        c.Set("user_id", claims.UserID)
        c.Set("user_email", claims.Email)
        c.Set("user_role", claims.Role)

        c.Next()
    }
}

// AdminMiddleware middleware untuk memvalidasi admin role
func AdminMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // Cek apakah user sudah login (AuthMiddleware harus dipanggil dulu)
        userRole, exists := c.Get("user_role")
        if !exists {
            c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
                Error:   "unauthorized",
                Message: "User not authenticated",
            })
            c.Abort()
            return
        }

        // Cek apakah user adalah admin
        if userRole != "admin" {
            c.JSON(http.StatusForbidden, responses.ErrorResponse{
                Error:   "forbidden",
                Message: "Admin access required",
            })
            c.Abort()
            return
        }

        c.Next()
    }
}</code></pre>

                    <h4>Penjelasan Middleware:</h4>
                    <ul>
                        <li><strong>AuthMiddleware:</strong> Memvalidasi JWT token dan set user info ke context</li>
                        <li><strong>AdminMiddleware:</strong> Memvalidasi apakah user memiliki role admin</li>
                        <li><strong>Authorization Header:</strong> Menggunakan format "Bearer {token}"</li>
                        <li><strong>Context:</strong> Menyimpan user info untuk digunakan di handler</li>
                    </ul>

                    <h3>üìù Langkah 2: Update Auth Service untuk Logout</h3>
                    <p>Update file <code>services/auth_service.go</code> untuk menambahkan Logout function:</p>

                    <pre><code>package services

import (
    "errors"
    "tokogo/helpers"
    "tokogo/models"
    "tokogo/repositories"
    "tokogo/requests"
    "tokogo/responses"
    "golang.org/x/crypto/bcrypt"
)

type AuthService struct {
    authRepo *repositories.AuthRepository
}

// NewAuthService membuat instance baru AuthService
func NewAuthService() *AuthService {
    return &AuthService{
        authRepo: repositories.NewAuthRepository(),
    }
}

// Register mendaftarkan user baru
func (s *AuthService) Register(req requests.RegisterRequest) (*responses.RegisterResponse, error) {
    // Cek apakah email sudah terdaftar
    existingUser, _ := s.authRepo.GetUserByEmail(req.Email)
    if existingUser != nil {
        return nil, errors.New("email already registered")
    }

    // Hash password
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
    if err != nil {
        return nil, errors.New("failed to hash password")
    }

    // Buat user baru
    user := &models.User{
        Name:     req.Username, // Menggunakan Username dari request
        Email:    req.Email,
        Password: string(hashedPassword),
        Role:     "customer", // Default role
    }

    // Simpan ke database
    if err := s.authRepo.CreateUser(user); err != nil {
        return nil, errors.New("failed to create user")
    }

    // Generate JWT token
    token, err := helpers.GenerateToken(*user)
    if err != nil {
        return nil, errors.New("failed to generate token")
    }

    // Return response
    return &responses.RegisterResponse{
        User:  responses.ConvertUserToResponse(*user),
        Token: token,
    }, nil
}

// Login melakukan login user
func (s *AuthService) Login(req requests.LoginRequest) (*responses.LoginResponse, error) {
    // Cari user berdasarkan email
    user, err := s.authRepo.GetUserByEmail(req.Email)
    if err != nil {
        return nil, errors.New("invalid email or password")
    }

    // Verifikasi password
    err = bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(req.Password))
    if err != nil {
        return nil, errors.New("invalid email or password")
    }

    // Generate JWT token
    token, err := helpers.GenerateToken(*user)
    if err != nil {
        return nil, errors.New("failed to generate token")
    }

    // Return response
    return &responses.LoginResponse{
        User:  responses.ConvertUserToResponse(*user),
        Token: token,
    }, nil
}

// Logout melakukan logout user (client-side token removal)
func (s *AuthService) Logout(userID uint) (*responses.LogoutResponse, error) {
    // Untuk stateless JWT, logout dilakukan di client side
    // Server hanya memberikan response sukses
    // Di production, bisa implementasi token blacklist jika diperlukan
    
    return &responses.LogoutResponse{
        Message: "Logout successful",
    }, nil
}

// GetProfile mengambil profile user berdasarkan ID
func (s *AuthService) GetProfile(userID uint) (*responses.UserResponse, error) {
    user, err := s.authRepo.GetUserByID(userID)
    if err != nil {
        return nil, errors.New("user not found")
    }

    return &responses.UserResponse{
        ID:        user.ID,
        Name:      user.Name,
        Email:     user.Email,
        Role:      user.Role,
        CreatedAt: user.CreatedAt.Format("2006-01-02 15:04:05"),
    }, nil
}</code></pre>

                    <h4>Penjelasan Logout Function:</h4>
                    <ul>
                        <li><strong>Stateless Logout:</strong> Untuk JWT stateless, logout dilakukan di client side</li>
                        <li><strong>Token Removal:</strong> Client menghapus token dari storage</li>
                        <li><strong>Server Response:</strong> Server memberikan konfirmasi logout sukses</li>
                        <li><strong>GetProfile:</strong> Function tambahan untuk mengambil profile user</li>
                    </ul>

                    <h3>üìù Langkah 3: Update Response Struct untuk Logout</h3>
                    <p>Update file <code>responses/auth_response.go</code> untuk menambahkan LogoutResponse:</p>

                    <pre><code>package responses

import "tokogo/models"

// RegisterResponse struct untuk response register
type RegisterResponse struct {
    User  UserResponse \`json:"user"\`
    Token string       \`json:"token"\`
}

// LoginResponse struct untuk response login
type LoginResponse struct {
    User  UserResponse \`json:"user"\`
    Token string       \`json:"token"\`
}

// LogoutResponse struct untuk response logout
type LogoutResponse struct {
    Message string \`json:"message"\`
}

// UserResponse struct untuk response user (tanpa password)
type UserResponse struct {
    ID        uint   \`json:"id"\`
    Name      string \`json:"name"\`
    Email     string \`json:"email"\`
    Role      string \`json:"role"\`
    CreatedAt string \`json:"created_at"\`
}

// ErrorResponse struct untuk response error
type ErrorResponse struct {
    Error   string \`json:"error"\`
    Message string \`json:"message"\`
}

// SuccessResponse struct untuk response sukses
type SuccessResponse struct {
    Message string      \`json:"message"\`
    Data    interface{} \`json:"data,omitempty"\`
}

// ConvertUserToResponse mengkonversi User model ke UserResponse
func ConvertUserToResponse(user models.User) UserResponse {
    return UserResponse{
        ID:        user.ID,
        Name:      user.Name,
        Email:     user.Email,
        Role:      user.Role,
        CreatedAt: user.CreatedAt.Format("2006-01-02 15:04:05"),
    }
}</code></pre>

                    <h4>Penjelasan LogoutResponse:</h4>
                    <ul>
                        <li><strong>LogoutResponse:</strong> Response sederhana untuk logout yang berisi message sukses</li>
                        <li><strong>Stateless Design:</strong> Tidak menyimpan state logout di server</li>
                        <li><strong>Client Responsibility:</strong> Client bertanggung jawab menghapus token</li>
                    </ul>

                    <h3>üìù Langkah 4: Update Auth Repository untuk GetUserByID</h3>
                    <p>Update file <code>repositories/auth_repository.go</code> untuk menambahkan GetUserByID:</p>

                    <pre><code>package repositories

import (
    "errors"
    "tokogo/config"
    "tokogo/models"

    "gorm.io/gorm"
)

type AuthRepository struct {
    db *gorm.DB
}

// NewAuthRepository membuat instance baru AuthRepository
func NewAuthRepository() *AuthRepository {
    return &AuthRepository{
        db: config.DB,
    }
}

// CreateUser menyimpan user baru ke database
func (r *AuthRepository) CreateUser(user *models.User) error {
    return r.db.Create(user).Error
}

// GetUserByEmail mengambil user berdasarkan email (untuk cek duplikasi)
func (r *AuthRepository) GetUserByEmail(email string) (*models.User, error) {
    var user models.User
    err := r.db.Where("email = ?", email).First(&user).Error
    
    if err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, errors.New("user not found")
        }
        return nil, err
    }
    
    return &user, nil
}

// GetUserByID mengambil user berdasarkan ID
func (r *AuthRepository) GetUserByID(id uint) (*models.User, error) {
    var user models.User
    err := r.db.Where("id = ?", id).First(&user).Error
    
    if err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, errors.New("user not found")
        }
        return nil, err
    }
    
    return &user, nil
}</code></pre>

                    <h4>Penjelasan GetUserByID:</h4>
                    <ul>
                        <li><strong>GetUserByID:</strong> Function untuk mengambil user berdasarkan ID</li>
                        <li><strong>Error Handling:</strong> Menangani error jika user tidak ditemukan</li>
                        <li><strong>GORM Query:</strong> Menggunakan Where clause untuk mencari berdasarkan ID</li>
                    </ul>

                    <h3>üìù Langkah 5: Update Auth Handler untuk Logout dan GetProfile</h3>
                    <p>Update file <code>handlers/auth_handler.go</code> untuk menambahkan Logout dan GetProfile handler:</p>

                    <pre><code>package handlers

import (
    "net/http"
    "strconv"
    "tokogo/requests"
    "tokogo/responses"
    "tokogo/services"

    "github.com/gin-gonic/gin"
)

type AuthHandler struct {
    authService *services.AuthService
}

// NewAuthHandler membuat instance baru AuthHandler
func NewAuthHandler() *AuthHandler {
    return &AuthHandler{
        authService: services.NewAuthService(),
    }
}

// Register handler untuk registrasi user baru
func (h *AuthHandler) Register(c *gin.Context) {
    var req requests.RegisterRequest

    // Bind dan validasi request
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Validasi menggunakan method Validate()
    if err := req.Validate(); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Panggil service untuk register
    registerResponse, err := h.authService.Register(req)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "register_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusCreated, responses.SuccessResponse{
        Message: "User registered successfully",
        Data:    registerResponse,
    })
}

// Login handler untuk login user
func (h *AuthHandler) Login(c *gin.Context) {
    var req requests.LoginRequest

    // Bind dan validasi request
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Validasi menggunakan method Validate()
    if err := req.Validate(); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Panggil service untuk login
    loginResponse, err := h.authService.Login(req)
    if err != nil {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "login_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Login successful",
        Data:    loginResponse,
    })
}

// Logout handler untuk logout user
func (h *AuthHandler) Logout(c *gin.Context) {
    // Ambil user ID dari context (setelah AuthMiddleware)
    userID, exists := c.Get("user_id")
    if !exists {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "unauthorized",
            Message: "User not authenticated",
        })
        return
    }

    // Panggil service untuk logout
    logoutResponse, err := h.authService.Logout(userID.(uint))
    if err != nil {
        c.JSON(http.StatusInternalServerError, responses.ErrorResponse{
            Error:   "logout_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, logoutResponse)
}

// GetProfile handler untuk mengambil profile user
func (h *AuthHandler) GetProfile(c *gin.Context) {
    // Ambil user ID dari context (setelah AuthMiddleware)
    userID, exists := c.Get("user_id")
    if !exists {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "unauthorized",
            Message: "User not authenticated",
        })
        return
    }

    // Panggil service untuk get profile
    userResponse, err := h.authService.GetProfile(userID.(uint))
    if err != nil {
        c.JSON(http.StatusNotFound, responses.ErrorResponse{
            Error:   "user_not_found",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Profile retrieved successfully",
        Data:    userResponse,
    })
}</code></pre>

                    <h4>Penjelasan Handler Baru:</h4>
                    <ul>
                        <li><strong>Logout Handler:</strong> Menggunakan user_id dari context untuk logout</li>
                        <li><strong>GetProfile Handler:</strong> Mengambil profile user berdasarkan ID dari context</li>
                        <li><strong>Context Usage:</strong> Menggunakan data user yang sudah di-set oleh middleware</li>
                        <li><strong>Error Handling:</strong> Menangani error jika user tidak authenticated</li>
                    </ul>

                    <h3>üìù Langkah 6: Update Main.go untuk Logout dan Protected Routes</h3>
                    <p>Update file <code>main.go</code> untuk menambahkan route logout dan protected routes:</p>

                    <pre><code>package main

import (
    "log"
    "tokogo/config"
    "tokogo/handlers"
    "tokogo/middlewares"

    "github.com/gin-contrib/cors"
    "github.com/gin-gonic/gin"
    "github.com/joho/godotenv"
)

func main() {
    // Load environment variables
    if err := godotenv.Load(); err != nil {
        log.Println("No .env file found, using system environment variables")
    }

    // Initialize database
    config.InitDB()

    // Setup Gin router
    r := gin.Default()

    // CORS middleware
    r.Use(cors.New(cors.Config{
        AllowOrigins:     []string{"*"},
        AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
        AllowHeaders:     []string{"*"},
        ExposeHeaders:    []string{"Content-Length"},
        AllowCredentials: true,
    }))

    // Initialize handlers
    authHandler := handlers.NewAuthHandler()

    // Public routes (tidak perlu authentication)
    api := r.Group("/api/v1")
    {
        // Auth routes
        auth := api.Group("/auth")
        {
            auth.POST("/register", authHandler.Register)
            auth.POST("/login", authHandler.Login)
        }
    }

    // Protected routes (perlu authentication)
    protected := r.Group("/api/v1")
    protected.Use(middlewares.AuthMiddleware())
    {
        // Auth protected routes
        auth := protected.Group("/auth")
        {
            auth.POST("/logout", authHandler.Logout)
            auth.GET("/profile", authHandler.GetProfile)
        }

        // Admin routes (perlu admin role)
        admin := protected.Group("/admin")
        admin.Use(middlewares.AdminMiddleware())
        {
            admin.GET("/dashboard", func(c *gin.Context) {
                c.JSON(200, gin.H{
                    "message": "Welcome to admin dashboard",
                    "user_id": c.GetUint("user_id"),
                })
            })
        }
    }

    // Start server
    port := config.GetEnv("SERVER_PORT", "8080")
    log.Printf("Server starting on port %s", port)
    r.Run(":" + port)
}</code></pre>

                    <h4>Penjelasan Main.go Update:</h4>
                    <ul>
                        <li><strong>Protected Routes:</strong> Menggunakan AuthMiddleware untuk melindungi endpoint</li>
                        <li><strong>Logout Route:</strong> POST /api/v1/auth/logout (protected)</li>
                        <li><strong>Profile Route:</strong> GET /api/v1/auth/profile (protected)</li>
                        <li><strong>Admin Routes:</strong> Menggunakan AdminMiddleware untuk role admin</li>
                        <li><strong>Middleware Chain:</strong> AuthMiddleware -> AdminMiddleware untuk admin routes</li>
                    </ul>

                    <h3>üß™ Testing API Logout dan Protected Routes</h3>
                    <p>Sekarang mari kita test API logout dan protected routes yang sudah kita buat:</p>

                    <h4>1. Login User (untuk mendapatkan token)</h4>
                    <pre><code>POST http://localhost:8080/api/v1/auth/login
Content-Type: application/json

{
    "email": "john@example.com",
    "password": "password123"
}</code></pre>

                    <h4>2. Get Profile (Protected Route)</h4>
                    <pre><code>GET http://localhost:8080/api/v1/auth/profile
Authorization: Bearer {your_jwt_token}</code></pre>

                    <h4>Response Sukses (200 OK):</h4>
                    <pre><code>{
    "message": "Profile retrieved successfully",
    "data": {
        "id": 1,
        "name": "johndoe",
        "email": "john@example.com",
        "role": "customer",
        "created_at": "2024-01-15 10:30:00"
    }
}</code></pre>

                    <h4>3. Logout User</h4>
                    <pre><code>POST http://localhost:8080/api/v1/auth/logout
Authorization: Bearer {your_jwt_token}</code></pre>

                    <h4>Response Sukses (200 OK):</h4>
                    <pre><code>{
    "message": "Logout successful"
}</code></pre>

                    <h4>4. Test Protected Route tanpa Token</h4>
                    <pre><code>GET http://localhost:8080/api/v1/auth/profile</code></pre>

                    <h4>Response Error (401 Unauthorized):</h4>
                    <pre><code>{
    "error": "unauthorized",
    "message": "Authorization header is required"
}</code></pre>

                    <h4>5. Test Admin Route (Customer Role)</h4>
                    <pre><code>GET http://localhost:8080/api/v1/admin/dashboard
Authorization: Bearer {customer_jwt_token}</code></pre>

                    <h4>Response Error (403 Forbidden):</h4>
                    <pre><code>{
    "error": "forbidden",
    "message": "Admin access required"
}</code></pre>

                    <h3>‚úÖ Checklist Implementasi Logout</h3>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>File yang Harus Dibuat:</h4>
                        <ul>
                            <li>‚úÖ middlewares/auth_middleware.go (AuthMiddleware, AdminMiddleware)</li>
                        </ul>
                        
                        <h4>File yang Harus Diupdate:</h4>
                        <ul>
                            <li>‚úÖ responses/auth_response.go (LogoutResponse)</li>
                            <li>‚úÖ repositories/auth_repository.go (GetUserByID)</li>
                            <li>‚úÖ services/auth_service.go (Logout, GetProfile)</li>
                            <li>‚úÖ handlers/auth_handler.go (Logout, GetProfile)</li>
                            <li>‚úÖ main.go (Protected routes, middleware)</li>
                        </ul>
                    </div>

                    <h3>üöÄ Cara Menjalankan</h3>
                    <ol>
                        <li>Pastikan MySQL sudah berjalan</li>
                        <li>Pastikan database 'tokogo' sudah dibuat</li>
                        <li>Pastikan ada user yang sudah terdaftar dan bisa login</li>
                        <li>Jalankan: <code>go run main.go</code></li>
                        <li>Test dengan Postman atau curl</li>
                    </ol>

                    <h3>üéØ Fitur Logout yang Sudah Diimplementasikan</h3>
                    <ul>
                        <li>‚úÖ User Logout dengan JWT token validation</li>
                        <li>‚úÖ Middleware Authentication untuk protected routes</li>
                        <li>‚úÖ Middleware Admin untuk admin-only routes</li>
                        <li>‚úÖ Get Profile endpoint yang protected</li>
                        <li>‚úÖ Admin Dashboard endpoint</li>
                        <li>‚úÖ Error handling yang proper</li>
                        <li>‚úÖ Response format yang konsisten</li>
                    </ul>

                    <h3>üîí Keamanan yang Diimplementasikan</h3>
                    <ul>
                        <li>‚úÖ JWT token validation di middleware</li>
                        <li>‚úÖ Authorization header validation</li>
                        <li>‚úÖ Role-based access control (AdminMiddleware)</li>
                        <li>‚úÖ Protected routes dengan authentication</li>
                        <li>‚úÖ Context-based user information</li>
                        <li>‚úÖ Stateless logout design</li>
                        <li>‚úÖ Proper error messages untuk security</li>
                    </ul>

                    <h3>üéâ Selamat!</h3>
                    <p>Anda telah berhasil mengimplementasikan modul Logout yang lengkap! Sistem authentication sudah lengkap dengan Register, Login, Logout, dan middleware protection. Sistem sudah siap untuk digunakan dan dapat diintegrasikan dengan frontend aplikasi.</p>

                    <div style="text-align: center; margin: 3rem 0;">
                        <div style="background: #f8f9fa; border: 1px solid #dee2e6; color: #2c3e50; padding: 2rem; border-radius: 5px; display: inline-block;">
                            <h3 style="color: #2c3e50; margin-bottom: 1rem;">üéØ Sistem Authentication Lengkap!</h3>
                            <p style="color: #495057; margin-bottom: 0;">Sekarang Anda memiliki sistem authentication yang lengkap dengan Register, Login, Logout, dan middleware protection. Siap untuk melanjutkan ke modul berikutnya!</p>
                        </div>
                    </div>
                `
            },
            {
                id: 'chapter9',
                title: 'Bab 9: Relaksasi & Review Pembelajaran - Modul Authentication',
                meta: 'Halaman 10 dari 55 ‚Ä¢ Dibaca 15 menit',
                content: `
                    <h2>Bab 9: Relaksasi & Review Pembelajaran - Modul Authentication</h2>
                    <p>Selamat! Anda telah berhasil menyelesaikan modul Authentication yang lengkap (Bab 6-8). Sekarang saatnya untuk beristirahat sejenak dan mengulas kembali semua yang telah dipelajari tentang sistem authentication. Bab ini dirancang untuk membantu otak Anda mengkonsolidasikan pengetahuan authentication yang baru saja diperoleh.</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">üéØ Pencapaian yang Luar Biasa!</h3>
                        <p style="color: #495057; margin-bottom: 0;">Anda telah berhasil membangun sistem authentication yang lengkap dengan Register, Login, Logout, dan middleware protection. Ini adalah pencapaian yang sangat membanggakan!</p>
                    </div>

                    <h3>Ringkasan Pembelajaran Bab 6-8</h3>
                    <p>Sebelum masuk ke pertanyaan review, mari kita ingat kembali perjalanan pembelajaran authentication yang telah kita lalui:</p>

                    <h4>Bab 6: Modul Authentication - Register</h4>
                    <ul>
                        <li>‚úÖ User registration dengan validasi input</li>
                        <li>‚úÖ Password hashing dengan bcrypt</li>
                        <li>‚úÖ Email uniqueness validation</li>
                        <li>‚úÖ Konfirmasi password untuk keamanan</li>
                        <li>‚úÖ JWT token generation setelah registrasi</li>
                        <li>‚úÖ Response format yang konsisten</li>
                        <li>‚úÖ Error handling yang proper</li>
                    </ul>

                    <h4>Bab 7: Modul Authentication - Login</h4>
                    <ul>
                        <li>‚úÖ User login dengan validasi email/password</li>
                        <li>‚úÖ Password verification dengan bcrypt</li>
                        <li>‚úÖ JWT token generation setelah login sukses</li>
                        <li>‚úÖ Input validation dengan go-playground/validator</li>
                        <li>‚úÖ Error handling untuk invalid credentials</li>
                        <li>‚úÖ Security: Error message yang sama untuk keamanan</li>
                        <li>‚úÖ Response format yang konsisten</li>
                    </ul>

                    <h4>Bab 8: Modul Authentication - Logout</h4>
                    <ul>
                        <li>‚úÖ User logout dengan JWT token validation</li>
                        <li>‚úÖ Middleware Authentication untuk protected routes</li>
                        <li>‚úÖ Middleware Admin untuk role-based access control</li>
                        <li>‚úÖ Get Profile endpoint yang protected</li>
                        <li>‚úÖ Admin Dashboard endpoint</li>
                        <li>‚úÖ Authorization header validation</li>
                        <li>‚úÖ Context-based user information</li>
                    </ul>

                    <h3>Pertanyaan Review Interaktif</h3>
                    <p>Mari kita uji pemahaman Anda dengan pertanyaan-pertanyaan yang dirancang untuk mengaktifkan kembali memori dan memperkuat pembelajaran authentication:</p>

                    <div style="background: #f8f9fa; border-left: 4px solid #3498db; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Bagian A: Konsep Dasar Authentication</h4>
                        
                        <p><strong>1. Mengapa kita menggunakan bcrypt untuk hashing password?</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: bcrypt adalah algoritma hashing yang aman dan slow, membuat brute force attack menjadi sangat sulit dan memakan waktu lama.</p>
                        
                        <p><strong>2. Apa perbedaan antara JWT token dan session-based authentication?</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: JWT adalah stateless (tidak menyimpan state di server), sementara session-based menyimpan state di server. JWT lebih scalable untuk distributed systems.</p>
                        
                        <p><strong>3. Mengapa kita memvalidasi konfirmasi password di sisi server?</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: Validasi di server memastikan keamanan dan mencegah user salah ketik password, meskipun sudah ada validasi di client side.</p>
                    </div>

                    <div style="background: #f8f9fa; border-left: 4px solid #e74c3c; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Bagian B: Middleware & Security</h4>
                        
                        <p><strong>4. Bagaimana cara kerja AuthMiddleware dalam melindungi endpoint?</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: AuthMiddleware memvalidasi JWT token dari Authorization header, mengekstrak user info, dan menyimpannya di context untuk digunakan di handler.</p>
                        
                        <p><strong>5. Apa perbedaan antara AuthMiddleware dan AdminMiddleware?</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: AuthMiddleware memvalidasi token dan set user info, sementara AdminMiddleware memvalidasi apakah user memiliki role admin.</p>
                        
                        <p><strong>6. Mengapa kita menggunakan format "Bearer {token}" untuk Authorization header?</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: Ini adalah standar OAuth 2.0 yang memisahkan tipe authentication (Bearer) dengan token, memudahkan parsing dan validasi.</p>
                    </div>

                    <div style="background: #f8f9fa; border-left: 4px solid #f39c12; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Bagian C: Arsitektur & Best Practices</h4>
                        
                        <p><strong>7. Jelaskan alur authentication flow dari register sampai logout!</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: Register ‚Üí Hash password ‚Üí Save user ‚Üí Generate JWT ‚Üí Login ‚Üí Validate credentials ‚Üí Generate JWT ‚Üí Access protected routes ‚Üí Logout ‚Üí Remove token (client-side).</p>
                        
                        <p><strong>8. Mengapa kita menggunakan layered architecture untuk authentication?</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: Separation of concerns, maintainability, testability, dan scalability. Setiap layer memiliki tanggung jawab yang jelas.</p>
                        
                        <p><strong>9. Bagaimana cara implementasi stateless logout dengan JWT?</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: Server memberikan response sukses, client menghapus token dari storage. Untuk production, bisa implementasi token blacklist.</p>
                    </div>

                    <div style="background: #f8f9fa; border-left: 4px solid #27ae60; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Bagian D: Error Handling & Security</h4>
                        
                        <p><strong>10. Mengapa kita memberikan error message yang sama untuk "invalid email or password"?</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: Untuk keamanan, mencegah attacker mengetahui apakah email terdaftar atau tidak, menghindari user enumeration attack.</p>
                        
                        <p><strong>11. Apa yang terjadi jika JWT token expired?</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: ValidateToken akan return error, middleware akan mengembalikan 401 Unauthorized, client harus login ulang.</p>
                        
                        <p><strong>12. Bagaimana cara mengimplementasikan role-based access control?</strong></p>
                        <p style="color: #666; font-style: italic;">Jawaban: Menggunakan AdminMiddleware yang memvalidasi role dari JWT claims, memberikan akses berbeda berdasarkan role user.</p>
                    </div>

                    <h3>Latihan Praktis</h3>
                    <p>Mari kita lakukan beberapa latihan praktis untuk memperkuat pemahaman:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Latihan 1: Analisis Security</h4>
                        <p>Analisis kode authentication yang sudah dibuat dan identifikasi:</p>
                        <ul>
                            <li>‚úÖ Password hashing dengan bcrypt</li>
                            <li>‚úÖ JWT token dengan expiration</li>
                            <li>‚úÖ Input validation</li>
                            <li>‚úÖ SQL injection protection (GORM)</li>
                            <li>‚úÖ CORS configuration</li>
                            <li>‚úÖ Generic error messages</li>
                        </ul>
                    </div>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Latihan 2: Testing Scenarios</h4>
                        <p>Test berbagai skenario authentication:</p>
                        <ul>
                            <li>‚úÖ Register dengan email yang sudah ada</li>
                            <li>‚úÖ Login dengan password yang salah</li>
                            <li>‚úÖ Akses protected route tanpa token</li>
                            <li>‚úÖ Akses admin route dengan customer role</li>
                            <li>‚úÖ Logout dengan token yang valid</li>
                        </ul>
                    </div>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Latihan 3: Code Review</h4>
                        <p>Review kode authentication dan identifikasi:</p>
                        <ul>
                            <li>‚úÖ Error handling yang konsisten</li>
                            <li>‚úÖ Response format yang seragam</li>
                            <li>‚úÖ Middleware yang reusable</li>
                            <li>‚úÖ Separation of concerns</li>
                            <li>‚úÖ Security best practices</li>
                        </ul>
                    </div>

                    <h3>Teknik Memori untuk Authentication</h3>
                    <p>Berikut adalah teknik memori untuk mengingat konsep-konsep authentication:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Akronim: AUTH-FLOW</h4>
                        <ul>
                            <li><strong>A</strong>uthentication - Verifikasi identitas user</li>
                            <li><strong>U</strong>ser Registration - Pendaftaran user baru</li>
                            <li><strong>T</strong>oken Generation - Pembuatan JWT token</li>
                            <li><strong>H</strong>ashing - Password hashing dengan bcrypt</li>
                            <li><strong>F</strong>low Control - Middleware untuk kontrol akses</li>
                            <li><strong>L</strong>ogin/Logout - Proses masuk dan keluar</li>
                            <li><strong>O</strong>wnership - User ownership data</li>
                            <li><strong>W</strong>eb Security - Keamanan web application</li>
                        </ul>
                    </div>

                    <h3>Self-Assessment</h3>
                    <p>Evaluasi pemahaman Anda tentang modul Authentication:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Kemampuan yang Harus Dikuasai:</h4>
                        <ul>
                            <li>‚úÖ Memahami konsep authentication dan authorization</li>
                            <li>‚úÖ Mampu implementasi user registration dengan validasi</li>
                            <li>‚úÖ Mampu implementasi user login dengan JWT</li>
                            <li>‚úÖ Mampu implementasi user logout</li>
                            <li>‚úÖ Mampu membuat middleware authentication</li>
                            <li>‚úÖ Mampu implementasi role-based access control</li>
                            <li>‚úÖ Mampu testing API authentication</li>
                            <li>‚úÖ Memahami security best practices</li>
                        </ul>
                    </div>

                    <h3>Tips untuk Pengembangan Selanjutnya</h3>
                    <p>Berikut adalah tips untuk mengembangkan sistem authentication lebih lanjut:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Fitur Tambahan yang Bisa Dikembangkan:</h4>
                        <ul>
                            <li>üîê Password reset functionality</li>
                            <li>üîê Email verification</li>
                            <li>üîê Two-factor authentication (2FA)</li>
                            <li>üîê Refresh token mechanism</li>
                            <li>üîê Rate limiting untuk login attempts</li>
                            <li>üîê Account lockout setelah failed attempts</li>
                            <li>üîê Audit logging untuk security</li>
                            <li>üîê OAuth integration (Google, Facebook)</li>
                        </ul>
                    </div>

                    <h3>Refleksi Pembelajaran</h3>
                    <p>Mari kita refleksikan apa yang telah dipelajari:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Pencapaian yang Membanggakan:</h4>
                        <ul>
                            <li>üéØ Berhasil membangun sistem authentication yang lengkap</li>
                            <li>üéØ Memahami konsep JWT dan stateless authentication</li>
                            <li>üéØ Mampu implementasi middleware untuk security</li>
                            <li>üéØ Memahami role-based access control</li>
                            <li>üéØ Mampu testing API dengan Postman</li>
                            <li>üéØ Memahami security best practices</li>
                        </ul>
                    </div>

                 

                    <h3>Kata-kata Motivasi</h3>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; margin: 2rem 0; border-radius: 5px; text-align: center;">
                        <p style="font-size: 1.1rem; color: #2c3e50; font-style: italic; margin-bottom: 0;">
                            "Authentication adalah fondasi keamanan aplikasi. Dengan menguasai konsep ini, Anda telah membangun dasar yang kuat untuk mengembangkan aplikasi yang aman dan terpercaya. Teruslah belajar dan eksplorasi fitur-fitur keamanan yang lebih advanced!"
                        </p>
                    </div>

                    <h3>Selamat!</h3>
                    <p>Anda telah berhasil menyelesaikan modul Authentication yang lengkap! Ini adalah pencapaian yang luar biasa. Sistem authentication yang Anda buat sudah siap untuk production dan dapat diintegrasikan dengan frontend aplikasi.</p>

                    <div style="text-align: center; margin: 3rem 0;">
                        <div style="background: #f8f9fa; border: 1px solid #dee2e6; color: #2c3e50; padding: 2rem; border-radius: 5px; display: inline-block;">
                            <h3 style="color: #2c3e50; margin-bottom: 1rem;">üéØ Siap untuk Modul Selanjutnya?</h3>
                            <p style="color: #495057; margin-bottom: 0;">Dengan sistem authentication yang lengkap, Anda siap untuk melanjutkan ke modul berikutnya seperti Product Management atau Shopping Cart!</p>
                        </div>
                    </div>
                `
            },
            {
                id: 'chapter10',
                title: 'Bab 10: Modul CRUD Kategori - Role Admin',
                meta: 'Halaman 11 dari 55 ‚Ä¢ Dibaca 12 menit',
                content: `
                    <h2>üìÇ Bab 10: Modul CRUD Kategori - Role Admin</h2>
                    <p>Selamat! Sekarang kita akan membuat modul CRUD (Create, Read, Update, Delete) untuk Kategori yang hanya bisa diakses oleh admin. Di bab ini, kita akan mengimplementasikan sistem manajemen kategori dengan role-based access control.</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">üéØ Apa yang Akan Kita Buat di Bab Ini?</h3>
                        <p style="color: #495057; margin-bottom: 0;">Kita akan membuat sistem CRUD kategori yang lengkap dengan Create, Read, Update, Delete operations. Semua endpoint hanya bisa diakses oleh admin. Setelah selesai, kita akan test menggunakan Postman.</p>
                    </div>

                    <h3>üìã Prasyarat</h3>
                    <p>Sebelum memulai, pastikan Anda sudah menyelesaikan:</p>
                    <ul>
                        <li>‚úÖ Bab 6-8: Modul Authentication (Register, Login, Logout)</li>
                        <li>‚úÖ Bab 9: Review Pembelajaran Authentication</li>
                        <li>‚úÖ Middleware authentication sudah berfungsi</li>
                        <li>‚úÖ AdminMiddleware sudah diimplementasikan</li>
                    </ul>

                    <h3>üìä Database Schema Kategori</h3>
                    <p>Berdasarkan requirement yang diberikan, berikut adalah struktur tabel kategori:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>Table: categories</h4>
                        <table style="width: 100%; border-collapse: collapse; margin-top: 1rem;">
                            <thead>
                                <tr style="background: #e9ecef;">
                                    <th style="border: 1px solid #dee2e6; padding: 0.75rem; text-align: left;">Field</th>
                                    <th style="border: 1px solid #dee2e6; padding: 0.75rem; text-align: left;">Type</th>
                                    <th style="border: 1px solid #dee2e6; padding: 0.75rem; text-align: left;">Notes</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">id</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">BIGINT PK</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Auto Increment</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">name</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">VARCHAR</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Nama kategori</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">slug</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">VARCHAR</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">URL-friendly identifier</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">created_at</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">TIMESTAMP</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Waktu dibuat</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">updated_at</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">TIMESTAMP</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Waktu diupdate</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">deleted_at</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">TIMESTAMP</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Soft delete</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <h3>üìù Langkah 1: Buat Model Category</h3>
                    <p>Buat file <code>models/category.go</code> untuk model kategori:</p>

                    <pre><code>package models

import (
    "time"
    "strings"
    "gorm.io/gorm"
)

type Category struct {
    ID        uint           \`gorm:"primaryKey;column:id;type:BIGINT UNSIGNED AUTO_INCREMENT" json:"id"\`
    Name      string         \`gorm:"column:name;type:VARCHAR(255);not null" json:"name"\`
    Slug      string         \`gorm:"column:slug;type:VARCHAR(255);uniqueIndex;not null" json:"slug"\`
    CreatedAt time.Time      \`gorm:"column:created_at;type:TIMESTAMP DEFAULT CURRENT_TIMESTAMP" json:"created_at"\`
    UpdatedAt time.Time      \`gorm:"column:updated_at;type:TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP" json:"updated_at"\`
    DeletedAt gorm.DeletedAt \`gorm:"column:deleted_at;type:TIMESTAMP NULL;index" json:"-"\`
}

// TableName mengembalikan nama tabel untuk model Category
func (Category) TableName() string {
    return "categories"
}

// GenerateSlug menghasilkan slug dari nama kategori
func (c *Category) GenerateSlug() {
    slug := strings.ToLower(c.Name)
    slug = strings.ReplaceAll(slug, " ", "-")
    slug = strings.ReplaceAll(slug, "_", "-")
    c.Slug = slug
}

// BeforeCreate hook untuk generate slug sebelum create
func (c *Category) BeforeCreate(tx *gorm.DB) error {
    c.GenerateSlug()
    return nil
}

// BeforeUpdate hook untuk generate slug sebelum update
func (c *Category) BeforeUpdate(tx *gorm.DB) error {
    c.GenerateSlug()
    return nil
}</code></pre>

                    <h4>Penjelasan Model Category:</h4>
                    <ul>
                        <li><strong>Struct Fields:</strong> Sesuai dengan database schema yang diberikan</li>
                        <li><strong>GORM Tags:</strong> Mapping ke database dengan tipe data yang tepat</li>
                        <li><strong>GenerateSlug:</strong> Function untuk membuat slug dari nama kategori</li>
                        <li><strong>Hooks:</strong> BeforeCreate dan BeforeUpdate untuk auto-generate slug</li>
                        <li><strong>Soft Delete:</strong> Menggunakan gorm.DeletedAt untuk soft delete</li>
                    </ul>

                    <h3>üìù Langkah 2: Buat Request Struct untuk Category</h3>
                    <p>Buat file <code>requests/category_request.go</code> untuk validasi input kategori:</p>

                    <pre><code>package requests

import (
    "errors"
    "github.com/go-playground/validator/v10"
)

// CreateCategoryRequest represents the request structure for creating category
type CreateCategoryRequest struct {
    Name string \`json:"name" validate:"required,min=2,max=100"\`
}

// UpdateCategoryRequest represents the request structure for updating category
type UpdateCategoryRequest struct {
    Name string \`json:"name" validate:"required,min=2,max=100"\`
}

// Validate validates the CreateCategoryRequest using the validator
func (r *CreateCategoryRequest) Validate() error {
    validate := validator.New()
    
    // Validasi struct fields
    if err := validate.Struct(r); err != nil {
        return err
    }
    
    // Validasi custom: nama tidak boleh kosong setelah trim
    if strings.TrimSpace(r.Name) == "" {
        return errors.New("name cannot be empty")
    }
    
    return nil
}

// Validate validates the UpdateCategoryRequest using the validator
func (r *UpdateCategoryRequest) Validate() error {
    validate := validator.New()
    
    // Validasi struct fields
    if err := validate.Struct(r); err != nil {
        return err
    }
    
    // Validasi custom: nama tidak boleh kosong setelah trim
    if strings.TrimSpace(r.Name) == "" {
        return errors.New("name cannot be empty")
    }
    
    return nil
}</code></pre>

                    <h4>Penjelasan Request Struct:</h4>
                    <ul>
                        <li><strong>CreateCategoryRequest:</strong> Untuk membuat kategori baru</li>
                        <li><strong>UpdateCategoryRequest:</strong> Untuk update kategori yang sudah ada</li>
                        <li><strong>Validation:</strong> Nama minimal 2 karakter, maksimal 100 karakter</li>
                        <li><strong>Custom Validation:</strong> Nama tidak boleh kosong setelah trim</li>
                    </ul>

                    <h3>üìù Langkah 3: Buat Response Struct untuk Category</h3>
                    <p>Buat file <code>responses/category_response.go</code> untuk format response kategori:</p>

                    <pre><code>package responses

import "tokogo/models"

// CategoryResponse struct untuk response category
type CategoryResponse struct {
    ID        uint   \`json:"id"\`
    Name      string \`json:"name"\`
    Slug      string \`json:"slug"\`
    CreatedAt string \`json:"created_at"\`
    UpdatedAt string \`json:"updated_at"\`
}

// CategoryListResponse struct untuk response list category
type CategoryListResponse struct {
    Categories []CategoryResponse \`json:"categories"\`
    Total      int                \`json:"total"\`
    Page       int                \`json:"page"\`
    Limit      int                \`json:"limit"\`
}

// ConvertCategoryToResponse mengkonversi Category model ke CategoryResponse
func ConvertCategoryToResponse(category models.Category) CategoryResponse {
    return CategoryResponse{
        ID:        category.ID,
        Name:      category.Name,
        Slug:      category.Slug,
        CreatedAt: category.CreatedAt.Format("2006-01-02 15:04:05"),
        UpdatedAt: category.UpdatedAt.Format("2006-01-02 15:04:05"),
    }
}

// ConvertCategoriesToResponse mengkonversi slice Category ke slice CategoryResponse
func ConvertCategoriesToResponse(categories []models.Category) []CategoryResponse {
    var responses []CategoryResponse
    for _, category := range categories {
        responses = append(responses, ConvertCategoryToResponse(category))
    }
    return responses
}</code></pre>

                    <h4>Penjelasan Response Struct:</h4>
                    <ul>
                        <li><strong>CategoryResponse:</strong> Response untuk single category</li>
                        <li><strong>CategoryListResponse:</strong> Response untuk list category dengan pagination</li>
                        <li><strong>Convert Functions:</strong> Helper functions untuk konversi model ke response</li>
                        <li><strong>Date Formatting:</strong> Format tanggal yang konsisten</li>
                    </ul>

                    <h3>üìù Langkah 4: Buat Category Repository</h3>
                    <p>Buat file <code>repositories/category_repository.go</code> untuk database operations:</p>

                    <pre><code>package repositories

import (
    "errors"
    "tokogo/config"
    "tokogo/models"

    "gorm.io/gorm"
)

type CategoryRepository struct {
    db *gorm.DB
}

// NewCategoryRepository membuat instance baru CategoryRepository
func NewCategoryRepository() *CategoryRepository {
    return &CategoryRepository{
        db: config.DB,
    }
}

// CreateCategory menyimpan category baru ke database
func (r *CategoryRepository) CreateCategory(category *models.Category) error {
    return r.db.Create(category).Error
}

// GetCategoryByID mengambil category berdasarkan ID
func (r *CategoryRepository) GetCategoryByID(id uint) (*models.Category, error) {
    var category models.Category
    err := r.db.Where("id = ?", id).First(&category).Error
    
    if err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, errors.New("category not found")
        }
        return nil, err
    }
    
    return &category, nil
}

// GetCategoryBySlug mengambil category berdasarkan slug
func (r *CategoryRepository) GetCategoryBySlug(slug string) (*models.Category, error) {
    var category models.Category
    err := r.db.Where("slug = ?", slug).First(&category).Error
    
    if err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, errors.New("category not found")
        }
        return nil, err
    }
    
    return &category, nil
}

// GetAllCategories mengambil semua categories dengan pagination
func (r *CategoryRepository) GetAllCategories(page, limit int) ([]models.Category, int64, error) {
    var categories []models.Category
    var total int64

    // Hitung total records
    if err := r.db.Model(&models.Category{}).Count(&total).Error; err != nil {
        return nil, 0, err
    }

    // Ambil data dengan pagination
    offset := (page - 1) * limit
    err := r.db.Offset(offset).Limit(limit).Order("created_at DESC").Find(&categories).Error
    
    return categories, total, err
}

// UpdateCategory mengupdate category berdasarkan ID
func (r *CategoryRepository) UpdateCategory(id uint, category *models.Category) error {
    return r.db.Where("id = ?", id).Updates(category).Error
}

// DeleteCategory menghapus category berdasarkan ID (soft delete)
func (r *CategoryRepository) DeleteCategory(id uint) error {
    return r.db.Where("id = ?", id).Delete(&models.Category{}).Error
}

// CheckCategoryExists mengecek apakah category dengan nama tertentu sudah ada
func (r *CategoryRepository) CheckCategoryExists(name string, excludeID uint) (bool, error) {
    var count int64
    query := r.db.Model(&models.Category{}).Where("name = ?", name)
    
    if excludeID > 0 {
        query = query.Where("id != ?", excludeID)
    }
    
    err := query.Count(&count).Error
    return count > 0, err
}</code></pre>

                    <h4>Penjelasan Category Repository:</h4>
                    <ul>
                        <li><strong>CRUD Operations:</strong> Create, Read, Update, Delete category</li>
                        <li><strong>Pagination:</strong> GetAllCategories dengan pagination support</li>
                        <li><strong>Soft Delete:</strong> DeleteCategory menggunakan soft delete</li>
                        <li><strong>Validation:</strong> CheckCategoryExists untuk cek duplikasi nama</li>
                        <li><strong>Error Handling:</strong> Proper error handling untuk setiap operation</li>
                    </ul>

                    <h3>üìù Langkah 5: Buat Category Service</h3>
                    <p>Buat file <code>services/category_service.go</code> untuk business logic kategori:</p>

                    <pre><code>package services

import (
    "errors"
    "tokogo/models"
    "tokogo/repositories"
    "tokogo/requests"
    "tokogo/responses"
)

type CategoryService struct {
    categoryRepo *repositories.CategoryRepository
}

// NewCategoryService membuat instance baru CategoryService
func NewCategoryService() *CategoryService {
    return &CategoryService{
        categoryRepo: repositories.NewCategoryRepository(),
    }
}

// CreateCategory membuat category baru
func (s *CategoryService) CreateCategory(req requests.CreateCategoryRequest) (*responses.CategoryResponse, error) {
    // Cek apakah nama category sudah ada
    exists, err := s.categoryRepo.CheckCategoryExists(req.Name, 0)
    if err != nil {
        return nil, errors.New("failed to check category existence")
    }
    if exists {
        return nil, errors.New("category name already exists")
    }

    // Buat category baru
    category := &models.Category{
        Name: req.Name,
    }

    // Simpan ke database
    if err := s.categoryRepo.CreateCategory(category); err != nil {
        return nil, errors.New("failed to create category")
    }

    // Return response
    return &responses.CategoryResponse{
        ID:        category.ID,
        Name:      category.Name,
        Slug:      category.Slug,
        CreatedAt: category.CreatedAt.Format("2006-01-02 15:04:05"),
        UpdatedAt: category.UpdatedAt.Format("2006-01-02 15:04:05"),
    }, nil
}

// GetCategoryByID mengambil category berdasarkan ID
func (s *CategoryService) GetCategoryByID(id uint) (*responses.CategoryResponse, error) {
    category, err := s.categoryRepo.GetCategoryByID(id)
    if err != nil {
        return nil, err
    }

    return &responses.CategoryResponse{
        ID:        category.ID,
        Name:      category.Name,
        Slug:      category.Slug,
        CreatedAt: category.CreatedAt.Format("2006-01-02 15:04:05"),
        UpdatedAt: category.UpdatedAt.Format("2006-01-02 15:04:05"),
    }, nil
}

// GetAllCategories mengambil semua categories dengan pagination
func (s *CategoryService) GetAllCategories(page, limit int) (*responses.CategoryListResponse, error) {
    categories, total, err := s.categoryRepo.GetAllCategories(page, limit)
    if err != nil {
        return nil, errors.New("failed to get categories")
    }

    return &responses.CategoryListResponse{
        Categories: responses.ConvertCategoriesToResponse(categories),
        Total:      int(total),
        Page:       page,
        Limit:      limit,
    }, nil
}

// UpdateCategory mengupdate category berdasarkan ID
func (s *CategoryService) UpdateCategory(id uint, req requests.UpdateCategoryRequest) (*responses.CategoryResponse, error) {
    // Cek apakah category ada
    existingCategory, err := s.categoryRepo.GetCategoryByID(id)
    if err != nil {
        return nil, err
    }

    // Cek apakah nama category sudah ada (exclude current category)
    exists, err := s.categoryRepo.CheckCategoryExists(req.Name, id)
    if err != nil {
        return nil, errors.New("failed to check category existence")
    }
    if exists {
        return nil, errors.New("category name already exists")
    }

    // Update category
    existingCategory.Name = req.Name
    if err := s.categoryRepo.UpdateCategory(id, existingCategory); err != nil {
        return nil, errors.New("failed to update category")
    }

    // Get updated category
    updatedCategory, err := s.categoryRepo.GetCategoryByID(id)
    if err != nil {
        return nil, errors.New("failed to get updated category")
    }

    return &responses.CategoryResponse{
        ID:        updatedCategory.ID,
        Name:      updatedCategory.Name,
        Slug:      updatedCategory.Slug,
        CreatedAt: updatedCategory.CreatedAt.Format("2006-01-02 15:04:05"),
        UpdatedAt: updatedCategory.UpdatedAt.Format("2006-01-02 15:04:05"),
    }, nil
}

// DeleteCategory menghapus category berdasarkan ID
func (s *CategoryService) DeleteCategory(id uint) error {
    // Cek apakah category ada
    _, err := s.categoryRepo.GetCategoryByID(id)
    if err != nil {
        return err
    }

    // Hapus category
    if err := s.categoryRepo.DeleteCategory(id); err != nil {
        return errors.New("failed to delete category")
    }

    return nil
}</code></pre>

                    <h4>Penjelasan Category Service:</h4>
                    <ul>
                        <li><strong>CreateCategory:</strong> Business logic untuk membuat kategori baru</li>
                        <li><strong>GetCategoryByID:</strong> Mengambil kategori berdasarkan ID</li>
                        <li><strong>GetAllCategories:</strong> Mengambil semua kategori dengan pagination</li>
                        <li><strong>UpdateCategory:</strong> Business logic untuk update kategori</li>
                        <li><strong>DeleteCategory:</strong> Business logic untuk hapus kategori</li>
                        <li><strong>Validation:</strong> Cek duplikasi nama kategori</li>
                    </ul>

                    <h3>üìù Langkah 6: Buat Category Handler</h3>
                    <p>Buat file <code>handlers/category_handler.go</code> untuk HTTP handlers:</p>

                    <pre><code>package handlers

import (
    "net/http"
    "strconv"
    "tokogo/requests"
    "tokogo/responses"
    "tokogo/services"

    "github.com/gin-gonic/gin"
)

type CategoryHandler struct {
    categoryService *services.CategoryService
}

// NewCategoryHandler membuat instance baru CategoryHandler
func NewCategoryHandler() *CategoryHandler {
    return &CategoryHandler{
        categoryService: services.NewCategoryService(),
    }
}

// CreateCategory handler untuk membuat category baru
func (h *CategoryHandler) CreateCategory(c *gin.Context) {
    var req requests.CreateCategoryRequest

    // Bind dan validasi request
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Validasi menggunakan method Validate()
    if err := req.Validate(); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Panggil service untuk create category
    categoryResponse, err := h.categoryService.CreateCategory(req)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "create_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusCreated, responses.SuccessResponse{
        Message: "Category created successfully",
        Data:    categoryResponse,
    })
}

// GetCategoryByID handler untuk mengambil category berdasarkan ID
func (h *CategoryHandler) GetCategoryByID(c *gin.Context) {
    // Ambil ID dari URL parameter
    idStr := c.Param("id")
    id, err := strconv.ParseUint(idStr, 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "invalid_id",
            Message: "Invalid category ID",
        })
        return
    }

    // Panggil service untuk get category
    categoryResponse, err := h.categoryService.GetCategoryByID(uint(id))
    if err != nil {
        c.JSON(http.StatusNotFound, responses.ErrorResponse{
            Error:   "category_not_found",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Category retrieved successfully",
        Data:    categoryResponse,
    })
}

// GetAllCategories handler untuk mengambil semua categories
func (h *CategoryHandler) GetAllCategories(c *gin.Context) {
    // Ambil query parameters untuk pagination
    pageStr := c.DefaultQuery("page", "1")
    limitStr := c.DefaultQuery("limit", "10")

    page, err := strconv.Atoi(pageStr)
    if err != nil || page < 1 {
        page = 1
    }

    limit, err := strconv.Atoi(limitStr)
    if err != nil || limit < 1 || limit > 100 {
        limit = 10
    }

    // Panggil service untuk get all categories
    categoriesResponse, err := h.categoryService.GetAllCategories(page, limit)
    if err != nil {
        c.JSON(http.StatusInternalServerError, responses.ErrorResponse{
            Error:   "get_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Categories retrieved successfully",
        Data:    categoriesResponse,
    })
}

// UpdateCategory handler untuk mengupdate category
func (h *CategoryHandler) UpdateCategory(c *gin.Context) {
    // Ambil ID dari URL parameter
    idStr := c.Param("id")
    id, err := strconv.ParseUint(idStr, 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "invalid_id",
            Message: "Invalid category ID",
        })
        return
    }

    var req requests.UpdateCategoryRequest

    // Bind dan validasi request
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Validasi menggunakan method Validate()
    if err := req.Validate(); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Panggil service untuk update category
    categoryResponse, err := h.categoryService.UpdateCategory(uint(id), req)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "update_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Category updated successfully",
        Data:    categoryResponse,
    })
}

// DeleteCategory handler untuk menghapus category
func (h *CategoryHandler) DeleteCategory(c *gin.Context) {
    // Ambil ID dari URL parameter
    idStr := c.Param("id")
    id, err := strconv.ParseUint(idStr, 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "invalid_id",
            Message: "Invalid category ID",
        })
        return
    }

    // Panggil service untuk delete category
    err = h.categoryService.DeleteCategory(uint(id))
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "delete_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Category deleted successfully",
        Data:    nil,
    })
}</code></pre>

                    <h4>Penjelasan Category Handler:</h4>
                    <ul>
                        <li><strong>CreateCategory:</strong> HTTP handler untuk membuat kategori baru</li>
                        <li><strong>GetCategoryByID:</strong> HTTP handler untuk mengambil kategori berdasarkan ID</li>
                        <li><strong>GetAllCategories:</strong> HTTP handler untuk mengambil semua kategori dengan pagination</li>
                        <li><strong>UpdateCategory:</strong> HTTP handler untuk update kategori</li>
                        <li><strong>DeleteCategory:</strong> HTTP handler untuk hapus kategori</li>
                        <li><strong>Error Handling:</strong> Proper error handling untuk setiap endpoint</li>
                    </ul>

                    <h3>üìù Langkah 7: Update Main.go untuk Category Routes</h3>
                    <p>Update file <code>main.go</code> untuk menambahkan category routes:</p>

                    <pre><code>package main

import (
    "log"
    "tokogo/config"
    "tokogo/handlers"
    "tokogo/middlewares"

    "github.com/gin-contrib/cors"
    "github.com/gin-gonic/gin"
    "github.com/joho/godotenv"
)

func main() {
    // Load environment variables
    if err := godotenv.Load(); err != nil {
        log.Println("No .env file found, using system environment variables")
    }

    // Initialize database
    config.InitDB()

    // Setup Gin router
    r := gin.Default()

    // CORS middleware
    r.Use(cors.New(cors.Config{
        AllowOrigins:     []string{"*"},
        AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
        AllowHeaders:     []string{"*"},
        ExposeHeaders:    []string{"Content-Length"},
        AllowCredentials: true,
    }))

    // Initialize handlers
    authHandler := handlers.NewAuthHandler()
    categoryHandler := handlers.NewCategoryHandler()

    // Public routes (tidak perlu authentication)
    api := r.Group("/api/v1")
    {
        // Auth routes
        auth := api.Group("/auth")
        {
            auth.POST("/register", authHandler.Register)
            auth.POST("/login", authHandler.Login)
        }
    }

    // Protected routes (perlu authentication)
    protected := r.Group("/api/v1")
    protected.Use(middlewares.AuthMiddleware())
    {
        // Auth protected routes
        auth := protected.Group("/auth")
        {
            auth.POST("/logout", authHandler.Logout)
            auth.GET("/profile", authHandler.GetProfile)
        }

        // Admin routes (perlu admin role)
        admin := protected.Group("/admin")
        admin.Use(middlewares.AdminMiddleware())
        {
            admin.GET("/dashboard", func(c *gin.Context) {
                c.JSON(200, gin.H{
                    "message": "Welcome to admin dashboard",
                    "user_id": c.GetUint("user_id"),
                })
            })

            // Category CRUD routes (admin only)
            categories := admin.Group("/categories")
            {
                categories.POST("", categoryHandler.CreateCategory)
                categories.GET("", categoryHandler.GetAllCategories)
                categories.GET("/:id", categoryHandler.GetCategoryByID)
                categories.PUT("/:id", categoryHandler.UpdateCategory)
                categories.DELETE("/:id", categoryHandler.DeleteCategory)
            }
        }
    }

    // Start server
    port := config.GetEnv("SERVER_PORT", "8080")
    log.Printf("Server starting on port %s", port)
    r.Run(":" + port)
}</code></pre>

                    <h4>Penjelasan Main.go Update:</h4>
                    <ul>
                        <li><strong>Category Handler:</strong> Initialize categoryHandler</li>
                        <li><strong>Admin Routes:</strong> Category routes dalam admin group</li>
                        <li><strong>CRUD Endpoints:</strong> POST, GET, PUT, DELETE untuk categories</li>
                        <li><strong>Middleware Chain:</strong> AuthMiddleware -> AdminMiddleware</li>
                        <li><strong>Route Structure:</strong> /api/v1/admin/categories</li>
                    </ul>

                    <h3>üìù Langkah 8: Update Database Config untuk AutoMigrate</h3>
                    <p>Update file <code>config/database.go</code> untuk menambahkan Category model:</p>

                    <pre><code>package config

import (
    "fmt"
    "log"
    "os"
    "tokogo/models"

    "gorm.io/driver/mysql"
    "gorm.io/gorm"
)

var DB *gorm.DB

// InitDB menginisialisasi koneksi database
func InitDB() {
    var err error

    // Konfigurasi database dari environment variables
    dbHost := GetEnv("DB_HOST", "localhost")
    dbPort := GetEnv("DB_PORT", "3306")
    dbUser := GetEnv("DB_USER", "root")
    dbPassword := GetEnv("DB_PASSWORD", "")
    dbName := GetEnv("DB_NAME", "tokogo")

    // Buat DSN (Data Source Name)
    dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local",
        dbUser, dbPassword, dbHost, dbPort, dbName)

    // Koneksi ke database
    DB, err = gorm.Open(mysql.Open(dsn), &gorm.Config{})
    if err != nil {
        log.Fatal("Failed to connect to database:", err)
    }

    log.Println("Database connected successfully")

    // Auto migrate models
    err = DB.AutoMigrate(
        &models.User{},
        &models.Category{},
    )
    if err != nil {
        log.Fatal("Failed to migrate database:", err)
    }

    log.Println("Database migrated successfully")
}
</code></pre>

                    <h4>Penjelasan Database Config Update:</h4>
                    <ul>
                        <li><strong>AutoMigrate:</strong> Menambahkan &models.Category{} ke AutoMigrate</li>
                        <li><strong>Table Creation:</strong> GORM akan membuat tabel categories otomatis</li>
                        <li><strong>Schema Sync:</strong> Database schema akan sync dengan model</li>
                    </ul>

                    <h3>üß™ Testing API Category CRUD</h3>
                    <p>Sekarang mari kita test API category CRUD yang sudah kita buat:</p>

                    <h4>1. Login sebagai Admin (untuk mendapatkan token)</h4>
                    <pre><code>POST http://localhost:8080/api/v1/auth/login
Content-Type: application/json

{
    "email": "admin@example.com",
    "password": "adminpassword"
}</code></pre>

                    <h4>2. Create Category</h4>
                    <pre><code>POST http://localhost:8080/api/v1/admin/categories
Authorization: Bearer {admin_jwt_token}
Content-Type: application/json

{
    "name": "Electronics"
}</code></pre>

                    <h4>Response Sukses (201 Created):</h4>
                    <pre><code>{
    "message": "Category created successfully",
    "data": {
        "id": 1,
        "name": "Electronics",
        "slug": "electronics",
        "created_at": "2024-01-15 10:30:00",
        "updated_at": "2024-01-15 10:30:00"
    }
}</code></pre>

                    <h4>3. Get All Categories</h4>
                    <pre><code>GET http://localhost:8080/api/v1/admin/categories?page=1&limit=10
Authorization: Bearer {admin_jwt_token}</code></pre>

                    <h4>4. Get Category by ID</h4>
                    <pre><code>GET http://localhost:8080/api/v1/admin/categories/1
Authorization: Bearer {admin_jwt_token}</code></pre>

                    <h4>5. Update Category</h4>
                    <pre><code>PUT http://localhost:8080/api/v1/admin/categories/1
Authorization: Bearer {admin_jwt_token}
Content-Type: application/json

{
    "name": "Electronic Devices"
}</code></pre>

                    <h4>6. Delete Category</h4>
                    <pre><code>DELETE http://localhost:8080/api/v1/admin/categories/1
Authorization: Bearer {admin_jwt_token}</code></pre>

                    <h4>Response Sukses (200 OK):</h4>
                    <pre><code>{
    "message": "Category deleted successfully",
    "data": null
}</code></pre>

                    <h4>7. Test dengan Customer Role (403 Forbidden)</h4>
                    <pre><code>POST http://localhost:8080/api/v1/admin/categories
Authorization: Bearer {customer_jwt_token}
Content-Type: application/json

{
    "name": "Test Category"
}</code></pre>

                    <h4>Response Error (403 Forbidden):</h4>
                    <pre><code>{
    "error": "forbidden",
    "message": "Admin access required"
}</code></pre>

                    <h3>‚úÖ Checklist Implementasi Category CRUD</h3>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>File yang Harus Dibuat:</h4>
                        <ul>
                            <li>‚úÖ models/category.go (Category model)</li>
                            <li>‚úÖ requests/category_request.go (Request structs)</li>
                            <li>‚úÖ responses/category_response.go (Response structs)</li>
                            <li>‚úÖ repositories/category_repository.go (Database operations)</li>
                            <li>‚úÖ services/category_service.go (Business logic)</li>
                            <li>‚úÖ handlers/category_handler.go (HTTP handlers)</li>
                        </ul>
                        
                        <h4>File yang Harus Diupdate:</h4>
                        <ul>
                            <li>‚úÖ config/database.go (AutoMigrate Category)</li>
                            <li>‚úÖ main.go (Category routes)</li>
                        </ul>
                    </div>

                    <h3>üöÄ Cara Menjalankan</h3>
                    <ol>
                        <li>Pastikan MySQL sudah berjalan</li>
                        <li>Pastikan database 'tokogo' sudah dibuat</li>
                        <li>Pastikan ada user dengan role admin</li>
                        <li>Jalankan: <code>go run main.go</code></li>
                        <li>Test dengan Postman atau curl</li>
                    </ol>

                    <h3>üéØ Fitur Category CRUD yang Sudah Diimplementasikan</h3>
                    <ul>
                        <li>‚úÖ Create Category dengan validasi nama</li>
                        <li>‚úÖ Read Category (Get by ID, Get All dengan pagination)</li>
                        <li>‚úÖ Update Category dengan validasi nama</li>
                        <li>‚úÖ Delete Category (soft delete)</li>
                        <li>‚úÖ Auto-generate slug dari nama</li>
                        <li>‚úÖ Duplicate name validation</li>
                        <li>‚úÖ Admin-only access control</li>
                        <li>‚úÖ Pagination support</li>
                    </ul>

                    <h3>üîí Keamanan yang Diimplementasikan</h3>
                    <ul>
                        <li>‚úÖ Admin-only access dengan AdminMiddleware</li>
                        <li>‚úÖ JWT token validation</li>
                        <li>‚úÖ Input validation dengan go-playground/validator</li>
                        <li>‚úÖ SQL injection protection (GORM)</li>
                        <li>‚úÖ Soft delete untuk data integrity</li>
                        <li>‚úÖ Duplicate name prevention</li>
                        <li>‚úÖ Proper error handling</li>
                    </ul>

                    <h3>üéâ Selamat!</h3>
                    <p>Anda telah berhasil mengimplementasikan modul CRUD Kategori yang lengkap! Sistem manajemen kategori sudah siap untuk digunakan dan hanya bisa diakses oleh admin. Fitur ini dapat diintegrasikan dengan modul Product Management di bab selanjutnya.</p>

                    <div style="text-align: center; margin: 3rem 0;">
                        <div style="background: #f8f9fa; border: 1px solid #dee2e6; color: #2c3e50; padding: 2rem; border-radius: 5px; display: inline-block;">
                            <h3 style="color: #2c3e50; margin-bottom: 1rem;">üéØ Siap untuk Modul Selanjutnya?</h3>
                            <p style="color: #495057; margin-bottom: 0;">Dengan sistem CRUD Kategori yang lengkap, Anda siap untuk melanjutkan ke modul Product Management yang akan menggunakan kategori ini!</p>
                        </div>
                    </div>
                `
            },
            {
                id: 'chapter11',
                title: 'Bab 11: Modul CRUD Product - Role Admin',
                meta: 'Halaman 12 dari 55 ‚Ä¢ Dibaca 15 menit',
                content: `
                    <h2>üì¶ Bab 11: Modul CRUD Product - Role Admin</h2>
                    <p>Selamat! Sekarang kita akan membuat modul CRUD (Create, Read, Update, Delete) untuk Product yang hanya bisa diakses oleh admin. Di bab ini, kita akan mengimplementasikan sistem manajemen produk dengan role-based access control dan relasi dengan kategori.</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">üéØ Apa yang Akan Kita Buat di Bab Ini?</h3>
                        <p style="color: #495057; margin-bottom: 0;">Kita akan membuat sistem CRUD produk yang lengkap dengan Create, Read, Update, Delete operations. Semua endpoint hanya bisa diakses oleh admin. Produk akan memiliki relasi dengan kategori dan fitur manajemen stok.</p>
                    </div>

                    <h3>üìã Prasyarat</h3>
                    <p>Sebelum memulai, pastikan Anda sudah menyelesaikan:</p>
                    <ul>
                        <li>‚úÖ Bab 6-8: Modul Authentication (Register, Login, Logout)</li>
                        <li>‚úÖ Bab 9: Review Pembelajaran Authentication</li>
                        <li>‚úÖ Bab 10: Modul CRUD Kategori - Role Admin</li>
                        <li>‚úÖ Middleware authentication sudah berfungsi</li>
                        <li>‚úÖ AdminMiddleware sudah diimplementasikan</li>
                        <li>‚úÖ Tabel categories sudah ada di database</li>
                    </ul>

                    <h3>üóÑÔ∏è Database Schema - Tabel Products</h3>
                    <p>Pertama, kita perlu membuat tabel products dengan struktur sebagai berikut:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>üìä Struktur Tabel Products</h4>
                        <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                            <thead>
                                <tr style="background-color: #e9ecef;">
                                    <th style="border: 1px solid #dee2e6; padding: 0.75rem; text-align: left;">Field</th>
                                    <th style="border: 1px solid #dee2e6; padding: 0.75rem; text-align: left;">Type</th>
                                    <th style="border: 1px solid #dee2e6; padding: 0.75rem; text-align: left;">Constraint</th>
                                    <th style="border: 1px solid #dee2e6; padding: 0.75rem; text-align: left;">Description</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">id</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">BIGINT</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">PK, Auto Increment</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Primary key</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">name</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">VARCHAR</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">NOT NULL</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Nama produk</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">description</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">TEXT</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">NULL</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Deskripsi produk</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">purchase_price</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">DECIMAL(10,2)</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">NOT NULL</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Harga beli</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">selling_price</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">DECIMAL(10,2)</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">NOT NULL</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Harga jual</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">stock</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">INT</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">NOT NULL, DEFAULT 0</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Stok produk</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">category_id</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">BIGINT</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">FK ‚Üí Categories(id)</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">ID kategori</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">image_url</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">VARCHAR(255)</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">NULL</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">URL gambar produk (opsional)</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">created_at</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">TIMESTAMP</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">DEFAULT CURRENT_TIMESTAMP</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Waktu dibuat</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">updated_at</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">TIMESTAMP</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">Waktu diupdate</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <h4>üîß SQL untuk Membuat Tabel Products</h4>
                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>CREATE TABLE products (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    purchase_price DECIMAL(10,2) NOT NULL,
    selling_price DECIMAL(10,2) NOT NULL,
    stock INT NOT NULL DEFAULT 0,
    category_id BIGINT NOT NULL,
    image_url VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (category_id) REFERENCES categories(id) ON DELETE CASCADE
);</code></pre>

                    <h3>üìÅ Struktur File yang Akan Dibuat</h3>
                    <p>Kita akan membuat file-file berikut untuk modul Product:</p>
                    <ul>
                        <li><code>models/product.go</code> - Model Product</li>
                        <li><code>requests/product_request.go</code> - Request structs</li>
                        <li><code>responses/product_response.go</code> - Response structs</li>
                        <li><code>repositories/product_repository.go</code> - Database operations</li>
                        <li><code>services/product_service.go</code> - Business logic</li>
                        <li><code>handlers/product_handler.go</code> - HTTP handlers</li>
                    </ul>

                    <h3>üèóÔ∏è Langkah 1: Membuat Model Product</h3>
                    <p>Buat file <code>models/product.go</code>:</p>

                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>package models

import "time"

type Product struct {
    ID            uint      \`json:"id" gorm:"primaryKey"\`
    Name          string    \`json:"name" gorm:"not null"\`
    Description   string    \`json:"description"\`
    PurchasePrice float64   \`json:"purchase_price" gorm:"not null;type:decimal(10,2)"\`
    SellingPrice  float64   \`json:"selling_price" gorm:"not null;type:decimal(10,2)"\`
    Stock         int       \`json:"stock" gorm:"not null;default:0"\`
    CategoryID    uint      \`json:"category_id" gorm:"not null"\`
    Category      Category  \`json:"category" gorm:"foreignKey:CategoryID"\`
    ImageURL      string    \`json:"image_url"\`
    CreatedAt     time.Time \`json:"created_at"\`
    UpdatedAt     time.Time \`json:"updated_at"\`
}

func (Product) TableName() string {
    return "products"
}</code></pre>

                    <h4>üìù Penjelasan Model Product:</h4>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h5 style="color: #2c3e50; margin-bottom: 1rem;">üîç Struktur Model yang Diimplementasikan</h5>
                        
                        <p><strong>1. Product Struct Fields:</strong></p>
                        <ul>
                            <li><code>ID</code> - Primary key dengan auto increment (uint)</li>
                            <li><code>Name</code> - Nama produk (string, required)</li>
                            <li><code>Description</code> - Deskripsi produk (string, optional)</li>
                            <li><code>PurchasePrice</code> - Harga beli dengan 2 desimal (float64, required)</li>
                            <li><code>SellingPrice</code> - Harga jual dengan 2 desimal (float64, required)</li>
                            <li><code>Stock</code> - Jumlah stok dengan default 0 (int, required)</li>
                            <li><code>CategoryID</code> - Foreign key ke tabel categories (uint, required)</li>
                            <li><code>Category</code> - Relasi ke model Category (struct, optional)</li>
                            <li><code>ImageURL</code> - URL gambar produk (string, optional)</li>
                            <li><code>CreatedAt</code> - Timestamp pembuatan (time.Time)</li>
                            <li><code>UpdatedAt</code> - Timestamp update (time.Time)</li>
                        </ul>

                        <p><strong>2. GORM Tags:</strong></p>
                        <ul>
                            <li><code>primaryKey</code> - Menandai field sebagai primary key</li>
                            <li><code>not null</code> - Field wajib diisi</li>
                            <li><code>type:decimal(10,2)</code> - Tipe data decimal dengan 10 digit, 2 desimal</li>
                            <li><code>default:0</code> - Nilai default untuk stok</li>
                            <li><code>foreignKey:CategoryID</code> - Menentukan foreign key untuk relasi</li>
                        </ul>

                        <p><strong>3. TableName Method:</strong></p>
                        <ul>
                            <li>Mengembalikan nama tabel "products" secara eksplisit</li>
                            <li>Memastikan GORM menggunakan nama tabel yang benar</li>
                        </ul>

                        <p style="color: #495057; margin-bottom: 0;"><strong>üí° Keuntungan:</strong> Model ini mendefinisikan struktur data yang konsisten dengan database dan menyediakan relasi yang jelas dengan Category.</p>
                    </div>

                    <h3>üìù Langkah 2: Membuat Request Structs</h3>
                    <p>Buat file <code>requests/product_request.go</code>:</p>
                    
                    <div style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 1rem; margin: 2rem 0;">
                        <strong>üí° Perubahan Penting:</strong> Untuk image, kita akan menggunakan file upload instead of URL. Field ImageURL sudah dihapus dari request struct karena akan ditangani secara terpisah melalui file upload.
                    </div>

                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>package requests

import (
    "errors"
    "strings"

    "github.com/go-playground/validator/v10"
)

// CreateProductRequest represents the request structure for creating product
type CreateProductRequest struct {
    Name          string  \`json:"name" validate:"required,min=3,max=255"\`
    Description   string  \`json:"description"\`
    PurchasePrice float64 \`json:"purchase_price" validate:"required,min=0"\`
    SellingPrice  float64 \`json:"selling_price" validate:"required,min=0"\`
    Stock         int     \`json:"stock" validate:"min=0"\`
    CategoryID    uint    \`json:"category_id" validate:"required"\`
}

// UpdateProductRequest represents the request structure for updating product
type UpdateProductRequest struct {
    Name          string  \`json:"name" validate:"required,min=3,max=255"\`
    Description   string  \`json:"description"\`
    PurchasePrice float64 \`json:"purchase_price" validate:"required,min=0"\`
    SellingPrice  float64 \`json:"selling_price" validate:"required,min=0"\`
    Stock         int     \`json:"stock" validate:"min=0"\`
    CategoryID    uint    \`json:"category_id" validate:"required"\`
}

// Validate validates the CreateProductRequest using the validator
func (r *CreateProductRequest) Validate() error {
    validate := validator.New()

    // Validasi struct fields
    if err := validate.Struct(r); err != nil {
        return err
    }

    // Validasi custom: nama tidak boleh kosong setelah trim
    if strings.TrimSpace(r.Name) == "" {
        return errors.New("name cannot be empty")
    }

    // Validasi custom: selling price harus lebih besar dari purchase price
    if r.SellingPrice <= r.PurchasePrice {
        return errors.New("selling price must be greater than purchase price")
    }

    return nil
}

// Validate validates the UpdateProductRequest using the validator
func (r *UpdateProductRequest) Validate() error {
    validate := validator.New()

    // Validasi struct fields
    if err := validate.Struct(r); err != nil {
        return err
    }

    // Validasi custom: nama tidak boleh kosong setelah trim
    if strings.TrimSpace(r.Name) == "" {
        return errors.New("name cannot be empty")
    }

    // Validasi custom: selling price harus lebih besar dari purchase price
    if r.SellingPrice <= r.PurchasePrice {
        return errors.New("selling price must be greater than purchase price")
    }

    return nil
}</code></pre>

                    <h4>üìù Penjelasan Request Structs:</h4>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h5 style="color: #2c3e50; margin-bottom: 1rem;">üîç Struktur Request yang Diimplementasikan</h5>
                        
                        <p><strong>1. CreateProductRequest Struct:</strong></p>
                        <ul>
                            <li><code>Name</code> - Nama produk (required, min 3, max 255 karakter)</li>
                            <li><code>Description</code> - Deskripsi produk (optional)</li>
                            <li><code>PurchasePrice</code> - Harga beli (required, minimal 0)</li>
                            <li><code>SellingPrice</code> - Harga jual (required, minimal 0)</li>
                            <li><code>Stock</code> - Jumlah stok (minimal 0)</li>
                            <li><code>CategoryID</code> - ID kategori (required)</li>
                            <li><strong>Image:</strong> File gambar produk akan diupload secara terpisah (tidak termasuk dalam request struct)</li>
                        </ul>

                        <p><strong>2. UpdateProductRequest Struct:</strong></p>
                        <ul>
                            <li>Struktur yang sama dengan CreateProductRequest</li>
                            <li>Digunakan untuk update data produk yang sudah ada</li>
                            <li>Validasi yang sama untuk memastikan data konsisten</li>
                        </ul>

                        <p><strong>3. Validator Tags:</strong></p>
                        <ul>
                            <li><code>validate:"required"</code> - Field wajib diisi</li>
                            <li><code>validate:"min=3,max=255"</code> - Panjang string minimal 3, maksimal 255</li>
                            <li><code>validate:"min=0"</code> - Nilai numerik minimal 0</li>
                            <li>Validasi menggunakan go-playground/validator</li>
                        </ul>

                        <p><strong>4. Custom Validation Methods:</strong></p>
                        <ul>
                            <li><code>Validate()</code> - Method untuk validasi custom</li>
                            <li>Validasi nama tidak boleh kosong setelah trim</li>
                            <li>Validasi selling price harus lebih besar dari purchase price</li>
                            <li>Konsisten dengan pattern category</li>
                        </ul>

                        <p style="color: #495057; margin-bottom: 0;"><strong>üí° Keuntungan:</strong> Request structs dengan method Validate() memisahkan input validation dari business logic, memastikan data yang masuk sudah valid, dan mengikuti pattern yang konsisten dengan category.</p>
                    </div>

                    <h3>üì§ Langkah 3: Membuat Response Structs</h3>
                    <p>Buat file <code>responses/product_response.go</code>:</p>

                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>package responses

import "tokogo/models"

type ProductResponse struct {
    ID            uint    \`json:"id"\`
    Name          string  \`json:"name"\`
    Description   string  \`json:"description"\`
    PurchasePrice float64 \`json:"purchase_price"\`
    SellingPrice  float64 \`json:"selling_price"\`
    Stock         int     \`json:"stock"\`
    CategoryID    uint    \`json:"category_id"\`
    CategoryName  string  \`json:"category_name"\`
    ImagePath     string  \`json:"image_path"\`
    CreatedAt     string  \`json:"created_at"\`
    UpdatedAt     string  \`json:"updated_at"\`
}

type ProductListResponse struct {
    Products []ProductResponse \`json:"products"\`
    Total    int64             \`json:"total"\`
    Page     int               \`json:"page"\`
    Limit    int               \`json:"limit"\`
}

func ConvertProductToResponse(product models.Product) ProductResponse {
    return ProductResponse{
        ID:            product.ID,
        Name:          product.Name,
        Description:   product.Description,
        PurchasePrice: product.PurchasePrice,
        SellingPrice:  product.SellingPrice,
        Stock:         product.Stock,
        CategoryID:    product.CategoryID,
        CategoryName:  product.Category.Name,
        ImagePath:     product.ImagePath,
        CreatedAt:     product.CreatedAt.Format("2006-01-02 15:04:05"),
        UpdatedAt:     product.UpdatedAt.Format("2006-01-02 15:04:05"),
    }
}

func ConvertProductsToResponse(products []models.Product) []ProductResponse {
    var responses []ProductResponse
    for _, product := range products {
        responses = append(responses, ConvertProductToResponse(product))
    }
    return responses
}</code></pre>

                    <h4>üìù Penjelasan Response Structs:</h4>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h5 style="color: #2c3e50; margin-bottom: 1rem;">üîç Struktur Response yang Diimplementasikan</h5>
                        
                        <p><strong>1. ProductResponse Struct:</strong></p>
                        <ul>
                            <li><code>ID</code> - ID unik produk (uint)</li>
                            <li><code>Name</code> - Nama produk</li>
                            <li><code>Description</code> - Deskripsi produk</li>
                            <li><code>PurchasePrice</code> - Harga beli (float64)</li>
                            <li><code>SellingPrice</code> - Harga jual (float64)</li>
                            <li><code>Stock</code> - Jumlah stok (int)</li>
                            <li><code>CategoryID</code> - ID kategori (uint)</li>
                            <li><code>CategoryName</code> - Nama kategori (string) - diambil dari relasi</li>
                            <li><code>ImagePath</code> - Path file gambar produk (untuk file upload)</li>
                            <li><code>CreatedAt</code> - Waktu dibuat (format string "2006-01-02 15:04:05")</li>
                            <li><code>UpdatedAt</code> - Waktu diupdate (format string "2006-01-02 15:04:05")</li>
                        </ul>

                        <p><strong>2. ProductListResponse Struct:</strong></p>
                        <ul>
                            <li><code>Products</code> - Array dari ProductResponse</li>
                            <li><code>Total</code> - Total jumlah produk (int64)</li>
                            <li><code>Page</code> - Halaman saat ini (int)</li>
                            <li><code>Limit</code> - Jumlah item per halaman (int)</li>
                        </ul>

                        <p><strong>3. Helper Functions:</strong></p>
                        <ul>
                            <li><code>ConvertProductToResponse()</code> - Mengkonversi model Product ke ProductResponse</li>
                            <li><code>ConvertProductsToResponse()</code> - Mengkonversi array model Product ke array ProductResponse</li>
                            <li>Format tanggal menggunakan "2006-01-02 15:04:05" untuk konsistensi</li>
                            <li>Konsisten dengan pattern category response</li>
                        </ul>

                        <p style="color: #495057; margin-bottom: 0;"><strong>üí° Keuntungan:</strong> Helper functions memudahkan konversi data, memastikan konsistensi response format di seluruh aplikasi, dan mengikuti pattern yang sama dengan category untuk maintainability yang lebih baik.</p>
                    </div>

                    <h3>üìÅ Langkah 4: Membuat File Upload Helper</h3>
                    <p>Buat file <code>helpers/file_upload.go</code> untuk menangani file upload:</p>
                    
                  
                    
                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>package helpers

import (
    "fmt"
    "io"
    "mime/multipart"
    "os"
    "path/filepath"
    "strings"
    "time"
)

// UploadFile handles file upload and returns the file path
func UploadFile(file *multipart.FileHeader, uploadDir string) (string, error) {
    // Create upload directory if it doesn't exist
    if err := os.MkdirAll(uploadDir, 0755); err != nil {
        return "", fmt.Errorf("failed to create upload directory: %v", err)
    }

    // Validate file type
    allowedTypes := []string{"image/jpeg", "image/jpg", "image/png", "image/gif"}
    contentType := file.Header.Get("Content-Type")
    if !isAllowedType(contentType, allowedTypes) {
        return "", fmt.Errorf("file type not allowed. Allowed types: %v", allowedTypes)
    }

    // Validate file size (max 5MB)
    maxSize := int64(5 * 1024 * 1024) // 5MB
    if file.Size > maxSize {
        return "", fmt.Errorf("file size too large. Maximum size: 5MB")
    }

    // Generate unique filename
    ext := filepath.Ext(file.Filename)
    filename := fmt.Sprintf("%d_%s%s", time.Now().Unix(), generateRandomString(10), ext)
    filePath := filepath.Join(uploadDir, filename)

    // Open uploaded file
    src, err := file.Open()
    if err != nil {
        return "", fmt.Errorf("failed to open uploaded file: %v", err)
    }
    defer src.Close()

    // Create destination file
    dst, err := os.Create(filePath)
    if err != nil {
        return "", fmt.Errorf("failed to create destination file: %v", err)
    }
    defer dst.Close()

    // Copy file content
    if _, err := io.Copy(dst, src); err != nil {
        return "", fmt.Errorf("failed to copy file: %v", err)
    }

    // Return relative path for database storage
    return filePath, nil
}

// DeleteFile deletes a file from the filesystem
func DeleteFile(filePath string) error {
    if filePath == "" {
        return nil
    }
    
    if err := os.Remove(filePath); err != nil && !os.IsNotExist(err) {
        return fmt.Errorf("failed to delete file: %v", err)
    }
    
    return nil
}

// isAllowedType checks if the content type is in the allowed list
func isAllowedType(contentType string, allowedTypes []string) bool {
    for _, allowedType := range allowedTypes {
        if contentType == allowedType {
            return true
        }
    }
    return false
}

// generateRandomString generates a random string of specified length
func generateRandomString(length int) string {
    const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    b := make([]byte, length)
    for i := range b {
        b[i] = charset[time.Now().UnixNano()%int64(len(charset))]
    }
    return string(b)
}</code></pre>

                    <h4>üìù Penjelasan File Upload Helper:</h4>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h5 style="color: #2c3e50; margin-bottom: 1rem;">üîç Fungsi File Upload yang Diimplementasikan</h5>
                        
                        <p><strong>1. UploadFile Function:</strong></p>
                        <ul>
                            <li>Membuat direktori upload jika belum ada</li>
                            <li>Validasi tipe file (hanya image: jpeg, jpg, png, gif)</li>
                            <li>Validasi ukuran file (maksimal 5MB)</li>
                            <li>Generate nama file unik dengan timestamp</li>
                            <li>Menyimpan file ke direktori yang ditentukan</li>
                        </ul>

                        <p><strong>2. DeleteFile Function:</strong></p>
                        <ul>
                            <li>Menghapus file dari filesystem</li>
                            <li>Menangani error jika file tidak ada</li>
                            <li>Digunakan untuk cleanup saat update/delete</li>
                        </ul>

                        <p><strong>3. Helper Functions:</strong></p>
                        <ul>
                            <li><code>isAllowedType()</code> - Validasi tipe file</li>
                            <li><code>generateRandomString()</code> - Generate string random untuk nama file</li>
                        </ul>

                        <p style="color: #495057; margin-bottom: 0;"><strong>üí° Keuntungan:</strong> Helper ini memastikan file upload yang aman dengan validasi tipe file, ukuran, dan nama file yang unik untuk menghindari konflik.</p>
                    </div>

                    <h3>üóÑÔ∏è Langkah 5: Membuat Repository</h3>
                    <p>Buat file <code>repositories/product_repository.go</code>:</p>

                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>package repositories

import (
    "tokogo/models"
    "gorm.io/gorm"
)

type ProductRepository struct {
    db *gorm.DB
}

func NewProductRepository(db *gorm.DB) *ProductRepository {
    return &ProductRepository{db: db}
}

func (r *ProductRepository) Create(product *models.Product) error {
    return r.db.Create(product).Error
}

func (r *ProductRepository) GetAll(page, limit int) ([]models.Product, int64, error) {
    var products []models.Product
    var total int64

    offset := (page - 1) * limit

    // Count total records
    if err := r.db.Model(&models.Product{}).Count(&total).Error; err != nil {
        return nil, 0, err
    }

    // Get products with pagination
    err := r.db.Preload("Category").
        Offset(offset).
        Limit(limit).
        Find(&products).Error

    return products, total, err
}

func (r *ProductRepository) GetByID(id uint) (*models.Product, error) {
    var product models.Product
    err := r.db.Preload("Category").First(&product, id).Error
    return &product, err
}

func (r *ProductRepository) Update(product *models.Product) error {
    return r.db.Save(product).Error
}

func (r *ProductRepository) Delete(id uint) error {
    return r.db.Delete(&models.Product{}, id).Error
}

func (r *ProductRepository) GetByCategoryID(categoryID uint, page, limit int) ([]models.Product, int64, error) {
    var products []models.Product
    var total int64

    offset := (page - 1) * limit

    // Count total records
    if err := r.db.Model(&models.Product{}).Where("category_id = ?", categoryID).Count(&total).Error; err != nil {
        return nil, 0, err
    }

    // Get products with pagination
    err := r.db.Preload("Category").
        Where("category_id = ?", categoryID).
        Offset(offset).
        Limit(limit).
        Find(&products).Error

    return products, total, err
}</code></pre>

                    <h4>üìù Penjelasan Repository:</h4>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h5 style="color: #2c3e50; margin-bottom: 1rem;">üîç Struktur Repository yang Diimplementasikan</h5>
                        
                        <p><strong>1. ProductRepository Struct:</strong></p>
                        <ul>
                            <li>Menggunakan dependency injection untuk database connection</li>
                            <li>Mengisolasi semua operasi database dalam satu layer</li>
                            <li>Menggunakan GORM untuk ORM operations</li>
                        </ul>

                        <p><strong>2. Constructor Function:</strong></p>
                        <ul>
                            <li><code>NewProductRepository()</code> - Factory function untuk membuat instance repository</li>
                            <li>Menerima database connection sebagai parameter</li>
                            <li>Mengembalikan pointer ke ProductRepository</li>
                        </ul>

                        <p><strong>3. CRUD Operations:</strong></p>
                        <ul>
                            <li><code>Create()</code> - Membuat produk baru di database</li>
                            <li><code>GetAll()</code> - Mengambil semua produk dengan pagination dan relasi Category</li>
                            <li><code>GetByID()</code> - Mengambil produk berdasarkan ID dengan relasi Category</li>
                            <li><code>Update()</code> - Mengupdate data produk yang sudah ada</li>
                            <li><code>Delete()</code> - Menghapus produk berdasarkan ID</li>
                            <li><code>GetByCategoryID()</code> - Mengambil produk berdasarkan kategori dengan pagination</li>
                        </ul>

                        <p><strong>4. GORM Features:</strong></p>
                        <ul>
                            <li><code>Preload("Category")</code> - Eager loading untuk relasi Category</li>
                            <li><code>Offset()</code> dan <code>Limit()</code> - Implementasi pagination</li>
                            <li><code>Where()</code> - Filter berdasarkan kondisi tertentu</li>
                            <li><code>Count()</code> - Menghitung total records untuk pagination</li>
                        </ul>

                        <p style="color: #495057; margin-bottom: 0;"><strong>üí° Keuntungan:</strong> Repository pattern memisahkan data access logic dari business logic, memudahkan testing, dan menyediakan interface yang konsisten untuk operasi database.</p>
                    </div>

                    <h3>‚öôÔ∏è Langkah 6: Membuat Service</h3>
                    <p>Buat file <code>services/product_service.go</code>:</p>

                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>package services

import (
	"errors"
	"tokogo/config"
	"tokogo/helpers"
	"tokogo/models"
	"tokogo/repositories"
	"tokogo/requests"
	"tokogo/responses"
)

type ProductService struct {
	productRepo  *repositories.ProductRepository
	categoryRepo *repositories.CategoryRepository
}

// NewProductService membuat instance baru ProductService
func NewProductService() *ProductService {
	return &ProductService{
		productRepo:  repositories.NewProductRepository(config.DB),
		categoryRepo: repositories.NewCategoryRepository(),
	}
}

// CreateProduct membuat product baru
func (s *ProductService) CreateProduct(req requests.CreateProductRequest, imagePath string) (*responses.ProductResponse, error) {
	// Cek apakah category ada
	_, err := s.categoryRepo.GetCategoryByID(req.CategoryID)
	if err != nil {
		return nil, errors.New("category not found")
	}

	// Buat product baru
	product := &models.Product{
		Name:          req.Name,
		Description:   req.Description,
		PurchasePrice: req.PurchasePrice,
		SellingPrice:  req.SellingPrice,
		Stock:         req.Stock,
		CategoryID:    req.CategoryID,
		ImagePath:     imagePath,
	}

	// Simpan ke database
	if err := s.productRepo.Create(product); err != nil {
		// If database save fails, delete uploaded file
		if imagePath != "" {
			helpers.DeleteFile(imagePath)
		}
		return nil, errors.New("failed to create product")
	}

	// Return response
	response := responses.ConvertProductToResponse(*product)
	return &response, nil
}

func (s *ProductService) GetAllProducts(page, limit int) (*responses.ProductListResponse, error) {
	if page < 1 {
		page = 1
	}
	if limit < 1 {
		limit = 10
	}

	products, total, err := s.productRepo.GetAll(page, limit)
	if err != nil {
		return nil, err
	}

	productResponses := responses.ConvertProductsToResponse(products)

	return &responses.ProductListResponse{
		Products: productResponses,
		Total:    total,
		Page:     page,
		Limit:    limit,
	}, nil
}

func (s *ProductService) GetProductByID(id uint) (*responses.ProductResponse, error) {
	product, err := s.productRepo.GetByID(id)
	if err != nil {
		return nil, err
	}

	response := responses.ConvertProductToResponse(*product)
	return &response, nil
}

func (s *ProductService) UpdateProduct(id uint, req requests.UpdateProductRequest) (*responses.ProductResponse, error) {
	// Get existing product
	product, err := s.productRepo.GetByID(id)
	if err != nil {
		return nil, err
	}

	// Validate category exists
	_, err = s.categoryRepo.GetCategoryByID(req.CategoryID)
	if err != nil {
		return nil, errors.New("category not found")
	}

	// Update product fields
	product.Name = req.Name
	product.Description = req.Description
	product.PurchasePrice = req.PurchasePrice
	product.SellingPrice = req.SellingPrice
	product.Stock = req.Stock
	product.CategoryID = req.CategoryID
	product.ImageURL = req.ImageURL

	if err := s.productRepo.Update(product); err != nil {
		return nil, err
	}

	response := responses.ConvertProductToResponse(*product)
	return &response, nil
}

func (s *ProductService) DeleteProduct(id uint) error {
	// Check if product exists
	_, err := s.productRepo.GetByID(id)
	if err != nil {
		return err
	}

	return s.productRepo.Delete(id)
}

func (s *ProductService) GetProductsByCategory(categoryID uint, page, limit int) (*responses.ProductListResponse, error) {
	if page < 1 {
		page = 1
	}
	if limit < 1 {
		limit = 10
	}

	products, total, err := s.productRepo.GetByCategoryID(categoryID, page, limit)
	if err != nil {
		return nil, err
	}

	productResponses := responses.ConvertProductsToResponse(products)

	return &responses.ProductListResponse{
		Products: productResponses,
		Total:    total,
		Page:     page,
		Limit:    limit,
	}, nil
}


                        </code></pre>

                    <h4>üìù Penjelasan Service:</h4>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h5 style="color: #2c3e50; margin-bottom: 1rem;">üîç Struktur Service yang Diimplementasikan</h5>
                        
                        <p><strong>1. ProductService Struct:</strong></p>
                        <ul>
                            <li>Menggunakan dependency injection untuk repository dependencies</li>
                            <li>Mengisolasi business logic dari data access layer</li>
                            <li>Menggunakan ProductRepository dan CategoryRepository</li>
                        </ul>

                        <p><strong>2. Constructor Function:</strong></p>
                        <ul>
                            <li><code>NewProductService()</code> - Factory function untuk membuat instance service</li>
                            <li>Menerima repository dependencies sebagai parameter</li>
                            <li>Mengembalikan pointer ke ProductService</li>
                        </ul>

                        <p><strong>3. Business Logic Methods:</strong></p>
                        <ul>
                            <li><code>CreateProduct()</code> - Validasi kategori dan membuat produk baru</li>
                            <li><code>GetAllProducts()</code> - Mengambil semua produk dengan pagination</li>
                            <li><code>GetProductByID()</code> - Mengambil produk berdasarkan ID</li>
                            <li><code>UpdateProduct()</code> - Validasi dan update data produk</li>
                            <li><code>DeleteProduct()</code> - Validasi dan hapus produk</li>
                            <li><code>GetProductsByCategory()</code> - Mengambil produk berdasarkan kategori</li>
                        </ul>

                        <p><strong>4. Business Rules:</strong></p>
                        <ul>
                            <li>Validasi kategori harus ada sebelum membuat/update produk</li>
                            <li>Default pagination (page=1, limit=10) jika parameter tidak valid</li>
                            <li>Menggunakan helper functions dari responses package</li>
                            <li>Error handling yang konsisten</li>
                        </ul>

                        <p style="color: #495057; margin-bottom: 0;"><strong>üí° Keuntungan:</strong> Service layer mengimplementasikan business logic, validasi, dan koordinasi antara repository dan response layer, memisahkan concerns dengan jelas.</p>
                    </div>

                    <h3>üåê Langkah 7: Membuat Handler</h3>
                    <p>Buat file <code>handlers/product_handler.go</code>:</p>

                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>package handlers

import (
    "net/http"
    "strconv"
    "tokogo/helpers"
    "tokogo/requests"
    "tokogo/responses"
    "tokogo/services"

    "github.com/gin-gonic/gin"
)

type ProductHandler struct {
    productService *services.ProductService
}

// NewProductHandler membuat instance baru ProductHandler
func NewProductHandler() *ProductHandler {
    return &ProductHandler{
        productService: services.NewProductService(),
    }
}

// CreateProduct handler untuk membuat product baru
func (h *ProductHandler) CreateProduct(c *gin.Context) {
    var req requests.CreateProductRequest

    // Bind form data (including file upload)
    if err := c.ShouldBind(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Validasi menggunakan method Validate()
    if err := req.Validate(); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Handle file upload
    var imagePath string
    if file, err := c.FormFile("image"); err == nil {
        // File was uploaded
        uploadDir := "./uploads/products"
        uploadedPath, err := helpers.UploadFile(file, uploadDir)
        if err != nil {
            c.JSON(http.StatusBadRequest, responses.ErrorResponse{
                Error:   "upload_failed",
                Message: err.Error(),
            })
            return
        }
        imagePath = uploadedPath
    }

    // Panggil service untuk create product
    productResponse, err := h.productService.CreateProduct(req, imagePath)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "create_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusCreated, responses.SuccessResponse{
        Message: "Product created successfully",
        Data:    productResponse,
    })
}

// GetAllProducts godoc
// @Summary Get all products
// @Description Get all products with pagination (Admin only)
// @Tags Products
// @Produce json
// @Param page query int false "Page number" default(1)
// @Param limit query int false "Items per page" default(10)
// @Success 200 {object} responses.ProductListResponse
// @Failure 401 {object} map[string]string
// @Failure 403 {object} map[string]string
// @Router /admin/products [get]
func (h *ProductHandler) GetAllProducts(c *gin.Context) {
    page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
    limit, _ := strconv.Atoi(c.DefaultQuery("limit", "10"))

    products, err := h.productService.GetAllProducts(page, limit)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusOK, products)
}

// GetProductByID godoc
// @Summary Get product by ID
// @Description Get a specific product by ID (Admin only)
// @Tags Products
// @Produce json
// @Param id path int true "Product ID"
// @Success 200 {object} responses.ProductResponse
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 403 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /admin/products/{id} [get]
func (h *ProductHandler) GetProductByID(c *gin.Context) {
    id, err := strconv.ParseUint(c.Param("id"), 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid product ID"})
        return
    }

    product, err := h.productService.GetProductByID(uint(id))
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": "Product not found"})
        return
    }

    c.JSON(http.StatusOK, product)
}

// UpdateProduct godoc
// @Summary Update product
// @Description Update a product by ID (Admin only)
// @Tags Products
// @Accept json
// @Produce json
// @Param id path int true "Product ID"
// @Param product body requests.UpdateProductRequest true "Product data"
// @Success 200 {object} responses.ProductResponse
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 403 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /admin/products/{id} [put]
func (h *ProductHandler) UpdateProduct(c *gin.Context) {
    id, err := strconv.ParseUint(c.Param("id"), 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid product ID"})
        return
    }

    var req requests.UpdateProductRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    product, err := h.productService.UpdateProduct(uint(id), req)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusOK, product)
}

// DeleteProduct godoc
// @Summary Delete product
// @Description Delete a product by ID (Admin only)
// @Tags Products
// @Produce json
// @Param id path int true "Product ID"
// @Success 200 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 403 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /admin/products/{id} [delete]
func (h *ProductHandler) DeleteProduct(c *gin.Context) {
    id, err := strconv.ParseUint(c.Param("id"), 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid product ID"})
        return
    }

    err = h.productService.DeleteProduct(uint(id))
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": "Product not found"})
        return
    }

    c.JSON(http.StatusOK, gin.H{"message": "Product deleted successfully"})
}

// GetProductsByCategory godoc
// @Summary Get products by category
// @Description Get products by category ID with pagination (Admin only)
// @Tags Products
// @Produce json
// @Param category_id path int true "Category ID"
// @Param page query int false "Page number" default(1)
// @Param limit query int false "Items per page" default(10)
// @Success 200 {object} responses.ProductListResponse
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 403 {object} map[string]string
// @Router /admin/categories/{category_id}/products [get]
func (h *ProductHandler) GetProductsByCategory(c *gin.Context) {
    categoryID, err := strconv.ParseUint(c.Param("category_id"), 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid category ID"})
        return
    }

    page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
    limit, _ := strconv.Atoi(c.DefaultQuery("limit", "10"))

    products, err := h.productService.GetProductsByCategory(uint(categoryID), page, limit)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusOK, products)
}</code></pre>

                    <h3>üîó Langkah 8: Update main.go</h3>
                    <p>Tambahkan routes untuk product di <code>main.go</code>:</p>

                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>
                      package main

import (
	"log"
	"tokogo/config"
	"tokogo/handlers"
	"tokogo/middlewares"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
	"github.com/joho/godotenv"
)

func main() {
	// Load environment variables
	if err := godotenv.Load(); err != nil {
		log.Println("No .env file found, using system environment variables")
	}

	// Initialize database
	config.InitDB()

	// Setup Gin router
	r := gin.Default()

	// CORS middleware
	r.Use(cors.New(cors.Config{
		AllowOrigins:     []string{"*"},
		AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowHeaders:     []string{"*"},
		ExposeHeaders:    []string{"Content-Length"},
		AllowCredentials: true,
	}))

	// Static file serving for uploaded images
	r.Static("/uploads", "./uploads")

	// Initialize handlers
	authHandler := handlers.NewAuthHandler()
	categoryHandler := handlers.NewCategoryHandler()
	productHandler := handlers.NewProductHandler()

	// Public routes (tidak perlu authentication)
	api := r.Group("/api/v1")
	{
		// Auth routes
		auth := api.Group("/auth")
		{
			auth.POST("/register", authHandler.Register)
			auth.POST("/login", authHandler.Login)
		}
	}

	// Protected routes (perlu authentication)
	protected := r.Group("/api/v1")
	protected.Use(middlewares.AuthMiddleware())
	{
		// Auth protected routes
		auth := protected.Group("/auth")
		{
			auth.POST("/logout", authHandler.Logout)
			auth.GET("/profile", authHandler.GetProfile)
		}

		// Admin routes (perlu admin role)
		admin := protected.Group("/admin")
		admin.Use(middlewares.AdminMiddleware())
		{
			admin.GET("/dashboard", func(c *gin.Context) {
				c.JSON(200, gin.H{
					"message": "Welcome to admin dashboard",
					"user_id": c.GetUint("user_id"),
				})
			})

			categories := admin.Group("/categories")
			{
				categories.POST("", categoryHandler.CreateCategory)
				categories.GET("", categoryHandler.GetAllCategories)
				categories.GET("/:id", categoryHandler.GetCategoryByID)
				categories.PUT("/:id", categoryHandler.UpdateCategory)
				categories.DELETE("/:id", categoryHandler.DeleteCategory)
			}

			products := admin.Group("/products")
			{
				products.POST("", productHandler.CreateProduct)
				products.GET("", productHandler.GetAllProducts)
				products.GET("/:id", productHandler.GetProductByID)
				products.PUT("/:id", productHandler.UpdateProduct)
				products.DELETE("/:id", productHandler.DeleteProduct)
				products.GET("/categories/:category_id", productHandler.GetProductsByCategory)
			}
		}
	}

	// Start server
	port := config.GetEnv("SERVER_PORT", "8080")
	log.Printf("Server starting on port %s", port)
	r.Run(":" + port)
}
</code></pre>

 <h3>üìù Langkah 9: Update Database Config untuk AutoMigrate</h3>
                    <p>Update file <code>config/database.go</code> untuk menambahkan Category model:</p>

                    <pre><code>package config

import (
    "fmt"
    "log"
    "os"
    "tokogo/models"

    "gorm.io/driver/mysql"
    "gorm.io/gorm"
)

var DB *gorm.DB

// InitDB menginisialisasi koneksi database
func InitDB() {
    var err error

    // Konfigurasi database dari environment variables
    dbHost := GetEnv("DB_HOST", "localhost")
    dbPort := GetEnv("DB_PORT", "3306")
    dbUser := GetEnv("DB_USER", "root")
    dbPassword := GetEnv("DB_PASSWORD", "")
    dbName := GetEnv("DB_NAME", "tokogo")

    // Buat DSN (Data Source Name)
    dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local",
        dbUser, dbPassword, dbHost, dbPort, dbName)

    // Koneksi ke database
    DB, err = gorm.Open(mysql.Open(dsn), &gorm.Config{})
    if err != nil {
        log.Fatal("Failed to connect to database:", err)
    }

    log.Println("Database connected successfully")

    // Auto migrate models
    err = DB.AutoMigrate(
        &models.User{},
        &models.Category{},
        &models.Product{},
    )
    if err != nil {
        log.Fatal("Failed to migrate database:", err)
    }

    log.Println("Database migrated successfully")
}
</code></pre>

                    <h4>Penjelasan Database Config Update:</h4>
                    <ul>
                        <li><strong>AutoMigrate:</strong> Menambahkan &models.Category{} ke AutoMigrate</li>
                        <li><strong>Table Creation:</strong> GORM akan membuat tabel categories otomatis</li>
                        <li><strong>Schema Sync:</strong> Database schema akan sync dengan model</li>
                    </ul>

                    <h3>üß™ Testing dengan Postman</h3>
                    <p>Sekarang kita akan test semua endpoint product dengan file upload. Pastikan Anda sudah login sebagai admin dan mendapatkan JWT token.</p>

                    <div style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 1rem; margin: 2rem 0;">
                        <strong>üí° Penting:</strong> Untuk testing file upload, gunakan form-data instead of JSON. Di Postman, pilih "form-data" tab dan tambahkan field "image" dengan tipe "File".
                    </div>

                    <div style="background: #e8f5e8; border-left: 4px solid #4CAF50; padding: 1rem; margin: 2rem 0;">
                        <strong>üéØ Panduan Praktik Bertahap:</strong> Jika Anda merasa overwhelmed dengan banyaknya endpoint, ikuti urutan testing ini untuk memudahkan pemahaman:
                        <ol style="margin: 0.5rem 0 0 1rem;">
                            <li><strong>Step 1:</strong> Test GET All Products (tanpa file upload) - untuk memahami response format</li>
                            <li><strong>Step 2:</strong> Test GET Product by ID - untuk melihat struktur data lengkap</li>
                            <li><strong>Step 3:</strong> Test CREATE Product dengan file upload - fokus pada file upload</li>
                            <li><strong>Step 4:</strong> Test UPDATE Product dengan file upload baru - untuk memahami update flow</li>
                            <li><strong>Step 5:</strong> Test DELETE Product - untuk melihat cleanup file</li>
                        </ol>
                        Dengan urutan ini, Anda akan memahami setiap aspek file upload secara bertahap!
                    </div>

                    <h4>1. Create Product dengan File Upload</h4>
                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>POST /admin/products
Headers:
Authorization: Bearer YOUR_JWT_TOKEN

Body (form-data):
name: Laptop Gaming ASUS
description: Laptop gaming dengan spesifikasi tinggi
purchase_price: 8000000
selling_price: 10000000
stock: 5
category_id: 1
image: [SELECT FILE - pilih file gambar]</code></pre>

                    <h4>2. Get All Products</h4>
                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>GET /admin/products?page=1&limit=10
Headers:
Authorization: Bearer YOUR_JWT_TOKEN</code></pre>

                    <h4>3. Get Product by ID</h4>
                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>GET /admin/products/1
Headers:
Authorization: Bearer YOUR_JWT_TOKEN</code></pre>

                    <h4>4. Update Product</h4>
                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>PUT /admin/products/1
Headers:
Authorization: Bearer YOUR_JWT_TOKEN
Content-Type: application/json

Body:
{
    "name": "Laptop Gaming ASUS ROG",
    "description": "Laptop gaming dengan spesifikasi tinggi dan RGB keyboard",
    "purchase_price": 8500000,
    "selling_price": 10500000,
    "stock": 3,
    "category_id": 1,
    "image_url": "https://example.com/laptop-rog.jpg"
}</code></pre>

                    <h4>5. Delete Product</h4>
                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>DELETE /admin/products/1
Headers:
Authorization: Bearer YOUR_JWT_TOKEN</code></pre>

                    <h4>6. Get Products by Category</h4>
                    <pre style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>GET /admin/categories/1/products?page=1&limit=10
Headers:
Authorization: Bearer YOUR_JWT_TOKEN</code></pre>

                    <h3>‚úÖ Checklist Implementasi</h3>
                    <p>Pastikan Anda telah menyelesaikan semua langkah berikut:</p>
                    <ul>
                        <li>‚úÖ Membuat tabel products di database</li>
                        <li>‚úÖ Membuat model Product di models/product.go</li>
                        <li>‚úÖ Membuat request structs di requests/product_request.go</li>
                        <li>‚úÖ Membuat response structs di responses/product_response.go</li>
                        <li>‚úÖ Membuat repository di repositories/product_repository.go</li>
                        <li>‚úÖ Membuat service di services/product_service.go</li>
                        <li>‚úÖ Membuat handler di handlers/product_handler.go</li>
                        <li>‚úÖ Menambahkan routes di main.go</li>
                        <li>‚úÖ Test semua endpoint dengan Postman</li>
                    </ul>

                    <h3>üéØ Fitur yang Telah Diimplementasikan</h3>
                    <ul>
                        <li>‚úÖ <strong>Create Product</strong> - Membuat produk baru dengan validasi</li>
                        <li>‚úÖ <strong>Read Products</strong> - Melihat daftar produk dengan pagination</li>
                        <li>‚úÖ <strong>Read Product by ID</strong> - Melihat detail produk berdasarkan ID</li>
                        <li>‚úÖ <strong>Update Product</strong> - Mengupdate data produk</li>
                        <li>‚úÖ <strong>Delete Product</strong> - Menghapus produk</li>
                        <li>‚úÖ <strong>Get Products by Category</strong> - Melihat produk berdasarkan kategori</li>
                        <li>‚úÖ <strong>Admin Role Protection</strong> - Semua endpoint hanya bisa diakses admin</li>
                        <li>‚úÖ <strong>Input Validation</strong> - Validasi input menggunakan Gin binding</li>
                        <li>‚úÖ <strong>Database Relations</strong> - Relasi dengan tabel categories</li>
                        <li>‚úÖ <strong>Error Handling</strong> - Penanganan error yang baik</li>
                    </ul>

                    <div style="background: #d4edda; border: 1px solid #c3e6cb; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4 style="color: #155724; margin-bottom: 1rem;">üéâ Selamat! Modul CRUD Product Telah Selesai</h4>
                        <p style="color: #155724; margin-bottom: 0;">Anda telah berhasil mengimplementasikan sistem CRUD Product yang lengkap dengan role-based access control. Sistem ini siap untuk digunakan dalam aplikasi toko online Anda!</p>
                    </div>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; margin: 1.5rem 0; border-radius: 5px;">
                        <h4>üéØ Preview Bab 12: Modul CRUD Customer - Role Admin</h4>
                        <p>Di bab selanjutnya, kita akan:</p>
                        <ul>
                            <li>Membuat sistem CRUD Customer untuk admin</li>
                            <li>Implementasi manajemen data pelanggan</li>
                            <li>Validasi dan keamanan data customer</li>
                            <li>Testing endpoint customer dengan Postman</li>
                        </ul>
                        <p style="color: #495057; margin-bottom: 0;">Dengan sistem CRUD Product yang lengkap, Anda siap untuk melanjutkan ke modul Customer Management!</p>
                    </div>

                    <h3>üéØ Pattern Consistency - Mengapa Penting?</h3>
                    <p>Dalam bab ini, kita telah mengimplementasikan pattern yang konsisten dengan modul Category. Ini adalah praktik yang sangat penting dalam pengembangan software. Berikut adalah keuntungan dari pattern yang konsisten:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #2c3e50; margin-bottom: 1rem;">üîç Pattern yang Konsisten yang Telah Diimplementasikan</h4>
                        
                        <p><strong>1. Request Validation Pattern:</strong></p>
                        <ul>
                            <li>Menggunakan method <code>Validate()</code> dengan custom validation</li>
                            <li>Menggunakan <code>validate</code> tag instead of <code>binding</code> tag</li>
                            <li>Validasi custom untuk business rules (selling price > purchase price)</li>
                            <li>Konsisten dengan pattern category</li>
                        </ul>

                        <p><strong>2. Response Format Pattern:</strong></p>
                        <ul>
                            <li>Menggunakan <code>SuccessResponse</code> dan <code>ErrorResponse</code></li>
                            <li>Format tanggal menggunakan string "2006-01-02 15:04:05"</li>
                            <li>Error handling yang konsisten dan informatif</li>
                            <li>Response structure yang seragam</li>
                        </ul>

                        <p><strong>3. Constructor Pattern:</strong></p>
                        <ul>
                            <li>Semua service dan handler menggunakan constructor tanpa parameter</li>
                            <li>Dependency injection yang konsisten</li>
                            <li>Factory pattern yang seragam</li>
                        </ul>

                        <p><strong>4. Code Comments Pattern:</strong></p>
                        <ul>
                            <li>Komentar yang konsisten dan informatif</li>
                            <li>Documentation yang seragam</li>
                            <li>Penjelasan yang jelas untuk setiap method</li>
                        </ul>

                        <p style="color: #495057; margin-bottom: 0;"><strong>üí° Keuntungan:</strong> Pattern yang konsisten membuat codebase lebih maintainable, scalable, dan mudah dipahami oleh developer lain. Ini adalah best practice dalam pengembangan software yang professional.</p>
                    </div>

                    <h3>üìÅ File Upload di Go - Best Practices</h3>
                    <p>Dalam bab ini, kita telah mengimplementasikan file upload yang aman dan efisien. Berikut adalah best practices untuk file upload di Go:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #2c3e50; margin-bottom: 1rem;">üîç Best Practices File Upload</h4>
                        
                        <p><strong>1. Validasi File Type:</strong></p>
                        <ul>
                            <li>Selalu validasi Content-Type header</li>
                            <li>Gunakan whitelist untuk tipe file yang diizinkan</li>
                            <li>Jangan percaya pada ekstensi file saja</li>
                        </ul>

                        <p><strong>2. Validasi File Size:</strong></p>
                        <ul>
                            <li>Set batas maksimal ukuran file</li>
                            <li>Validasi sebelum menyimpan ke disk</li>
                            <li>Berikan error message yang jelas</li>
                        </ul>

                        <p><strong>3. Generate Unique Filename:</strong></p>
                        <ul>
                            <li>Gunakan timestamp + random string</li>
                            <li>Hindari konflik nama file</li>
                            <li>Pertahankan ekstensi file asli</li>
                        </ul>

                        <p><strong>4. Error Handling:</strong></p>
                        <ul>
                            <li>Cleanup file jika database operation gagal</li>
                            <li>Handle error dengan graceful</li>
                            <li>Berikan feedback yang informatif</li>
                        </ul>

                        <p><strong>5. Security Considerations:</strong></p>
                        <ul>
                            <li>Jangan execute file yang diupload</li>
                            <li>Simpan file di luar web root jika mungkin</li>
                            <li>Gunakan static file serving yang aman</li>
                        </ul>

                        <p style="color: #495057; margin-bottom: 0;"><strong>üí° Keuntungan:</strong> Implementasi file upload yang aman dan efisien memastikan aplikasi dapat menangani upload file dengan baik tanpa mengorbankan keamanan dan performa.</p>
                    </div>

                    <h3>üéâ Selamat!</h3>
                    <p>Anda telah berhasil mengimplementasikan modul CRUD Product yang lengkap dengan pattern yang konsisten! Sistem manajemen produk sudah siap untuk digunakan dan hanya bisa diakses oleh admin. Fitur ini dapat diintegrasikan dengan modul Customer Management di bab selanjutnya.</p>

                    <div style="background: #f3e5f5; border-left: 4px solid #9C27B0; padding: 1rem; margin: 2rem 0;">
                        <strong>üåü Tips untuk Pemahaman yang Lebih Baik:</strong> File upload adalah konsep yang cukup kompleks, jadi jangan khawatir jika tidak langsung paham semuanya! Coba praktikkan dengan urutan yang sudah disarankan di atas. Mulai dari yang sederhana (GET data), kemudian perlahan naik ke yang lebih kompleks (CREATE dengan file upload). Setiap kali Anda berhasil menjalankan satu endpoint, Anda akan semakin memahami cara kerja file upload secara keseluruhan. Ingat, belajar programming adalah proses bertahap - yang penting adalah konsistensi dan praktik!
                    </div>

                    <div style="text-align: center; margin: 3rem 0;">
                        <div style="background: #f8f9fa; border: 1px solid #dee2e6; color: #2c3e50; padding: 2rem; border-radius: 5px; display: inline-block;">
                            <h3 style="color: #2c3e50; margin-bottom: 1rem;">üéØ Siap untuk Modul Selanjutnya?</h3>
                            <p style="color: #495057; margin-bottom: 0;">Dengan sistem CRUD Product yang lengkap dan pattern yang konsisten, Anda siap untuk melanjutkan ke modul Customer Management!</p>
                        </div>
                    </div>
                `
            },
            {
                id: 'chapter12',
                title: 'Bab 12: Modul User Management - Role Admin',
                meta: 'Halaman 13 dari 55 ‚Ä¢ Dibaca 18 menit',
                content: `
                    <h2>üë• Bab 12: Modul User Management - Role Admin</h2>
                    <p>Selamat! Sekarang kita akan membuat modul User Management yang hanya bisa diakses oleh admin. Di bab ini, kita akan mengimplementasikan sistem manajemen user dengan role-based access control, termasuk fitur CRUD user, update role, dan manajemen status user.</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">üéØ Apa yang Akan Kita Buat di Bab Ini?</h3>
                        <p style="color: #495057; margin-bottom: 0;">Kita akan membuat sistem User Management yang lengkap dengan Create, Read, Update, Delete operations. Admin dapat mengelola semua user, mengubah role, dan mengatur status user. Semua endpoint hanya bisa diakses oleh admin.</p>
                    </div>

                    <h3>üìã Prasyarat</h3>
                    <p>Sebelum memulai, pastikan Anda sudah menyelesaikan:</p>
                    <ul>
                        <li>‚úÖ Bab 6-8: Modul Authentication (Register, Login, Logout)</li>
                        <li>‚úÖ Bab 9: Review Pembelajaran Authentication</li>
                        <li>‚úÖ Bab 10: Modul CRUD Kategori - Role Admin</li>
                        <li>‚úÖ Bab 11: Modul CRUD Product - Role Admin</li>
                        <li>‚úÖ Middleware authentication sudah berfungsi</li>
                        <li>‚úÖ AdminMiddleware sudah diimplementasikan</li>
                        <li>‚úÖ Tabel users sudah ada di database</li>
                    </ul>

                    <h3>üèóÔ∏è Struktur File yang Akan Dibuat</h3>
                    <p>Kita akan membuat file-file berikut untuk modul User Management:</p>
                    <ul>
                        <li><code>requests/user_management_request.go</code> - Request structs untuk user management</li>
                        <li><code>responses/user_management_response.go</code> - Response structs untuk user management</li>
                        <li><code>repositories/user_management_repository.go</code> - Repository layer untuk user management</li>
                        <li><code>services/user_management_service.go</code> - Service layer untuk user management</li>
                        <li><code>handlers/user_management_handler.go</code> - Handler layer untuk user management</li>
                    </ul>

                    <h3>üìù 1. Membuat Request Structs</h3>
                    <p>Pertama, kita buat file <code>requests/user_management_request.go</code>:</p>
                    
                    <pre><code>package requests

import (
    "errors"
    "strings"

    "github.com/go-playground/validator/v10"
)

// CreateUserRequest represents the request structure for creating user
type CreateUserRequest struct {
    Name     string \`json:"name" validate:"required,min=3,max=255"\`
    Email    string \`json:"email" validate:"required,email"\`
    Password string \`json:"password" validate:"required,min=6"\`
    Role     string \`json:"role" validate:"required,oneof=customer admin"\`
}

// UpdateUserRequest represents the request structure for updating user
type UpdateUserRequest struct {
    Name  string \`json:"name" validate:"omitempty,min=3,max=255"\`
    Email string \`json:"email" validate:"omitempty,email"\`
    Role  string \`json:"role" validate:"omitempty,oneof=customer admin"\`
}

// ChangePasswordRequest represents the request structure for changing password
type ChangePasswordRequest struct {
    CurrentPassword string \`json:"current_password" validate:"required"\`
    NewPassword     string \`json:"new_password" validate:"required,min=6"\`
}

// Validate validates the CreateUserRequest using the validator
func (r *CreateUserRequest) Validate() error {
    validate := validator.New()

    // Validasi struct fields
    if err := validate.Struct(r); err != nil {
        return err
    }

    // Validasi custom: nama tidak boleh kosong setelah trim
    if strings.TrimSpace(r.Name) == "" {
        return errors.New("name cannot be empty")
    }

    // Validasi custom: email tidak boleh kosong setelah trim
    if strings.TrimSpace(r.Email) == "" {
        return errors.New("email cannot be empty")
    }

    // Validasi custom: password tidak boleh kosong setelah trim
    if strings.TrimSpace(r.Password) == "" {
        return errors.New("password cannot be empty")
    }

    return nil
}

// Validate validates the UpdateUserRequest using the validator
func (r *UpdateUserRequest) Validate() error {
    validate := validator.New()

    // Validasi struct fields
    if err := validate.Struct(r); err != nil {
        return err
    }

    // Validasi custom: jika name diisi, tidak boleh kosong setelah trim
    if r.Name != "" && strings.TrimSpace(r.Name) == "" {
        return errors.New("name cannot be empty")
    }

    // Validasi custom: jika email diisi, tidak boleh kosong setelah trim
    if r.Email != "" && strings.TrimSpace(r.Email) == "" {
        return errors.New("email cannot be empty")
    }

    return nil
}

// Validate validates the ChangePasswordRequest using the validator
func (r *ChangePasswordRequest) Validate() error {
    validate := validator.New()

    // Validasi struct fields
    if err := validate.Struct(r); err != nil {
        return err
    }

    // Validasi custom: current password tidak boleh kosong setelah trim
    if strings.TrimSpace(r.CurrentPassword) == "" {
        return errors.New("current password cannot be empty")
    }

    // Validasi custom: new password tidak boleh kosong setelah trim
    if strings.TrimSpace(r.NewPassword) == "" {
        return errors.New("new password cannot be empty")
    }

    return nil
}</code></pre>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; border-radius: 5px; margin: 1.5rem 0;">
                        <h4 style="color: #2c3e50; margin-bottom: 1rem;">üí° Penjelasan Request Structs</h4>
                        <ul>
                            <li><strong>CreateUserRequest:</strong> Struct untuk membuat user baru dengan validasi ketat</li>
                            <li><strong>UpdateUserRequest:</strong> Struct untuk update user dengan field opsional (omitempty)</li>
                            <li><strong>ChangePasswordRequest:</strong> Struct untuk mengubah password user</li>
                        </ul>
                        <p><strong>Validasi yang Digunakan:</strong></p>
                        <ul>
                            <li><strong>required:</strong> Field wajib diisi</li>
                            <li><strong>min=3, max=255:</strong> Panjang string minimal 3, maksimal 255 karakter</li>
                            <li><strong>email:</strong> Format email yang valid</li>
                            <li><strong>oneof=customer admin:</strong> Hanya menerima nilai "customer" atau "admin"</li>
                            <li><strong>omitempty:</strong> Validasi hanya dilakukan jika field tidak kosong</li>
                        </ul>
                        <p><strong>Custom Validation:</strong></p>
                        <ul>
                            <li><strong>TrimSpace:</strong> Menghapus spasi di awal dan akhir string</li>
                            <li><strong>Empty Check:</strong> Memastikan field tidak kosong setelah di-trim</li>
                            <li><strong>Error Messages:</strong> Pesan error yang jelas dan informatif</li>
                        </ul>
                        <p style="color: #495057; margin-bottom: 0;"><strong>üí° Keuntungan:</strong> Request structs ini memastikan data yang masuk ke sistem sudah valid dan aman, mencegah input yang tidak diinginkan dan memudahkan debugging.</p>
                    </div>

                    <h3>üì§ 2. Membuat Response Structs</h3>
                    <p>Buat file <code>responses/user_management_response.go</code>:</p>
                    
                    <pre><code>package responses

import "tokogo/models"

// UserManagementResponse struct untuk response user management
type UserManagementResponse struct {
    ID        uint   \`json:"id"\`
    Name      string \`json:"name"\`
    Email     string \`json:"email"\`
    Role      string \`json:"role"\`
    CreatedAt string \`json:"created_at"\`
    UpdatedAt string \`json:"updated_at"\`
}

// UserListResponse struct untuk response list users
type UserListResponse struct {
    Users []UserManagementResponse \`json:"users"\`
    Total int                      \`json:"total"\`
    Page  int                      \`json:"page"\`
    Limit int                      \`json:"limit"\`
}

// ConvertUserToManagementResponse mengkonversi model User ke UserManagementResponse
func ConvertUserToManagementResponse(user models.User) UserManagementResponse {
    return UserManagementResponse{
        ID:        user.ID,
        Name:      user.Name,
        Email:     user.Email,
        Role:      user.Role,
        CreatedAt: user.CreatedAt.Format("2006-01-02 15:04:05"),
        UpdatedAt: user.UpdatedAt.Format("2006-01-02 15:04:05"),
    }
}

// ConvertUsersToManagementResponse mengkonversi slice model User ke slice UserManagementResponse
func ConvertUsersToManagementResponse(users []models.User) []UserManagementResponse {
    var responses []UserManagementResponse
    for _, user := range users {
        responses = append(responses, ConvertUserToManagementResponse(user))
    }
    return responses
}</code></pre>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; border-radius: 5px; margin: 1.5rem 0;">
                        <h4 style="color: #2c3e50; margin-bottom: 1rem;">üí° Penjelasan Response Structs</h4>
                        <ul>
                            <li><strong>UserManagementResponse:</strong> Struct untuk response data user individual</li>
                            <li><strong>UserListResponse:</strong> Struct untuk response list users dengan pagination</li>
                        </ul>
                        <p><strong>Field yang Dikembalikan:</strong></p>
                        <ul>
                            <li><strong>ID:</strong> Unique identifier user</li>
                            <li><strong>Name:</strong> Nama lengkap user</li>
                            <li><strong>Email:</strong> Email address user</li>
                            <li><strong>Role:</strong> Role user (customer/admin)</li>
                            <li><strong>CreatedAt/UpdatedAt:</strong> Timestamp dengan format yang konsisten</li>
                        </ul>
                        <p><strong>Pagination Fields:</strong></p>
                        <ul>
                            <li><strong>Users:</strong> Array data users</li>
                            <li><strong>Total:</strong> Total jumlah users</li>
                            <li><strong>Page:</strong> Halaman saat ini</li>
                            <li><strong>Limit:</strong> Jumlah data per halaman</li>
                        </ul>
                        <p><strong>Converter Functions:</strong></p>
                        <ul>
                            <li><strong>ConvertUserToManagementResponse:</strong> Konversi single user model ke response</li>
                            <li><strong>ConvertUsersToManagementResponse:</strong> Konversi multiple users ke response array</li>
                            <li><strong>Date Formatting:</strong> Format tanggal konsisten "2006-01-02 15:04:05"</li>
                        </ul>
                        <p style="color: #495057; margin-bottom: 0;"><strong>üí° Keuntungan:</strong> Response structs ini memastikan format data yang konsisten untuk API, memudahkan frontend untuk mengolah data, dan menyembunyikan field sensitif seperti password.</p>
                    </div>

                    <h3>üóÑÔ∏è 3. Membuat Repository Layer</h3>
                    <p>Buat file <code>repositories/user_management_repository.go</code>:</p>
                    
                    <pre><code>package repositories

import (
    "errors"
    "tokogo/config"
    "tokogo/models"

    "gorm.io/gorm"
)

type UserManagementRepository struct {
    db *gorm.DB
}

// NewUserManagementRepository membuat instance baru UserManagementRepository
func NewUserManagementRepository() *UserManagementRepository {
    return &UserManagementRepository{
        db: config.DB,
    }
}

// CreateUser membuat user baru
func (r *UserManagementRepository) CreateUser(user *models.User) error {
    return r.db.Create(user).Error
}

// GetUserByID mengambil user berdasarkan ID
func (r *UserManagementRepository) GetUserByID(id uint) (*models.User, error) {
    var user models.User
    err := r.db.First(&user, id).Error
    if err != nil {
        return nil, err
    }
    return &user, nil
}

// GetUserByEmail mengambil user berdasarkan email
func (r *UserManagementRepository) GetUserByEmail(email string) (*models.User, error) {
    var user models.User
    err := r.db.Where("email = ?", email).First(&user).Error
    if err != nil {
        return nil, err
    }
    return &user, nil
}

// GetAllUsers mengambil semua users dengan pagination
func (r *UserManagementRepository) GetAllUsers(page, limit int) ([]models.User, int64, error) {
    var users []models.User
    var total int64

    // Hitung total
    if err := r.db.Model(&models.User{}).Count(&total).Error; err != nil {
        return nil, 0, err
    }

    // Ambil data dengan pagination
    offset := (page - 1) * limit
    err := r.db.Offset(offset).Limit(limit).Find(&users).Error
    if err != nil {
        return nil, 0, err
    }

    return users, total, nil
}

// UpdateUser mengupdate user
func (r *UserManagementRepository) UpdateUser(user *models.User) error {
    return r.db.Save(user).Error
}

// DeleteUser menghapus user (soft delete)
func (r *UserManagementRepository) DeleteUser(id uint) error {
    return r.db.Delete(&models.User{}, id).Error
}

// UpdateUserRole mengupdate role user
func (r *UserManagementRepository) UpdateUserRole(id uint, role string) error {
    return r.db.Model(&models.User{}).Where("id = ?", id).Update("role", role).Error
}

// GetUsersByRole mengambil users berdasarkan role
func (r *UserManagementRepository) GetUsersByRole(role string, page, limit int) ([]models.User, int64, error) {
    var users []models.User
    var total int64

    // Hitung total
    if err := r.db.Model(&models.User{}).Where("role = ?", role).Count(&total).Error; err != nil {
        return nil, 0, err
    }

    // Ambil data dengan pagination
    offset := (page - 1) * limit
    err := r.db.Where("role = ?", role).Offset(offset).Limit(limit).Find(&users).Error
    if err != nil {
        return nil, 0, err
    }

    return users, total, nil
}</code></pre>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; border-radius: 5px; margin: 1.5rem 0;">
                        <h4 style="color: #2c3e50; margin-bottom: 1rem;">üí° Penjelasan Repository Layer</h4>
                        <ul>
                            <li><strong>UserManagementRepository:</strong> Struct yang mengelola akses database untuk user management</li>
                            <li><strong>Database Connection:</strong> Menggunakan GORM untuk operasi database</li>
                        </ul>
                        <p><strong>CRUD Operations:</strong></p>
                        <ul>
                            <li><strong>CreateUser:</strong> Membuat user baru di database</li>
                            <li><strong>GetUserByID:</strong> Mengambil user berdasarkan ID dengan GORM First()</li>
                            <li><strong>GetUserByEmail:</strong> Mengambil user berdasarkan email dengan Where clause</li>
                            <li><strong>UpdateUser:</strong> Mengupdate user dengan GORM Save()</li>
                            <li><strong>DeleteUser:</strong> Soft delete user dengan GORM Delete()</li>
                        </ul>
                        <p><strong>Advanced Operations:</strong></p>
                        <ul>
                            <li><strong>GetAllUsers:</strong> Mengambil semua users dengan pagination (Count + Offset/Limit)</li>
                            <li><strong>GetUsersByRole:</strong> Filter users berdasarkan role dengan pagination</li>
                            <li><strong>UpdateUserRole:</strong> Update role user secara langsung dengan Model().Update()</li>
                        </ul>
                        <p><strong>Pagination Implementation:</strong></p>
                        <ul>
                            <li><strong>Count:</strong> Menghitung total records untuk pagination</li>
                            <li><strong>Offset:</strong> Menghitung offset berdasarkan page dan limit</li>
                            <li><strong>Limit:</strong> Membatasi jumlah data yang diambil</li>
                        </ul>
                        <p><strong>Error Handling:</strong></p>
                        <ul>
                            <li><strong>GORM Errors:</strong> Mengembalikan error dari GORM untuk handling di layer atas</li>
                            <li><strong>Nil Checks:</strong> Mengembalikan nil jika data tidak ditemukan</li>
                        </ul>
                        <p style="color: #495057; margin-bottom: 0;"><strong>üí° Keuntungan:</strong> Repository layer ini memisahkan logika database dari business logic, memudahkan testing, dan menyediakan interface yang konsisten untuk operasi database.</p>
                    </div>

                    <h3>‚öôÔ∏è 4. Membuat Service Layer</h3>
                    <p>Buat file <code>services/user_management_service.go</code>:</p>
                    
                    <pre><code>package services

import (
    "errors"
    "tokogo/models"
    "tokogo/repositories"
    "tokogo/requests"
    "tokogo/responses"

    "golang.org/x/crypto/bcrypt"
)

type UserManagementService struct {
    userRepo *repositories.UserManagementRepository
}

// NewUserManagementService membuat instance baru UserManagementService
func NewUserManagementService() *UserManagementService {
    return &UserManagementService{
        userRepo: repositories.NewUserManagementRepository(),
    }
}

// CreateUser membuat user baru
func (s *UserManagementService) CreateUser(req requests.CreateUserRequest) (*responses.UserManagementResponse, error) {
    // Cek apakah email sudah terdaftar
    existingUser, _ := s.userRepo.GetUserByEmail(req.Email)
    if existingUser != nil {
        return nil, errors.New("email already registered")
    }

    // Hash password
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
    if err != nil {
        return nil, errors.New("failed to hash password")
    }

    // Buat user baru
    user := &models.User{
        Name:     req.Name,
        Email:    req.Email,
        Password: string(hashedPassword),
        Role:     req.Role,
    }

    // Simpan ke database
    if err := s.userRepo.CreateUser(user); err != nil {
        return nil, errors.New("failed to create user")
    }

    // Return response
    response := responses.ConvertUserToManagementResponse(*user)
    return &response, nil
}

// GetUserByID mengambil user berdasarkan ID
func (s *UserManagementService) GetUserByID(id uint) (*responses.UserManagementResponse, error) {
    user, err := s.userRepo.GetUserByID(id)
    if err != nil {
        return nil, errors.New("user not found")
    }

    response := responses.ConvertUserToManagementResponse(*user)
    return &response, nil
}

// GetAllUsers mengambil semua users dengan pagination
func (s *UserManagementService) GetAllUsers(page, limit int) (*responses.UserListResponse, error) {
    if page < 1 {
        page = 1
    }
    if limit < 1 || limit > 100 {
        limit = 10
    }

    users, total, err := s.userRepo.GetAllUsers(page, limit)
    if err != nil {
        return nil, errors.New("failed to get users")
    }

    return &responses.UserListResponse{
        Users: responses.ConvertUsersToManagementResponse(users),
        Total: int(total),
        Page:  page,
        Limit: limit,
    }, nil
}

// UpdateUser mengupdate user
func (s *UserManagementService) UpdateUser(id uint, req requests.UpdateUserRequest) (*responses.UserManagementResponse, error) {
    // Ambil user yang akan diupdate
    user, err := s.userRepo.GetUserByID(id)
    if err != nil {
        return nil, errors.New("user not found")
    }

    // Update field yang ada
    if req.Name != "" {
        user.Name = req.Name
    }
    if req.Email != "" {
        // Cek apakah email sudah digunakan user lain
        existingUser, _ := s.userRepo.GetUserByEmail(req.Email)
        if existingUser != nil && existingUser.ID != id {
            return nil, errors.New("email already used by another user")
        }
        user.Email = req.Email
    }
    if req.Role != "" {
        user.Role = req.Role
    }

    // Simpan perubahan
    if err := s.userRepo.UpdateUser(user); err != nil {
        return nil, errors.New("failed to update user")
    }

    // Return response
    response := responses.ConvertUserToManagementResponse(*user)
    return &response, nil
}

// DeleteUser menghapus user
func (s *UserManagementService) DeleteUser(id uint) error {
    // Cek apakah user ada
    _, err := s.userRepo.GetUserByID(id)
    if err != nil {
        return errors.New("user not found")
    }

    // Hapus user
    if err := s.userRepo.DeleteUser(id); err != nil {
        return errors.New("failed to delete user")
    }

    return nil
}

// UpdateUserRole mengupdate role user
func (s *UserManagementService) UpdateUserRole(id uint, role string) (*responses.UserManagementResponse, error) {
    // Cek apakah user ada
    user, err := s.userRepo.GetUserByID(id)
    if err != nil {
        return nil, errors.New("user not found")
    }

    // Update role
    if err := s.userRepo.UpdateUserRole(id, role); err != nil {
        return nil, errors.New("failed to update user role")
    }

    // Ambil user yang sudah diupdate
    updatedUser, err := s.userRepo.GetUserByID(id)
    if err != nil {
        return nil, errors.New("failed to get updated user")
    }

    // Return response
    response := responses.ConvertUserToManagementResponse(*updatedUser)
    return &response, nil
}

// GetUsersByRole mengambil users berdasarkan role
func (s *UserManagementService) GetUsersByRole(role string, page, limit int) (*responses.UserListResponse, error) {
    if page < 1 {
        page = 1
    }
    if limit < 1 || limit > 100 {
        limit = 10
    }

    if role != "customer" && role != "admin" {
        return nil, errors.New("invalid role")
    }

    users, total, err := s.userRepo.GetUsersByRole(role, page, limit)
    if err != nil {
        return nil, errors.New("failed to get users by role")
    }

    return &responses.UserListResponse{
        Users: responses.ConvertUsersToManagementResponse(users),
        Total: int(total),
        Page:  page,
        Limit: limit,
    }, nil
}</code></pre>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; border-radius: 5px; margin: 1.5rem 0;">
                        <h4 style="color: #2c3e50; margin-bottom: 1rem;">üí° Penjelasan Service Layer</h4>
                        <ul>
                            <li><strong>UserManagementService:</strong> Struct yang mengelola business logic untuk user management</li>
                            <li><strong>Repository Injection:</strong> Menggunakan dependency injection untuk repository</li>
                        </ul>
                        <p><strong>Business Logic Operations:</strong></p>
                        <ul>
                            <li><strong>CreateUser:</strong> Validasi email unik, hash password, dan buat user baru</li>
                            <li><strong>GetUserByID:</strong> Ambil user dan konversi ke response format</li>
                            <li><strong>GetAllUsers:</strong> Validasi pagination dan ambil semua users</li>
                            <li><strong>UpdateUser:</strong> Validasi email unik dan update user</li>
                            <li><strong>DeleteUser:</strong> Validasi user exists dan hapus user</li>
                        </ul>
                        <p><strong>Security Features:</strong></p>
                        <ul>
                            <li><strong>Password Hashing:</strong> Menggunakan bcrypt untuk hash password</li>
                            <li><strong>Email Uniqueness:</strong> Validasi email tidak boleh duplikat</li>
                            <li><strong>Role Validation:</strong> Validasi role hanya customer atau admin</li>
                        </ul>
                        <p><strong>Data Validation:</strong></p>
                        <ul>
                            <li><strong>Pagination Limits:</strong> Page minimal 1, limit maksimal 100</li>
                            <li><strong>Default Values:</strong> Set default values untuk pagination</li>
                            <li><strong>Existence Checks:</strong> Validasi user exists sebelum operasi</li>
                        </ul>
                        <p><strong>Response Conversion:</strong></p>
                        <ul>
                            <li><strong>Model to Response:</strong> Konversi model ke response format</li>
                            <li><strong>Error Handling:</strong> Custom error messages yang user-friendly</li>
                            <li><strong>Data Transformation:</strong> Transform data sesuai kebutuhan API</li>
                        </ul>
                        <p style="color: #495057; margin-bottom: 0;"><strong>üí° Keuntungan:</strong> Service layer ini memisahkan business logic dari data access, memudahkan testing, dan menyediakan interface yang konsisten untuk handler layer.</p>
                    </div>

                    <h3>üéÆ 5. Membuat Handler Layer</h3>
                    <p>Buat file <code>handlers/user_management_handler.go</code>:</p>
                    
                    <pre><code>package handlers

import (
    "net/http"
    "strconv"
    "tokogo/requests"
    "tokogo/responses"
    "tokogo/services"

    "github.com/gin-gonic/gin"
)

type UserManagementHandler struct {
    userService *services.UserManagementService
}

// NewUserManagementHandler membuat instance baru UserManagementHandler
func NewUserManagementHandler() *UserManagementHandler {
    return &UserManagementHandler{
        userService: services.NewUserManagementService(),
    }
}

// CreateUser handler untuk membuat user baru
func (h *UserManagementHandler) CreateUser(c *gin.Context) {
    var req requests.CreateUserRequest

    // Bind dan validasi request
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Validasi menggunakan method Validate()
    if err := req.Validate(); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Panggil service untuk create user
    userResponse, err := h.userService.CreateUser(req)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "create_user_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusCreated, responses.SuccessResponse{
        Message: "User created successfully",
        Data:    userResponse,
    })
}

// GetUserByID handler untuk mengambil user berdasarkan ID
func (h *UserManagementHandler) GetUserByID(c *gin.Context) {
    // Ambil ID dari parameter
    idStr := c.Param("id")
    id, err := strconv.ParseUint(idStr, 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "invalid_id",
            Message: "Invalid user ID",
        })
        return
    }

    // Panggil service untuk get user
    userResponse, err := h.userService.GetUserByID(uint(id))
    if err != nil {
        c.JSON(http.StatusNotFound, responses.ErrorResponse{
            Error:   "user_not_found",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "User retrieved successfully",
        Data:    userResponse,
    })
}

// GetAllUsers handler untuk mengambil semua users
func (h *UserManagementHandler) GetAllUsers(c *gin.Context) {
    // Ambil parameter pagination
    pageStr := c.DefaultQuery("page", "1")
    limitStr := c.DefaultQuery("limit", "10")

    page, err := strconv.Atoi(pageStr)
    if err != nil {
        page = 1
    }

    limit, err := strconv.Atoi(limitStr)
    if err != nil {
        limit = 10
    }

    // Panggil service untuk get all users
    usersResponse, err := h.userService.GetAllUsers(page, limit)
    if err != nil {
        c.JSON(http.StatusInternalServerError, responses.ErrorResponse{
            Error:   "get_users_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Users retrieved successfully",
        Data:    usersResponse,
    })
}

// UpdateUser handler untuk mengupdate user
func (h *UserManagementHandler) UpdateUser(c *gin.Context) {
    // Ambil ID dari parameter
    idStr := c.Param("id")
    id, err := strconv.ParseUint(idStr, 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "invalid_id",
            Message: "Invalid user ID",
        })
        return
    }

    var req requests.UpdateUserRequest

    // Bind dan validasi request
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Validasi menggunakan method Validate()
    if err := req.Validate(); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Panggil service untuk update user
    userResponse, err := h.userService.UpdateUser(uint(id), req)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "update_user_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "User updated successfully",
        Data:    userResponse,
    })
}

// DeleteUser handler untuk menghapus user
func (h *UserManagementHandler) DeleteUser(c *gin.Context) {
    // Ambil ID dari parameter
    idStr := c.Param("id")
    id, err := strconv.ParseUint(idStr, 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "invalid_id",
            Message: "Invalid user ID",
        })
        return
    }

    // Panggil service untuk delete user
    err = h.userService.DeleteUser(uint(id))
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "delete_user_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "User deleted successfully",
        Data:    nil,
    })
}

// UpdateUserRole handler untuk mengupdate role user
func (h *UserManagementHandler) UpdateUserRole(c *gin.Context) {
    // Ambil ID dari parameter
    idStr := c.Param("id")
    id, err := strconv.ParseUint(idStr, 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "invalid_id",
            Message: "Invalid user ID",
        })
        return
    }

    var req struct {
        Role string \`json:"role" binding:"required,oneof=customer admin"\`
    }

    // Bind dan validasi request
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Panggil service untuk update user role
    userResponse, err := h.userService.UpdateUserRole(uint(id), req.Role)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "update_user_role_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "User role updated successfully",
        Data:    userResponse,
    })
}

// GetUsersByRole handler untuk mengambil users berdasarkan role
func (h *UserManagementHandler) GetUsersByRole(c *gin.Context) {
    // Ambil role dari parameter
    role := c.Param("role")
    if role != "customer" && role != "admin" {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "invalid_role",
            Message: "Role must be either customer or admin",
        })
        return
    }

    // Ambil parameter pagination
    pageStr := c.DefaultQuery("page", "1")
    limitStr := c.DefaultQuery("limit", "10")

    page, err := strconv.Atoi(pageStr)
    if err != nil {
        page = 1
    }

    limit, err := strconv.Atoi(limitStr)
    if err != nil {
        limit = 10
    }

    // Panggil service untuk get users by role
    usersResponse, err := h.userService.GetUsersByRole(role, page, limit)
    if err != nil {
        c.JSON(http.StatusInternalServerError, responses.ErrorResponse{
            Error:   "get_users_by_role_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Users retrieved successfully",
        Data:    usersResponse,
    })
}</code></pre>

                    <h3>üõ£Ô∏è 6. Menambahkan Routes di main.go</h3>
                    <p>Tambahkan routes untuk user management di <code>main.go</code>:</p>
                    
                    <pre><code>package main

import (
	"log"
	"tokogo/config"
	"tokogo/handlers"
	"tokogo/middlewares"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
	"github.com/joho/godotenv"
)

func main() {
	// Load environment variables
	if err := godotenv.Load(); err != nil {
		log.Println("No .env file found, using system environment variables")
	}

	// Initialize database
	config.InitDB()

	// Setup Gin router
	r := gin.Default()

	// CORS middleware
	r.Use(cors.New(cors.Config{
		AllowOrigins:     []string{"*"},
		AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowHeaders:     []string{"*"},
		ExposeHeaders:    []string{"Content-Length"},
		AllowCredentials: true,
	}))

	// Static file serving for uploaded images
	r.Static("/uploads", "./uploads")

	// Initialize handlers
	authHandler := handlers.NewAuthHandler()
	categoryHandler := handlers.NewCategoryHandler()
	productHandler := handlers.NewProductHandler()
	userManagementHandler := handlers.NewUserManagementHandler()

	// Public routes (tidak perlu authentication)
	api := r.Group("/api/v1")
	{
		// Auth routes
		auth := api.Group("/auth")
		{
			auth.POST("/register", authHandler.Register)
			auth.POST("/login", authHandler.Login)
		}
	}

	// Protected routes (perlu authentication)
	protected := r.Group("/api/v1")
	protected.Use(middlewares.AuthMiddleware())
	{
		// Auth protected routes
		auth := protected.Group("/auth")
		{
			auth.POST("/logout", authHandler.Logout)
			auth.GET("/profile", authHandler.GetProfile)
		}

		// Admin routes (perlu admin role)
		admin := protected.Group("/admin")
		admin.Use(middlewares.AdminMiddleware())
		{
			admin.GET("/dashboard", func(c *gin.Context) {
				c.JSON(200, gin.H{
					"message": "Welcome to admin dashboard",
					"user_id": c.GetUint("user_id"),
				})
			})

			categories := admin.Group("/categories")
			{
				categories.POST("", categoryHandler.CreateCategory)
				categories.GET("", categoryHandler.GetAllCategories)
				categories.GET("/:id", categoryHandler.GetCategoryByID)
				categories.PUT("/:id", categoryHandler.UpdateCategory)
				categories.DELETE("/:id", categoryHandler.DeleteCategory)
			}

			products := admin.Group("/products")
			{
				products.POST("", productHandler.CreateProduct)
				products.GET("", productHandler.GetAllProducts)
				products.GET("/:id", productHandler.GetProductByID)
				products.PUT("/:id", productHandler.UpdateProduct)
				products.DELETE("/:id", productHandler.DeleteProduct)
				products.GET("/categories/:category_id", productHandler.GetProductsByCategory)
			}

			userManagement := admin.Group("/user-management")
			{
				userManagement.POST("", userManagementHandler.CreateUser)
				userManagement.GET("", userManagementHandler.GetAllUsers)
				userManagement.GET("/:id", userManagementHandler.GetUserByID)
				userManagement.PUT("/:id", userManagementHandler.UpdateUser)
				userManagement.DELETE("/:id", userManagementHandler.DeleteUser)
			}
		}
	}

	// Start server
	port := config.GetEnv("SERVER_PORT", "8080")
	log.Printf("Server starting on port %s", port)
	r.Run(":" + port)
}
</code></pre>

                    <h3>üß™ 7. Testing dengan Postman</h3>
                    <p>Sekarang kita akan test semua endpoint user management menggunakan Postman:</p>

                    <h4>üìã Endpoint yang Tersedia:</h4>
                    <ul>
                        <li><strong>POST</strong> <code>/admin/users</code> - Create user baru</li>
                        <li><strong>GET</strong> <code>/admin/users</code> - Get semua users (dengan pagination)</li>
                        <li><strong>GET</strong> <code>/admin/users/:id</code> - Get user berdasarkan ID</li>
                        <li><strong>PUT</strong> <code>/admin/users/:id</code> - Update user</li>
                        <li><strong>DELETE</strong> <code>/admin/users/:id</code> - Delete user</li>
                        <li><strong>PUT</strong> <code>/admin/users/:id/role</code> - Update role user</li>
                        <li><strong>GET</strong> <code>/admin/users/role/:role</code> - Get users berdasarkan role</li>
                    </ul>

                    <h4>üîê Headers yang Diperlukan:</h4>
                    <p>Semua endpoint memerlukan header:</p>
                    <ul>
                        <li><code>Authorization: Bearer YOUR_JWT_TOKEN</code></li>
                        <li><code>Content-Type: application/json</code></li>
                    </ul>

                    <h4>üìù Contoh Request Body:</h4>
                    
                    <h5>Create User:</h5>
                    <pre><code>{
    "name": "John Doe",
    "email": "john@example.com",
    "password": "password123",
    "role": "customer"
}</code></pre>

                    <h5>Update User:</h5>
                    <pre><code>{
    "name": "John Updated",
    "email": "john.updated@example.com",
    "role": "admin"
}</code></pre>

                    <h5>Update User Role:</h5>
                    <pre><code>{
    "role": "admin"
}</code></pre>

                    <h4>üìä Contoh Response:</h4>
                    
                    <h5>Success Response:</h5>
                    <pre><code>{
    "message": "User created successfully",
    "data": {
        "id": 1,
        "name": "John Doe",
        "email": "john@example.com",
        "role": "customer",
        "created_at": "2024-01-01 10:00:00",
        "updated_at": "2024-01-01 10:00:00"
    }
}</code></pre>

                    <h5>List Users Response:</h5>
                    <pre><code>{
    "message": "Users retrieved successfully",
    "data": {
        "users": [
            {
                "id": 1,
                "name": "John Doe",
                "email": "john@example.com",
                "role": "customer",
                "created_at": "2024-01-01 10:00:00",
                "updated_at": "2024-01-01 10:00:00"
            }
        ],
        "total": 1,
        "page": 1,
        "limit": 10
    }
}</code></pre>

                    <h3>üéØ Fitur-fitur User Management:</h3>
                    <ul>
                        <li>‚úÖ <strong>Create User</strong> - Admin dapat membuat user baru dengan role customer atau admin</li>
                        <li>‚úÖ <strong>Read Users</strong> - Admin dapat melihat semua users dengan pagination</li>
                        <li>‚úÖ <strong>Update User</strong> - Admin dapat mengupdate informasi user (name, email, role)</li>
                        <li>‚úÖ <strong>Delete User</strong> - Admin dapat menghapus user (soft delete)</li>
                        <li>‚úÖ <strong>Role Management</strong> - Admin dapat mengubah role user (customer ‚Üî admin)</li>
                        <li>‚úÖ <strong>Filter by Role</strong> - Admin dapat melihat users berdasarkan role</li>
                        <li>‚úÖ <strong>Pagination</strong> - Semua list endpoint mendukung pagination</li>
                        <li>‚úÖ <strong>Validation</strong> - Semua input divalidasi dengan baik</li>
                        <li>‚úÖ <strong>Error Handling</strong> - Error handling yang komprehensif</li>
                    </ul>

                    <h3>üîí Security Features:</h3>
                    <ul>
                        <li>‚úÖ <strong>Admin Only Access</strong> - Semua endpoint hanya bisa diakses admin</li>
                        <li>‚úÖ <strong>JWT Authentication</strong> - Memerlukan token yang valid</li>
                        <li>‚úÖ <strong>Password Hashing</strong> - Password di-hash menggunakan bcrypt</li>
                        <li>‚úÖ <strong>Email Uniqueness</strong> - Email harus unik di sistem</li>
                        <li>‚úÖ <strong>Input Validation</strong> - Semua input divalidasi</li>
                    </ul>

                    <div style="background: #d4edda; border: 1px solid #c3e6cb; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #155724; margin-bottom: 1rem;">üéâ Selamat! Modul User Management Selesai!</h3>
                        <p style="color: #155724; margin-bottom: 0;">Dengan sistem User Management yang lengkap dan pattern yang konsisten, Anda siap untuk melanjutkan ke modul berikutnya!</p>
                    </div>
                `
            },
            {
                id: 'chapter13',
                title: 'Bab 13: Modul Transaction Management - Role Admin',
                meta: 'Halaman 14 dari 55 ‚Ä¢ Dibaca 20 menit',
                content: `
                    <h2>üí≥ Bab 13: Modul Transaction Management - Role Admin</h2>
                    <p>Selamat! Sekarang kita akan membuat modul Transaction Management yang hanya bisa diakses oleh admin. Di bab ini, kita akan mengimplementasikan sistem manajemen transaksi dengan fitur melihat daftar transaksi, detail transaksi, dan mengelola status transaksi.</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">üéØ Apa yang Akan Kita Buat di Bab Ini?</h3>
                        <p style="color: #495057; margin-bottom: 0;">Kita akan membuat sistem Transaction Management yang lengkap dengan fitur melihat daftar transaksi, detail transaksi, dan mengelola status transaksi. Admin dapat melihat semua transaksi, detail produk dalam transaksi, dan mengupdate status transaksi. Semua endpoint hanya bisa diakses oleh admin.</p>
                    </div>

                    <h3>üìã Prasyarat</h3>
                    <p>Sebelum memulai, pastikan Anda sudah menyelesaikan:</p>
                    <ul>
                        <li>‚úÖ Bab 6-8: Modul Authentication (Register, Login, Logout)</li>
                        <li>‚úÖ Bab 9: Review Pembelajaran Authentication</li>
                        <li>‚úÖ Bab 10: Modul CRUD Kategori - Role Admin</li>
                        <li>‚úÖ Bab 11: Modul CRUD Product - Role Admin</li>
                        <li>‚úÖ Bab 12: Modul User Management - Role Admin</li>
                        <li>‚úÖ Middleware authentication sudah berfungsi</li>
                        <li>‚úÖ AdminMiddleware sudah diimplementasikan</li>
                        <li>‚úÖ Tabel users, products, dan categories sudah ada di database</li>
                    </ul>

                    <h3>üóÑÔ∏è Database Schema</h3>
                    <p>Sebelum memulai, kita perlu membuat tabel untuk transaksi. Berikut adalah schema database yang akan kita gunakan:</p>

                    <h4>üìä Tabel Transactions</h4>
                    <pre><code>CREATE TABLE transactions (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    status ENUM('pending', 'paid', 'failed', 'expired') NOT NULL DEFAULT 'pending',
    total_amount DECIMAL(15,2) NOT NULL,
    payment_url VARCHAR(500),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);</code></pre>

                    <h4>üìä Tabel TransactionDetails</h4>
                    <pre><code>CREATE TABLE transaction_details (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    transaction_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,
    quantity INT NOT NULL,
    price DECIMAL(15,2) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (transaction_id) REFERENCES transactions(id) ON DELETE CASCADE,
    FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE
);</code></pre>

                    <h3>üèóÔ∏è Struktur File yang Akan Dibuat</h3>
                    <p>Kita akan membuat file-file berikut untuk modul Transaction Management:</p>
                    <ul>
                        <li><code>models/transaction.go</code> - Model Transaction dan TransactionDetail</li>
                        <li><code>requests/transaction_request.go</code> - Request structs untuk transaction management</li>
                        <li><code>responses/transaction_response.go</code> - Response structs untuk transaction management</li>
                        <li><code>repositories/transaction_repository.go</code> - Repository layer untuk transaction management</li>
                        <li><code>services/transaction_service.go</code> - Service layer untuk transaction management</li>
                        <li><code>handlers/transaction_handler.go</code> - Handler layer untuk transaction management</li>
                    </ul>

                    <h3>üìù 1. Membuat Model Transaction</h3>
                    <p>Pertama, kita buat model Transaction di file <code>models/transaction.go</code>:</p>
                    
                    <pre><code>package models

import "time"

// Transaction represents the transaction model
type Transaction struct {
    ID                uint                  \`json:"id" gorm:"primaryKey"\`
    UserID            uint                  \`json:"user_id" gorm:"not null"\`
    User              User                  \`json:"user" gorm:"foreignKey:UserID"\`
    Status            string                \`json:"status" gorm:"type:enum('pending','paid','failed','expired');default:'pending'"\`
    TotalAmount       float64               \`json:"total_amount" gorm:"type:decimal(15,2);not null"\`
    PaymentURL        string                \`json:"payment_url" gorm:"type:varchar(500)"\`
    TransactionDetails []TransactionDetail  \`json:"transaction_details" gorm:"foreignKey:TransactionID"\`
    CreatedAt         time.Time             \`json:"created_at"\`
    UpdatedAt         time.Time             \`json:"updated_at"\`
}

// TransactionDetail represents the transaction detail model
type TransactionDetail struct {
    ID            uint      \`json:"id" gorm:"primaryKey"\`
    TransactionID uint      \`json:"transaction_id" gorm:"not null"\`
    Transaction   Transaction \`json:"transaction" gorm:"foreignKey:TransactionID"\`
    ProductID     uint      \`json:"product_id" gorm:"not null"\`
    Product       Product   \`json:"product" gorm:"foreignKey:ProductID"\`
    Quantity      int       \`json:"quantity" gorm:"not null"\`
    Price         float64   \`json:"price" gorm:"type:decimal(15,2);not null"\`
    CreatedAt     time.Time \`json:"created_at"\`
    UpdatedAt     time.Time \`json:"updated_at"\`
}

// TableName returns the table name for Transaction
func (Transaction) TableName() string {
    return "transactions"
}

// TableName returns the table name for TransactionDetail
func (TransactionDetail) TableName() string {
    return "transaction_details"
}</code></pre>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; border-radius: 5px; margin: 1.5rem 0;">
                        <h4 style="color: #2c3e50; margin-bottom: 1rem;">üí° Penjelasan Model Transaction</h4>
                        <ul>
                            <li><strong>Transaction Model:</strong> Menyimpan informasi transaksi utama</li>
                            <li><strong>User Relationship:</strong> Relasi dengan User melalui UserID</li>
                            <li><strong>Status Enum:</strong> Status transaksi dengan nilai yang terbatas</li>
                            <li><strong>TotalAmount:</strong> Total harga transaksi dengan presisi decimal</li>
                            <li><strong>PaymentURL:</strong> URL untuk pembayaran (opsional)</li>
                            <li><strong>TransactionDetails:</strong> Relasi one-to-many dengan detail transaksi</li>
                        </ul>
                        <ul>
                            <li><strong>TransactionDetail Model:</strong> Menyimpan detail produk dalam transaksi</li>
                            <li><strong>Product Relationship:</strong> Relasi dengan Product melalui ProductID</li>
                            <li><strong>Quantity:</strong> Jumlah produk yang dibeli</li>
                            <li><strong>Price:</strong> Harga per unit saat transaksi</li>
                            <li><strong>TableName Methods:</strong> Menentukan nama tabel secara eksplisit</li>
                        </ul>
                        <p style="color: #495057; margin-bottom: 0;"><strong>üí° Keuntungan:</strong> Model ini mendefinisikan struktur data yang konsisten dengan database dan menyediakan relasi yang jelas dengan User dan Product.</p>
                    </div>

                    <h3>üìù 2. Membuat Request Structs</h3>
                    <p>Buat file <code>requests/transaction_request.go</code>:</p>
                    
                    <pre><code>package requests

import (
    "errors"
    "strings"

    "github.com/go-playground/validator/v10"
)

// UpdateTransactionStatusRequest represents the request structure for updating transaction status
type UpdateTransactionStatusRequest struct {
    Status string \`json:"status" validate:"required,oneof=pending paid failed expired"\`
}

// GetTransactionsRequest represents the request structure for getting transactions with filters
type GetTransactionsRequest struct {
    Status string \`json:"status" validate:"omitempty,oneof=pending paid failed expired"\`
    Page   int    \`json:"page" validate:"omitempty,min=1"\`
    Limit  int    \`json:"limit" validate:"omitempty,min=1,max=100"\`
}

// Validate validates the UpdateTransactionStatusRequest using the validator
func (r *UpdateTransactionStatusRequest) Validate() error {
    validate := validator.New()

    // Validasi struct fields
    if err := validate.Struct(r); err != nil {
        return err
    }

    // Validasi custom: status tidak boleh kosong setelah trim
    if strings.TrimSpace(r.Status) == "" {
        return errors.New("status cannot be empty")
    }

    return nil
}

// Validate validates the GetTransactionsRequest using the validator
func (r *GetTransactionsRequest) Validate() error {
    validate := validator.New()

    // Validasi struct fields
    if err := validate.Struct(r); err != nil {
        return err
    }

    // Set default values
    if r.Page <= 0 {
        r.Page = 1
    }
    if r.Limit <= 0 {
        r.Limit = 10
    }

    return nil
}</code></pre>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; border-radius: 5px; margin: 1.5rem 0;">
                        <h4 style="color: #2c3e50; margin-bottom: 1rem;">üí° Penjelasan Request Structs</h4>
                        <ul>
                            <li><strong>UpdateTransactionStatusRequest:</strong> Struct untuk mengupdate status transaksi</li>
                            <li><strong>GetTransactionsRequest:</strong> Struct untuk mengambil transaksi dengan filter dan pagination</li>
                        </ul>
                        <p><strong>Validasi yang Digunakan:</strong></p>
                        <ul>
                            <li><strong>required:</strong> Field wajib diisi untuk status update</li>
                            <li><strong>oneof=pending paid failed expired:</strong> Status hanya menerima nilai yang valid</li>
                            <li><strong>omitempty:</strong> Validasi hanya dilakukan jika field tidak kosong</li>
                            <li><strong>min=1, max=100:</strong> Pagination limits untuk mencegah abuse</li>
                        </ul>
                        <p><strong>Custom Validation:</strong></p>
                        <ul>
                            <li><strong>Status Validation:</strong> Memastikan status tidak kosong setelah trim</li>
                            <li><strong>Default Values:</strong> Set default values untuk pagination (page=1, limit=10)</li>
                            <li><strong>Range Validation:</strong> Validasi page minimal 1, limit maksimal 100</li>
                        </ul>
                        <p><strong>Business Logic:</strong></p>
                        <ul>
                            <li><strong>Status Management:</strong> Mengelola status transaksi (pending ‚Üí paid/failed/expired)</li>
                            <li><strong>Filtering:</strong> Memungkinkan filter berdasarkan status transaksi</li>
                            <li><strong>Pagination:</strong> Mendukung pagination untuk performa yang baik</li>
                        </ul>
                        <p style="color: #495057; margin-bottom: 0;"><strong>üí° Keuntungan:</strong> Request structs ini memastikan data yang masuk valid, mencegah status yang tidak valid, dan menyediakan pagination yang aman untuk performa sistem.</p>
                    </div>

                    <h3>üì§ 3. Membuat Response Structs</h3>
                    <p>Buat file <code>responses/transaction_response.go</code>:</p>
                    
                    <pre><code>package responses

import "time"

// TransactionResponse represents the response structure for transaction
type TransactionResponse struct {
    ID          int64                     \`json:"id"\`
    UserID      int64                     \`json:"user_id"\`
    UserName    string                    \`json:"user_name"\`
    UserEmail   string                    \`json:"user_email"\`
    Status      string                    \`json:"status"\`
    TotalAmount float64                   \`json:"total_amount"\`
    PaymentURL  string                    \`json:"payment_url,omitempty"\`
    CreatedAt   time.Time                 \`json:"created_at"\`
    UpdatedAt   time.Time                 \`json:"updated_at"\`
    Details     []TransactionDetailResponse \`json:"details,omitempty"\`
}

// TransactionDetailResponse represents the response structure for transaction detail
type TransactionDetailResponse struct {
    ID            int64   \`json:"id"\`
    TransactionID int64   \`json:"transaction_id"\`
    ProductID     int64   \`json:"product_id"\`
    ProductName   string  \`json:"product_name"\`
    ProductImage  string  \`json:"product_image,omitempty"\`
    Quantity      int     \`json:"quantity"\`
    Price         float64 \`json:"price"\`
    Subtotal      float64 \`json:"subtotal"\`
}

// TransactionListResponse represents the response structure for transaction list
type TransactionListResponse struct {
    Transactions []TransactionResponse \`json:"transactions"\`
    Total        int64                 \`json:"total"\`
    Page         int                   \`json:"page"\`
    Limit        int                   \`json:"limit"\`
    TotalPages   int                   \`json:"total_pages"\`
}

// TransactionStatusResponse represents the response structure for transaction status update
type TransactionStatusResponse struct {
    Message string              \`json:"message"\`
    Data    TransactionResponse \`json:"data"\`
}</code></pre>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; border-radius: 5px; margin: 1.5rem 0;">
                        <h4 style="color: #2c3e50; margin-bottom: 1rem;">üí° Penjelasan Response Structs</h4>
                        <ul>
                            <li><strong>TransactionResponse:</strong> Struct untuk response data transaksi individual</li>
                            <li><strong>TransactionDetailResponse:</strong> Struct untuk response detail produk dalam transaksi</li>
                            <li><strong>TransactionListResponse:</strong> Struct untuk response list transaksi dengan pagination</li>
                            <li><strong>TransactionStatusResponse:</strong> Struct untuk response update status transaksi</li>
                        </ul>
                        <p><strong>Transaction Response Fields:</strong></p>
                        <ul>
                            <li><strong>ID:</strong> Unique identifier transaksi</li>
                            <li><strong>UserID:</strong> ID user yang melakukan transaksi</li>
                            <li><strong>UserName/UserEmail:</strong> Informasi user untuk kemudahan admin</li>
                            <li><strong>Status:</strong> Status transaksi (pending/paid/failed/expired)</li>
                            <li><strong>TotalAmount:</strong> Total harga transaksi</li>
                            <li><strong>PaymentURL:</strong> URL pembayaran (opsional, omitempty)</li>
                            <li><strong>Details:</strong> Array detail produk dalam transaksi</li>
                        </ul>
                        <p><strong>Transaction Detail Fields:</strong></p>
                        <ul>
                            <li><strong>ProductID/ProductName:</strong> Informasi produk yang dibeli</li>
                            <li><strong>ProductImage:</strong> Gambar produk (opsional)</li>
                            <li><strong>Quantity:</strong> Jumlah produk yang dibeli</li>
                            <li><strong>Price:</strong> Harga per unit saat transaksi</li>
                            <li><strong>Subtotal:</strong> Total harga (quantity √ó price)</li>
                        </ul>
                        <p><strong>Pagination Fields:</strong></p>
                        <ul>
                            <li><strong>Transactions:</strong> Array data transaksi</li>
                            <li><strong>Total:</strong> Total jumlah transaksi</li>
                            <li><strong>Page/Limit:</strong> Informasi pagination</li>
                            <li><strong>TotalPages:</strong> Total halaman untuk navigasi</li>
                        </ul>
                        <p style="color: #495057; margin-bottom: 0;"><strong>üí° Keuntungan:</strong> Response structs ini menyediakan data yang lengkap untuk admin, termasuk informasi user dan detail produk, memudahkan monitoring dan manajemen transaksi.</p>
                    </div>

                    <h3>üóÑÔ∏è 4. Membuat Repository Layer</h3>
                    <p>Buat file <code>repositories/transaction_repository.go</code>:</p>
                    
                    <pre><code>package repositories

import (
    "tokogo/config"
    "tokogo/models"

    "gorm.io/gorm"
)

type TransactionRepository struct {
    db *gorm.DB
}

// NewTransactionRepository membuat instance baru TransactionRepository
func NewTransactionRepository() *TransactionRepository {
    return &TransactionRepository{
        db: config.DB,
    }
}

// GetAllTransactions mengambil semua transaksi dengan pagination dan filter
func (r *TransactionRepository) GetAllTransactions(page, limit int, status string) ([]models.Transaction, int64, error) {
    var transactions []models.Transaction
    var total int64

    // Build query dengan GORM
    query := r.db.Preload("User").Model(&models.Transaction{})
    
    // Apply filter status jika ada
    if status != "" {
        query = query.Where("status = ?", status)
    }

    // Count total records
    if err := query.Count(&total).Error; err != nil {
        return nil, 0, err
    }

    // Apply pagination dan ambil data
    offset := (page - 1) * limit
    if err := query.Offset(offset).Limit(limit).Order("created_at DESC").Find(&transactions).Error; err != nil {
        return nil, 0, err
    }

    return transactions, total, nil
}

// GetTransactionByID mengambil transaksi berdasarkan ID dengan detail
func (r *TransactionRepository) GetTransactionByID(id uint) (*models.Transaction, error) {
    var transaction models.Transaction

    // Get transaction dengan preload User dan TransactionDetails
    err := r.db.Preload("User").Preload("TransactionDetails.Product").First(&transaction, id).Error
    if err != nil {
        return nil, err
    }

    return &transaction, nil
}

// UpdateTransactionStatus mengupdate status transaksi
func (r *TransactionRepository) UpdateTransactionStatus(id uint, status string) error {
    err := r.db.Model(&models.Transaction{}).Where("id = ?", id).Update("status", status).Error
    if err != nil {
        return err
    }
    return nil
}

</code></pre>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; border-radius: 5px; margin: 1.5rem 0;">
                        <h4 style="color: #2c3e50; margin-bottom: 1rem;">üí° Penjelasan Repository Layer</h4>
                        <ul>
                            <li><strong>TransactionRepository:</strong> Struct yang mengelola akses database untuk transaction management</li>
                            <li><strong>Database Connection:</strong> Menggunakan GORM untuk operasi database</li>
                        </ul>
                        <p><strong>Query Operations:</strong></p>
                        <ul>
                            <li><strong>GetAllTransactions:</strong> Mengambil semua transaksi dengan pagination dan filter status</li>
                            <li><strong>GetTransactionByID:</strong> Mengambil transaksi berdasarkan ID dengan preload relasi</li>
                            <li><strong>UpdateTransactionStatus:</strong> Mengupdate status transaksi secara langsung</li>
                        </ul>
                        <p><strong>Advanced Query Features:</strong></p>
                        <ul>
                            <li><strong>Preload:</strong> Menggunakan GORM Preload untuk eager loading relasi (User, TransactionDetails, Product)</li>
                            <li><strong>Dynamic Filtering:</strong> Filter berdasarkan status dengan conditional WHERE clause</li>
                            <li><strong>Pagination:</strong> Implementasi pagination dengan Count, Offset, dan Limit</li>
                            <li><strong>Ordering:</strong> Mengurutkan data berdasarkan created_at DESC (terbaru dulu)</li>
                        </ul>
                        <p><strong>Performance Optimizations:</strong></p>
                        <ul>
                            <li><strong>Eager Loading:</strong> Preload relasi untuk menghindari N+1 query problem</li>
                            <li><strong>Selective Updates:</strong> Update hanya field yang diperlukan (status)</li>
                            <li><strong>Efficient Counting:</strong> Count total records untuk pagination</li>
                        </ul>
                        <p><strong>Error Handling:</strong></p>
                        <ul>
                            <li><strong>GORM Errors:</strong> Mengembalikan error dari GORM untuk handling di layer atas</li>
                            <li><strong>Nil Checks:</strong> Mengembalikan nil jika data tidak ditemukan</li>
                        </ul>
                        <p style="color: #495057; margin-bottom: 0;"><strong>üí° Keuntungan:</strong> Repository layer ini menyediakan query yang efisien dengan preload relasi, pagination yang optimal, dan filtering yang fleksibel untuk manajemen transaksi yang kompleks.</p>
                    </div>

                    <h3>‚öôÔ∏è 5. Membuat Service Layer</h3>
                    <p>Buat file <code>services/transaction_service.go</code>:</p>
                    
                    <pre><code>package services

import (
    "tokogo/config"
    "tokogo/repositories"
    "tokogo/requests"
    "tokogo/responses"
)

type TransactionService struct {
    transactionRepo *repositories.TransactionRepository
}

// NewTransactionService membuat instance baru TransactionService
func NewTransactionService() *TransactionService {
    return &TransactionService{
        transactionRepo: repositories.NewTransactionRepository(config.DB),
    }
}

// GetAllTransactions mengambil semua transaksi dengan pagination dan filter
func (s *TransactionService) GetAllTransactions(page, limit int, status string) (*responses.TransactionListResponse, error) {
    // Set default values
    if page < 1 {
        page = 1
    }
    if limit < 1 {
        limit = 10
    }

    // Get transactions from repository
    transactions, total, err := s.transactionRepo.GetAllTransactions(page, limit, status)
    if err != nil {
        return nil, err
    }

    // Convert to response format
    var transactionResponses []responses.TransactionResponse
    for _, transaction := range transactions {
        transactionResponse := responses.TransactionResponse{
            ID:          int64(transaction.ID),
            UserID:      int64(transaction.UserID),
            UserName:    transaction.User.Name,
            UserEmail:   transaction.User.Email,
            Status:      transaction.Status,
            TotalAmount: transaction.TotalAmount,
            PaymentURL:  transaction.PaymentURL,
            CreatedAt:   transaction.CreatedAt,
            UpdatedAt:   transaction.UpdatedAt,
        }
        transactionResponses = append(transactionResponses, transactionResponse)
    }

    return &responses.TransactionListResponse{
        Transactions: transactionResponses,
        Total:        int64(total),
        Page:         page,
        Limit:        limit,
    }, nil
}

// GetTransactionByID mengambil transaksi berdasarkan ID dengan detail
func (s *TransactionService) GetTransactionByID(id uint) (*responses.TransactionResponse, error) {
    // Get transaction from repository
    transaction, err := s.transactionRepo.GetTransactionByID(id)
    if err != nil {
        return nil, err
    }

    // Convert details to response format
    var detailResponses []responses.TransactionDetailResponse
    for _, detail := range transaction.TransactionDetails {
        detailResponse := responses.TransactionDetailResponse{
            ID:            int64(detail.ID),
            TransactionID: int64(detail.TransactionID),
            ProductID:     int64(detail.ProductID),
            ProductName:   detail.Product.Name,
            ProductImage:  detail.Product.ImageURL,
            Quantity:      detail.Quantity,
            Price:         detail.Price,
            Subtotal:      float64(detail.Quantity) * detail.Price,
        }
        detailResponses = append(detailResponses, detailResponse)
    }

    // Convert to response format
    transactionResponse := &responses.TransactionResponse{
        ID:          int64(transaction.ID),
        UserID:      int64(transaction.UserID),
        UserName:    transaction.User.Name,
        UserEmail:   transaction.User.Email,
        Status:      transaction.Status,
        TotalAmount: transaction.TotalAmount,
        PaymentURL:  transaction.PaymentURL,
        CreatedAt:   transaction.CreatedAt,
        UpdatedAt:   transaction.UpdatedAt,
        Details:     detailResponses,
    }

    return transactionResponse, nil
}

// UpdateTransactionStatus mengupdate status transaksi
func (s *TransactionService) UpdateTransactionStatus(id uint, req requests.UpdateTransactionStatusRequest) (*responses.TransactionResponse, error) {
    // Validasi request
    if err := req.Validate(); err != nil {
        return nil, err
    }

    // Cek apakah transaction ada
    _, err := s.transactionRepo.GetTransactionByID(id)
    if err != nil {
        return nil, err
    }

    // Update transaction status
    err = s.transactionRepo.UpdateTransactionStatus(id, req.Status)
    if err != nil {
        return nil, err
    }

    // Get updated transaction
    transactionResponse, err := s.GetTransactionByID(id)
    if err != nil {
        return nil, err
    }

    return transactionResponse, nil
}

</code></pre>

                    <h3>üéÆ 6. Membuat Handler Layer</h3>
                    <p>Buat file <code>handlers/transaction_handler.go</code>:</p>
                    
                    <pre><code>package handlers

import (
    "net/http"
    "strconv"
    "tokogo/requests"
    "tokogo/responses"
    "tokogo/services"

    "github.com/gin-gonic/gin"
)

type TransactionHandler struct {
    transactionService *services.TransactionService
}

// NewTransactionHandler membuat instance baru TransactionHandler
func NewTransactionHandler() *TransactionHandler {
    return &TransactionHandler{
        transactionService: services.NewTransactionService(),
    }
}

// GetAllTransactions handler untuk mengambil semua transaksi
func (h *TransactionHandler) GetAllTransactions(c *gin.Context) {
    // Parse query parameters
    status := c.Query("status")
    pageStr := c.DefaultQuery("page", "1")
    limitStr := c.DefaultQuery("limit", "10")

    page, err := strconv.Atoi(pageStr)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: "Invalid page parameter",
        })
        return
    }

    limit, err := strconv.Atoi(limitStr)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: "Invalid limit parameter",
        })
        return
    }

    // Get transactions
    result, err := h.transactionService.GetAllTransactions(page, limit, status)
    if err != nil {
        c.JSON(http.StatusInternalServerError, responses.ErrorResponse{
            Error:   "get_transactions_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Transactions retrieved successfully",
        Data:    result,
    })
}

// GetTransactionByID handler untuk mengambil transaksi berdasarkan ID
func (h *TransactionHandler) GetTransactionByID(c *gin.Context) {
    // Parse transaction ID
    idStr := c.Param("id")
    id, err := strconv.ParseUint(idStr, 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: "Invalid transaction ID",
        })
        return
    }

    // Get transaction
    transaction, err := h.transactionService.GetTransactionByID(uint(id))
    if err != nil {
        c.JSON(http.StatusNotFound, responses.ErrorResponse{
            Error:   "transaction_not_found",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Transaction retrieved successfully",
        Data:    transaction,
    })
}

// UpdateTransactionStatus handler untuk mengupdate status transaksi
func (h *TransactionHandler) UpdateTransactionStatus(c *gin.Context) {
    // Parse transaction ID
    idStr := c.Param("id")
    id, err := strconv.ParseUint(idStr, 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: "Invalid transaction ID",
        })
        return
    }

    // Parse request body
    var req requests.UpdateTransactionStatusRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Update transaction status
    transaction, err := h.transactionService.UpdateTransactionStatus(uint(id), req)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "update_transaction_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Transaction status updated successfully",
        Data:    transaction,
    })
}

</code></pre>

                    <h3>üîó 7. Menambahkan Routes di main.go</h3>
                    <p>Update file <code>main.go</code> untuk menambahkan routes transaction management:</p>
                    
                    <pre><code>// Tambahkan routes untuk transaction management
func setupRoutes(r *gin.Engine) {
    // ... existing routes ...
    
    // Transaction Management Routes (Admin Only)
    transactionHandler := handlers.NewTransactionHandler()
    
    admin := r.Group("/admin")
    admin.Use(middlewares.AuthMiddleware())
    admin.Use(middlewares.AdminMiddleware())
    {
        // Transaction routes
        transactions := admin.Group("/transactions")
        {
            transactions.GET("", transactionHandler.GetAllTransactions)
            transactions.GET("/:id", transactionHandler.GetTransactionByID)
            transactions.PUT("/:id/status", transactionHandler.UpdateTransactionStatus)
        }
    }
}</code></pre>

                    <h3>üß™ 8. Testing dengan Postman</h3>
                    <p>Sekarang kita akan test semua endpoint transaction management menggunakan Postman:</p>

                    <h4>üìã Test Cases untuk Transaction Management</h4>
                    <ol>
                        <li><strong>GET /admin/transactions</strong> - Ambil semua transaksi dengan pagination dan filter</li>
                        <li><strong>GET /admin/transactions/:id</strong> - Ambil detail transaksi berdasarkan ID</li>
                        <li><strong>PUT /admin/transactions/:id/status</strong> - Update status transaksi</li>
                    </ol>

                    <h4>üîê Headers yang Diperlukan:</h4>
                    <p>Semua endpoint memerlukan header:</p>
                    <ul>
                        <li><code>Authorization: Bearer YOUR_JWT_TOKEN</code></li>
                        <li><code>Content-Type: application/json</code></li>
                    </ul>

                    <h4>üìù Contoh Request Body:</h4>
                    
                    <h5>Update Transaction Status:</h5>
                    <pre><code>{
    "status": "paid"
}</code></pre>

                    <h4>üìä Contoh Response:</h4>
                    
                    <h5>Get All Transactions:</h5>
                    <pre><code>{
    "message": "Transactions retrieved successfully",
    "data": {
        "transactions": [
            {
                "id": 1,
                "user_id": 1,
                "user_name": "John Doe",
                "user_email": "john@example.com",
                "status": "paid",
                "total_amount": 150000.00,
                "payment_url": "https://app.midtrans.com/snap/v2/vtweb/...",
                "created_at": "2024-01-01T10:00:00Z",
                "updated_at": "2024-01-01T10:30:00Z"
            }
        ],
        "total": 1,
        "page": 1,
        "limit": 10,
        "total_pages": 1
    }
}</code></pre>

                    <h5>Get Transaction Detail:</h5>
                    <pre><code>{
    "message": "Transaction retrieved successfully",
    "data": {
        "id": 1,
        "user_id": 1,
        "user_name": "John Doe",
        "user_email": "john@example.com",
        "status": "paid",
        "total_amount": 150000.00,
        "payment_url": "https://app.midtrans.com/snap/v2/vtweb/...",
        "created_at": "2024-01-01T10:00:00Z",
        "updated_at": "2024-01-01T10:30:00Z",
        "details": [
            {
                "id": 1,
                "transaction_id": 1,
                "product_id": 1,
                "product_name": "Laptop Gaming",
                "product_image": "laptop.jpg",
                "quantity": 1,
                "price": 150000.00,
                "subtotal": 150000.00
            }
        ]
    }
}</code></pre>

                    <h3>üéØ Fitur-fitur Transaction Management:</h3>
                    <ul>
                        <li>‚úÖ <strong>List Transactions</strong> - Admin dapat melihat semua transaksi dengan pagination</li>
                        <li>‚úÖ <strong>Filter by Status</strong> - Admin dapat filter transaksi berdasarkan status (pending, paid, failed, expired)</li>
                        <li>‚úÖ <strong>Transaction Detail</strong> - Admin dapat melihat detail transaksi lengkap dengan produk yang dibeli</li>
                        <li>‚úÖ <strong>Update Status</strong> - Admin dapat mengupdate status transaksi</li>
                        <li>‚úÖ <strong>User Transactions</strong> - Admin dapat melihat transaksi berdasarkan user tertentu</li>
                        <li>‚úÖ <strong>Pagination</strong> - Semua list endpoint mendukung pagination</li>
                        <li>‚úÖ <strong>Validation</strong> - Semua input divalidasi dengan baik</li>
                        <li>‚úÖ <strong>Error Handling</strong> - Error handling yang komprehensif</li>
                    </ul>

                    <h3>üîí Security Features:</h3>
                    <ul>
                        <li>‚úÖ <strong>Admin Only Access</strong> - Semua endpoint hanya bisa diakses admin</li>
                        <li>‚úÖ <strong>JWT Authentication</strong> - Memerlukan token yang valid</li>
                        <li>‚úÖ <strong>Input Validation</strong> - Semua input divalidasi</li>
                        <li>‚úÖ <strong>SQL Injection Protection</strong> - Menggunakan prepared statements</li>
                    </ul>

                    <h3>üìä Database Schema yang Digunakan:</h3>
                    <ul>
                        <li>‚úÖ <strong>Transactions Table</strong> - Menyimpan informasi transaksi utama</li>
                        <li>‚úÖ <strong>TransactionDetails Table</strong> - Menyimpan detail produk dalam transaksi</li>
                        <li>‚úÖ <strong>Foreign Key Constraints</strong> - Relasi yang aman antar tabel</li>
                        <li>‚úÖ <strong>Indexing</strong> - Optimasi query dengan indexing yang tepat</li>
                    </ul>

                    <h3>üìù 9. Update Database Config untuk AutoMigrate</h3>
                    <p>Update file <code>config/database.go</code> untuk menambahkan Transaction model:</p>
                    
                    <pre><code>package config

import (
    "fmt"
    "log"
    "os"
    "tokogo/models"

    "gorm.io/driver/mysql"
    "gorm.io/gorm"
)

var DB *gorm.DB

// InitDB menginisialisasi koneksi database
func InitDB() {
    var err error

    // Konfigurasi database dari environment variables
    dbHost := GetEnv("DB_HOST", "localhost")
    dbPort := GetEnv("DB_PORT", "3306")
    dbUser := GetEnv("DB_USER", "root")
    dbPassword := GetEnv("DB_PASSWORD", "")
    dbName := GetEnv("DB_NAME", "tokogo")

    // Buat DSN (Data Source Name)
    dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local",
        dbUser, dbPassword, dbHost, dbPort, dbName)

    // Koneksi ke database
    DB, err = gorm.Open(mysql.Open(dsn), &gorm.Config{})
    if err != nil {
        log.Fatal("Failed to connect to database:", err)
    }

    // Auto migrate models
    err = DB.AutoMigrate(
        &models.User{},
        &models.Category{},
        &models.Product{},
        &models.Transaction{},
        &models.TransactionDetail{},
    )
    if err != nil {
        log.Fatal("Failed to migrate database:", err)
    }

    log.Println("Database connected and migrated successfully")
}

// GetDB mengembalikan instance database
func GetDB() *gorm.DB {
    return DB
}</code></pre>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; border-radius: 5px; margin: 1.5rem 0;">
                        <h4 style="color: #2c3e50; margin-bottom: 1rem;">üí° Penjelasan Database Config Update</h4>
                        <ul>
                            <li><strong>AutoMigrate:</strong> Menambahkan Transaction dan TransactionDetail models</li>
                            <li><strong>Foreign Keys:</strong> GORM akan otomatis membuat relasi antar tabel</li>
                            <li><strong>Table Creation:</strong> Tabel akan dibuat otomatis jika belum ada</li>
                            <li><strong>Schema Update:</strong> Schema akan diupdate jika ada perubahan</li>
                        </ul>
                        <p style="color: #495057; margin-bottom: 0;"><strong>üí° Keuntungan:</strong> Dengan AutoMigrate, kita tidak perlu membuat tabel secara manual. GORM akan menangani pembuatan tabel dan relasi berdasarkan model yang didefinisikan.</p>
                    </div>

                    <h3>‚úÖ Checklist Implementasi</h3>
                    <p>Pastikan Anda telah menyelesaikan semua langkah berikut:</p>
                    <ul>
                        <li>‚úÖ Membuat model Transaction dan TransactionDetail di models/transaction.go</li>
                        <li>‚úÖ Membuat request structs di requests/transaction_request.go</li>
                        <li>‚úÖ Membuat response structs di responses/transaction_response.go</li>
                        <li>‚úÖ Membuat repository di repositories/transaction_repository.go</li>
                        <li>‚úÖ Membuat service di services/transaction_service.go</li>
                        <li>‚úÖ Membuat handler di handlers/transaction_handler.go</li>
                        <li>‚úÖ Menambahkan routes di main.go</li>
                        <li>‚úÖ Update database config untuk AutoMigrate</li>
                        <li>‚úÖ Test semua endpoint dengan Postman</li>
                    </ul>

                    <div style="background: #d4edda; border: 1px solid #c3e6cb; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #155724; margin-bottom: 1rem;">üéâ Selamat! Modul Transaction Management Selesai!</h3>
                        <p style="color: #155724; margin-bottom: 0;">Dengan sistem Transaction Management yang lengkap, admin dapat mengelola semua transaksi dengan mudah. Sistem ini menyediakan visibilitas penuh terhadap aktivitas transaksi dan memungkinkan admin untuk mengelola status transaksi sesuai kebutuhan bisnis.</p>
                    </div>
                `
            },
            {
                id: 'chapter-14',
                title: 'Bab 14: Modul Profile & Password - User Management',
                meta: 'Halaman 15 dari 55 ‚Ä¢ Dibaca 25 menit',
                content: `
                    <h2>üë§ Bab 14: Modul Profile & Password - User Management</h2>
                    <p>Selamat! Sekarang kita akan membuat modul Profile dan Password yang memungkinkan user yang sudah login untuk mengedit profil mereka dan mengubah password. Di bab ini, kita akan mengimplementasikan sistem manajemen profil user dengan fitur edit profile dan change password.</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">üéØ Apa yang Akan Kita Buat di Bab Ini?</h3>
                        <p style="color: #495057; margin-bottom: 0;">Kita akan membuat sistem Profile dan Password Management yang lengkap dengan fitur edit profile dan change password. User yang sudah login dapat mengedit nama dan email mereka, serta mengubah password dengan validasi yang ketat. Semua endpoint memerlukan authentication dan hanya bisa diakses oleh user yang login.</p>
                    </div>

                    <h3>üìã Prasyarat</h3>
                    <p>Sebelum memulai, pastikan Anda sudah menyelesaikan:</p>
                    <ul>
                        <li>‚úÖ Bab 6-8: Modul Authentication (Register, Login, Logout)</li>
                        <li>‚úÖ Bab 9: Review Pembelajaran Authentication</li>
                        <li>‚úÖ Bab 10: Modul CRUD Kategori - Role Admin</li>
                        <li>‚úÖ Bab 11: Modul CRUD Product - Role Admin</li>
                        <li>‚úÖ Bab 12: Modul User Management - Role Admin</li>
                        <li>‚úÖ Bab 13: Modul Transaction Management - Role Admin</li>
                        <li>‚úÖ Middleware authentication sudah berfungsi</li>
                        <li>‚úÖ Model User sudah ada dan berfungsi</li>
                        <li>‚úÖ Tabel users sudah ada di database</li>
                    </ul>

                    <h3>üóÑÔ∏è Database Schema</h3>
                    <p>Kita akan menggunakan tabel users yang sudah ada. Berikut adalah schema yang akan kita gunakan:</p>

                    <h4>üìä Tabel Users (Sudah Ada)</h4>
                    <pre><code>CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    role ENUM('customer','admin') DEFAULT 'customer',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL
);</code></pre>

                    <h3>üèóÔ∏è Struktur File yang Akan Dibuat</h3>
                    <p>Kita akan membuat file-file berikut untuk modul Profile dan Password:</p>
                    <ul>
                        <li><code>requests/profile_request.go</code> - Request structs untuk profile management</li>
                        <li><code>responses/profile_response.go</code> - Response structs untuk profile management</li>
                        <li><code>repositories/profile_repository.go</code> - Repository layer untuk profile management</li>
                        <li><code>services/profile_service.go</code> - Service layer untuk profile management</li>
                        <li><code>handlers/profile_handler.go</code> - Handler layer untuk profile management</li>
                    </ul>

                    <h3>üìù 1. Membuat Request Structs</h3>
                    <p>Pertama, kita buat file <code>requests/profile_request.go</code>:</p>
                    <pre><code>package requests

import (
    "errors"
    "strings"

    "github.com/go-playground/validator/v10"
)

// UpdateProfileRequest represents the request structure for updating profile
type UpdateProfileRequest struct {
    Name  string \`json:"name" validate:"required,min=3,max=255"\`
    Email string \`json:"email" validate:"required,email,max=255"\`
}

// ChangePasswordRequest represents the request structure for changing password
type ChangeUserPasswordRequest struct {
    CurrentPassword string \`json:"current_password" validate:"required"\`
    NewPassword     string \`json:"new_password" validate:"required,min=6,max=255"\`
    ConfirmPassword string \`json:"confirm_password" validate:"required"\`
}

// Validate validates the UpdateProfileRequest using the validator
func (r *UpdateProfileRequest) Validate() error {
    validate := validator.New()

    // Validasi struct fields
    if err := validate.Struct(r); err != nil {
        return err
    }

    // Validasi custom: nama tidak boleh kosong setelah trim
    if strings.TrimSpace(r.Name) == "" {
        return errors.New("name cannot be empty")
    }

    // Validasi custom: email tidak boleh kosong setelah trim
    if strings.TrimSpace(r.Email) == "" {
        return errors.New("email cannot be empty")
    }

    return nil
}

// Validate validates the ChangePasswordRequest using the validator
func (r *ChangeUserPasswordRequest) Validate() error {
    validate := validator.New()

    // Validasi struct fields
    if err := validate.Struct(r); err != nil {
        return err
    }

    // Validasi custom: current password tidak boleh kosong setelah trim
    if strings.TrimSpace(r.CurrentPassword) == "" {
        return errors.New("current password cannot be empty")
    }

    // Validasi custom: new password tidak boleh kosong setelah trim
    if strings.TrimSpace(r.NewPassword) == "" {
        return errors.New("new password cannot be empty")
    }

    // Validasi custom: confirm password tidak boleh kosong setelah trim
    if strings.TrimSpace(r.ConfirmPassword) == "" {
        return errors.New("confirm password cannot be empty")
    }

    // Validasi password match
    if r.NewPassword != r.ConfirmPassword {
        return errors.New("new password and confirm password must match")
    }

    // Validasi password tidak sama dengan current
    if r.CurrentPassword == r.NewPassword {
        return errors.New("new password cannot be the same as current password")
    }

    return nil
}</code></pre>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; border-radius: 5px; margin: 1.5rem 0;">
                        <h4 style="color: #2c3e50; margin-bottom: 1rem;">üí° Penjelasan Request Structs</h4>
                        <ul>
                            <li><strong>UpdateProfileRequest:</strong> Struct untuk mengupdate profil user (nama dan email)</li>
                            <li><strong>ChangePasswordRequest:</strong> Struct untuk mengubah password user dengan validasi keamanan</li>
                        </ul>
                        <p><strong>Validasi yang Digunakan:</strong></p>
                        <ul>
                            <li><strong>required:</strong> Semua field wajib diisi</li>
                            <li><strong>min=3, max=255:</strong> Panjang string minimal 3, maksimal 255 karakter</li>
                            <li><strong>email:</strong> Format email yang valid</li>
                            <li><strong>min=6:</strong> Password minimal 6 karakter</li>
                        </ul>
                        <p><strong>Custom Validation untuk Profile:</strong></p>
                        <ul>
                            <li><strong>TrimSpace:</strong> Menghapus spasi di awal dan akhir string</li>
                            <li><strong>Empty Check:</strong> Memastikan field tidak kosong setelah di-trim</li>
                        </ul>
                        <p><strong>Custom Validation untuk Password:</strong></p>
                        <ul>
                            <li><strong>Password Match:</strong> Memastikan new password dan confirm password sama</li>
                            <li><strong>Password Different:</strong> Memastikan new password berbeda dengan current password</li>
                            <li><strong>Empty Validation:</strong> Memastikan semua field password tidak kosong</li>
                        </ul>
                        <p><strong>Security Features:</strong></p>
                        <ul>
                            <li><strong>Password Confirmation:</strong> User harus konfirmasi password baru</li>
                            <li><strong>Password Change Prevention:</strong> Mencegah user menggunakan password yang sama</li>
                            <li><strong>Input Sanitization:</strong> Trim spasi untuk mencegah input yang tidak valid</li>
                        </ul>
                        <p style="color: #495057; margin-bottom: 0;"><strong>üí° Keuntungan:</strong> Request structs ini memastikan keamanan tinggi untuk perubahan profil dan password, dengan validasi yang ketat untuk mencegah kesalahan user dan serangan keamanan.</p>
                    </div>

                    <h3>üì§ 2. Membuat Response Structs</h3>
                    <p>Buat file <code>responses/profile_response.go</code>:</p>
                    <pre><code>package responses

import "tokogo/models"

// ProfileResponse struct untuk response profile
type ProfileResponse struct {
    ID        uint   \`json:"id"\`
    Name      string \`json:"name"\`
    Email     string \`json:"email"\`
    Role      string \`json:"role"\`
    CreatedAt string \`json:"created_at"\`
    UpdatedAt string \`json:"updated_at"\`
}

// ChangeUserPasswordResponse struct untuk response change password
type ChangeUserPasswordResponse struct {
    Message string \`json:"message"\`
}

// ConvertUserToProfileResponse mengkonversi model User ke ProfileResponse
func ConvertUserToProfileResponse(user models.User) ProfileResponse {
    return ProfileResponse{
        ID:        user.ID,
        Name:      user.Name,
        Email:     user.Email,
        Role:      user.Role,
        CreatedAt: user.CreatedAt.Format("2006-01-02 15:04:05"),
        UpdatedAt: user.UpdatedAt.Format("2006-01-02 15:04:05"),
    }
}</code></pre>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; border-radius: 5px; margin: 1.5rem 0;">
                        <h4 style="color: #2c3e50; margin-bottom: 1rem;">üí° Penjelasan Response Structs</h4>
                        <ul>
                            <li><strong>ProfileResponse:</strong> Struct untuk response data profil user</li>
                            <li><strong>ChangePasswordResponse:</strong> Struct untuk response perubahan password</li>
                        </ul>
                        <p><strong>Profile Response Fields:</strong></p>
                        <ul>
                            <li><strong>ID:</strong> Unique identifier user</li>
                            <li><strong>Name:</strong> Nama lengkap user</li>
                            <li><strong>Email:</strong> Email address user</li>
                            <li><strong>Role:</strong> Role user (customer/admin)</li>
                            <li><strong>CreatedAt/UpdatedAt:</strong> Timestamp dengan format yang konsisten</li>
                        </ul>
                        <p><strong>Change Password Response:</strong></p>
                        <ul>
                            <li><strong>Message:</strong> Pesan konfirmasi perubahan password</li>
                            <li><strong>No Sensitive Data:</strong> Tidak mengembalikan data sensitif seperti password</li>
                        </ul>
                        <p><strong>Converter Function:</strong></p>
                        <ul>
                            <li><strong>ConvertUserToProfileResponse:</strong> Konversi model User ke ProfileResponse</li>
                            <li><strong>Date Formatting:</strong> Format tanggal konsisten "2006-01-02 15:04:05"</li>
                            <li><strong>Data Mapping:</strong> Mapping field dari model ke response format</li>
                        </ul>
                        <p><strong>Security Considerations:</strong></p>
                        <ul>
                            <li><strong>Password Exclusion:</strong> Password tidak dikembalikan dalam response</li>
                            <li><strong>Minimal Data:</strong> Hanya mengembalikan data yang diperlukan</li>
                            <li><strong>Consistent Format:</strong> Format response yang konsisten untuk frontend</li>
                        </ul>
                        <p style="color: #495057; margin-bottom: 0;"><strong>üí° Keuntungan:</strong> Response structs ini memastikan keamanan data dengan tidak mengembalikan informasi sensitif, menyediakan format yang konsisten, dan memudahkan frontend untuk menampilkan data profil user.</p>
                    </div>

                    <h3>üóÑÔ∏è 3. Membuat Repository Layer</h3>
                    <p>Buat file <code>repositories/profile_repository.go</code>:</p>
                    <pre><code>package repositories

import (
    "errors"
    "tokogo/config"
    "tokogo/models"

    "golang.org/x/crypto/bcrypt"
    "gorm.io/gorm"
)

type ProfileRepository struct {
    db *gorm.DB
}

// NewProfileRepository membuat instance baru ProfileRepository
func NewProfileRepository() *ProfileRepository {
    return &ProfileRepository{
        db: config.DB,
    }
}

// GetProfileByID mengambil profile user berdasarkan ID
func (r *ProfileRepository) GetProfileByID(userID uint) (*models.User, error) {
    var user models.User
    err := r.db.First(&user, userID).Error
    if err != nil {
        return nil, err
    }
    return &user, nil
}

// UpdateProfile mengupdate profile user
func (r *ProfileRepository) UpdateProfile(userID uint, name, email string) (*models.User, error) {
    var user models.User
    
    // Cek apakah user ada
    if err := r.db.First(&user, userID).Error; err != nil {
        return nil, errors.New("user not found")
    }
    
    // Cek apakah email sudah digunakan oleh user lain
    var existingUser models.User
    if err := r.db.Where("email = ? AND id != ?", email, userID).First(&existingUser).Error; err == nil {
        return nil, errors.New("email already exists")
    }
    
    // Update profile
    user.Name = name
    user.Email = email
    
    if err := r.db.Save(&user).Error; err != nil {
        return nil, errors.New("failed to update profile")
    }
    
    return &user, nil
}

// ChangeUserPassword mengubah password user
func (r *ProfileRepository) ChangeUserPassword(userID uint, currentPassword, newPassword string) error {
        var user models.User
        
    // Cek apakah user ada
    if err := r.db.First(&user, userID).Error; err != nil {
        return errors.New("user not found")
    }
    
    // Verifikasi current password
    if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(currentPassword)); err != nil {
        return errors.New("current password is incorrect")
    }
    
    // Hash new password
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(newPassword), bcrypt.DefaultCost)
    if err != nil {
        return errors.New("failed to hash new password")
    }
    
    // Update password
    user.Password = string(hashedPassword)
    
    if err := r.db.Save(&user).Error; err != nil {
        return errors.New("failed to change password")
    }
    
    return nil
}</code></pre>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; border-radius: 5px; margin: 1.5rem 0;">
                        <h4 style="color: #2c3e50; margin-bottom: 1rem;">üí° Penjelasan Repository Layer</h4>
                        <ul>
                            <li><strong>ProfileRepository:</strong> Struct yang mengelola akses database untuk profile management</li>
                            <li><strong>Database Connection:</strong> Menggunakan GORM untuk operasi database</li>
                        </ul>
                        <p><strong>Profile Operations:</strong></p>
                        <ul>
                            <li><strong>GetProfileByID:</strong> Mengambil profil user berdasarkan ID</li>
                            <li><strong>UpdateProfile:</strong> Mengupdate profil user (nama dan email)</li>
                            <li><strong>ChangePassword:</strong> Mengubah password user dengan verifikasi keamanan</li>
                        </ul>
                        <p><strong>Security Features:</strong></p>
                        <ul>
                            <li><strong>Email Uniqueness:</strong> Validasi email tidak boleh duplikat dengan user lain</li>
                            <li><strong>Password Verification:</strong> Verifikasi current password sebelum mengubah</li>
                            <li><strong>Password Hashing:</strong> Hash password baru menggunakan bcrypt</li>
                            <li><strong>User Existence Check:</strong> Validasi user exists sebelum operasi</li>
                        </ul>
                        <p><strong>Data Validation:</strong></p>
                        <ul>
                            <li><strong>Email Conflict Check:</strong> Cek email sudah digunakan user lain dengan WHERE clause</li>
                            <li><strong>Password Comparison:</strong> Compare hash password dengan bcrypt</li>
                            <li><strong>Atomic Operations:</strong> Operasi database yang atomic untuk konsistensi</li>
                        </ul>
                        <p><strong>Error Handling:</strong></p>
                        <ul>
                            <li><strong>Custom Error Messages:</strong> Pesan error yang user-friendly</li>
                            <li><strong>GORM Error Handling:</strong> Handle error dari GORM operations</li>
                            <li><strong>Security Error Messages:</strong> Error messages yang tidak expose informasi sensitif</li>
                        </ul>
                        <p style="color: #495057; margin-bottom: 0;"><strong>üí° Keuntungan:</strong> Repository layer ini menyediakan operasi yang aman untuk profile management dengan validasi email unik, verifikasi password, dan error handling yang komprehensif.</p>
                    </div>

                    <h3>‚öôÔ∏è 4. Membuat Service Layer</h3>
                    <p>Buat file <code>services/profile_service.go</code>:</p>
                    <pre><code>package services

import (
    "tokogo/repositories"
    "tokogo/requests"
    "tokogo/responses"
)

type ProfileService struct {
    profileRepo *repositories.ProfileRepository
}

// NewProfileService membuat instance baru ProfileService
func NewProfileService() *ProfileService {
    return &ProfileService{
        profileRepo: repositories.NewProfileRepository(),
    }
}

// GetProfile mengambil profile user
func (s *ProfileService) GetProfile(userID uint) (*responses.ProfileResponse, error) {
    user, err := s.profileRepo.GetProfileByID(userID)
    if err != nil {
        return nil, err
    }
    
    profileResponse := responses.ConvertUserToProfileResponse(*user)
    return &profileResponse, nil
}

// UpdateProfile mengupdate profile user
func (s *ProfileService) UpdateProfile(userID uint, req requests.UpdateProfileRequest) (*responses.ProfileResponse, error) {
    // Validasi request
    if err := req.Validate(); err != nil {
        return nil, err
    }
    
    // Update profile
    user, err := s.profileRepo.UpdateProfile(userID, req.Name, req.Email)
    if err != nil {
        return nil, err
    }
    
    profileResponse := responses.ConvertUserToProfileResponse(*user)
    return &profileResponse, nil
}

// ChangePassword mengubah password user
func (s *ProfileService) ChangePassword(userID uint, req requests.ChangePasswordRequest) (*responses.ChangePasswordResponse, error) {
    // Validasi request
    if err := req.Validate(); err != nil {
        return nil, err
    }
    
    // Change password
    if err := s.profileRepo.ChangePassword(userID, req.CurrentPassword, req.NewPassword); err != nil {
        return nil, err
    }
    
    return &responses.ChangePasswordResponse{
        Message: "Password changed successfully",
    }, nil
}</code></pre>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; border-radius: 5px; margin: 1.5rem 0;">
                        <h4 style="color: #2c3e50; margin-bottom: 1rem;">üí° Penjelasan Service Layer</h4>
                        <ul>
                            <li><strong>ProfileService:</strong> Struct yang mengelola business logic untuk profile management</li>
                            <li><strong>Repository Injection:</strong> Menggunakan dependency injection untuk repository</li>
                        </ul>
                        <p><strong>Business Logic Operations:</strong></p>
                        <ul>
                            <li><strong>GetProfile:</strong> Mengambil profil user dan konversi ke response format</li>
                            <li><strong>UpdateProfile:</strong> Validasi request dan update profil user</li>
                            <li><strong>ChangePassword:</strong> Validasi request dan ubah password user</li>
                        </ul>
                        <p><strong>Request Validation:</strong></p>
                        <ul>
                            <li><strong>Input Validation:</strong> Validasi semua request menggunakan method Validate()</li>
                            <li><strong>Business Rules:</strong> Implementasi business rules untuk profile management</li>
                            <li><strong>Error Propagation:</strong> Propagate error dari repository layer</li>
                        </ul>
                        <p><strong>Response Transformation:</strong></p>
                        <ul>
                            <li><strong>Model to Response:</strong> Konversi model User ke ProfileResponse</li>
                            <li><strong>Success Messages:</strong> Generate success messages untuk operasi</li>
                            <li><strong>Data Sanitization:</strong> Memastikan data yang dikembalikan aman</li>
                        </ul>
                        <p><strong>Security Considerations:</strong></p>
                        <ul>
                            <li><strong>User Context:</strong> Menggunakan userID dari JWT token untuk operasi</li>
                            <li><strong>Data Isolation:</strong> User hanya bisa mengakses data mereka sendiri</li>
                            <li><strong>Password Security:</strong> Tidak mengembalikan informasi password</li>
                        </ul>
                        <p style="color: #495057; margin-bottom: 0;"><strong>üí° Keuntungan:</strong> Service layer ini menyediakan business logic yang aman untuk profile management, dengan validasi yang ketat dan isolasi data user yang proper.</p>
                    </div>

                    <h3>üéÆ 5. Membuat Handler Layer</h3>
                    <p>Buat file <code>handlers/profile_handler.go</code>:</p>
                    <pre><code>package handlers

import (
    "net/http"
    "tokogo/requests"
    "tokogo/responses"
    "tokogo/services"
    
    "github.com/gin-gonic/gin"
)

type ProfileHandler struct {
    profileService *services.ProfileService
}

// NewProfileHandler membuat instance baru ProfileHandler
func NewProfileHandler() *ProfileHandler {
    return &ProfileHandler{
        profileService: services.NewProfileService(),
    }
}

// GetProfile handler untuk mengambil profile user
func (h *ProfileHandler) GetProfile(c *gin.Context) {
    // Ambil user ID dari JWT token
    userIDInterface, exists := c.Get("user_id")
    if !exists {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "unauthorized",
            Message: "User ID not found",
        })
        return
    }
    
    userID, ok := userIDInterface.(uint)
    if !ok {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "unauthorized",
            Message: "Invalid user ID",
        })
        return
    }
    
    // Panggil service untuk get profile
    profile, err := h.profileService.GetProfile(userID)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "get_profile_failed",
            Message: err.Error(),
        })
        return
    }
    
    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Profile retrieved successfully",
        Data:    profile,
    })
}

// UpdateProfile handler untuk mengupdate profile user
func (h *ProfileHandler) UpdateProfile(c *gin.Context) {
    // Ambil user ID dari JWT token
    userIDInterface, exists := c.Get("user_id")
    if !exists {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "unauthorized",
            Message: "User ID not found",
        })
        return
    }
    
    userID, ok := userIDInterface.(uint)
    if !ok {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "unauthorized",
            Message: "Invalid user ID",
        })
        return
    }
    
    var req requests.UpdateProfileRequest
    
    // Bind dan validasi request
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }
    
    // Panggil service untuk update profile
    response, err := h.profileService.UpdateProfile(userID, req)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "update_profile_failed",
            Message: err.Error(),
        })
        return
    }
    
    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Profile updated successfully",
        Data:    response,
    })
}

// ChangeUserPassword handler untuk mengubah password user
func (h *ProfileHandler) ChangeUserPassword(c *gin.Context) {
    // Ambil user ID dari JWT token
    userIDInterface, exists := c.Get("user_id")
    if !exists {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "unauthorized",
            Message: "User ID not found",
        })
        return
    }
    
    userID, ok := userIDInterface.(uint)
    if !ok {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "unauthorized",
            Message: "Invalid user ID",
        })
        return
    }
    
    var req requests.ChangePasswordRequest
    
    // Bind dan validasi request
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }
    
    // Panggil service untuk change password
    response, err := h.profileService.ChangePassword(userID, req)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "change_password_failed",
            Message: err.Error(),
        })
        return
    }
    
    c.JSON(http.StatusOK, response)
}</code></pre>

                    <h3>üîó 6. Menambahkan Routes di main.go</h3>
                    <p>Sekarang kita akan menambahkan routes untuk profile dan password management di main.go:</p>
                    <pre><code>// Tambahkan routes untuk profile dan password management
func setupRoutes(r *gin.Engine) {
    // ... existing routes ...
    
    // Profile & Password Management Routes (Authenticated Users)
    profileHandler := handlers.NewProfileHandler()
    
    // Profile routes
    r.GET("/profile", middlewares.AuthMiddleware(), profileHandler.GetProfile)
    r.PUT("/profile", middlewares.AuthMiddleware(), profileHandler.UpdateProfile)
    
    // Password routes
    r.PUT("/password", middlewares.AuthMiddleware(), profileHandler.ChangePassword)
}</code></pre>

                    <h3>üß™ Testing dengan Postman</h3>
                    <p>Sekarang kita akan test semua endpoint yang sudah dibuat menggunakan Postman.</p>

                    <h4>üìã Test Cases untuk Profile Management</h4>
                    <ol>
                        <li><strong>GET /profile</strong> - Ambil profile user yang login</li>
                        <li><strong>PUT /profile</strong> - Update profile user yang login</li>
                        <li><strong>PUT /password</strong> - Ubah password user yang login</li>
                    </ol>

                    <h4>üîê Headers yang Diperlukan</h4>
                    <pre><code>Authorization: Bearer YOUR_JWT_TOKEN
Content-Type: application/json</code></pre>

                    <h4>üìù Sample Request Body untuk Update Profile</h4>
                    <pre><code>{
    "name": "John Doe Updated",
    "email": "john.doe.updated@example.com"
}</code></pre>

                    <h4>üìù Sample Request Body untuk Change Password</h4>
                    <pre><code>{
    "current_password": "oldpassword123",
    "new_password": "newpassword123",
    "confirm_password": "newpassword123"
}</code></pre>

                    <h3>‚úÖ Fitur yang Sudah Diimplementasikan</h3>
                    <ul>
                        <li>‚úÖ <strong>Get Profile</strong> - User dapat melihat profile mereka</li>
                        <li>‚úÖ <strong>Update Profile</strong> - User dapat mengedit nama dan email</li>
                        <li>‚úÖ <strong>Change Password</strong> - User dapat mengubah password dengan validasi</li>
                        <li>‚úÖ <strong>Authentication Required</strong> - Semua endpoint memerlukan JWT token</li>
                        <li>‚úÖ <strong>Input Validation</strong> - Semua input divalidasi dengan ketat</li>
                        <li>‚úÖ <strong>Password Security</strong> - Password di-hash dengan bcrypt</li>
                        <li>‚úÖ <strong>Email Uniqueness</strong> - Email harus unik saat update</li>
                        <li>‚úÖ <strong>Current Password Verification</strong> - Verifikasi password lama saat change password</li>
                    </ul>

                    <h3>üîí Keamanan yang Diimplementasikan</h3>
                    <ul>
                        <li>‚úÖ <strong>JWT Authentication</strong> - Semua endpoint memerlukan token yang valid</li>
                        <li>‚úÖ <strong>User Authorization</strong> - User hanya bisa mengakses profile mereka sendiri</li>
                        <li>‚úÖ <strong>Input Validation</strong> - Semua input divalidasi</li>
                        <li>‚úÖ <strong>Password Hashing</strong> - Password di-hash dengan bcrypt</li>
                        <li>‚úÖ <strong>SQL Injection Protection</strong> - Menggunakan GORM ORM</li>
                        <li>‚úÖ <strong>Email Uniqueness Check</strong> - Mencegah duplikasi email</li>
                    </ul>

                    <h3>üìä Database Schema yang Digunakan:</h3>
                    <ul>
                        <li>‚úÖ <strong>Users Table</strong> - Menggunakan tabel users yang sudah ada</li>
                        <li>‚úÖ <strong>Password Hashing</strong> - Password disimpan dalam bentuk hash</li>
                        <li>‚úÖ <strong>Email Uniqueness</strong> - Constraint unique pada email</li>
                        <li>‚úÖ <strong>Soft Delete</strong> - Menggunakan soft delete untuk data integrity</li>
                    </ul>

                    <div style="background: #d4edda; border: 1px solid #c3e6cb; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #155724; margin-bottom: 1rem;">üéâ Selamat! Modul Profile & Password Selesai!</h3>
                        <p style="color: #155724; margin-bottom: 0;">Dengan sistem Profile dan Password Management yang lengkap, user dapat mengelola profil mereka dengan aman. Sistem ini menyediakan fitur edit profile dan change password dengan validasi yang ketat dan keamanan yang tinggi.</p>
                    </div>
                `
            },
            {
                id: 'chapter-15',
                title: 'Bab 15: Relaksasi & Review Pembelajaran - Modul CRUD & User Management',
                meta: 'Halaman 16 dari 55 ‚Ä¢ Dibaca 20 menit',
                content: `
                    <h2>üßò Bab 15: Relaksasi & Review Pembelajaran - Modul CRUD & User Management</h2>
                    <p>Selamat! Anda telah berhasil menyelesaikan modul-modul CRUD dan User Management yang lengkap (Bab 10-14). Sekarang saatnya untuk beristirahat sejenak dan mengulas kembali semua yang telah dipelajari tentang sistem manajemen data dan user. Bab ini dirancang untuk membantu otak Anda mengkonsolidasikan pengetahuan CRUD dan User Management yang baru saja diperoleh.</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">üéØ Tujuan Bab Relaksasi Ini</h3>
                        <p style="color: #495057; margin-bottom: 0;">Bab ini akan membantu Anda mengkonsolidasikan pembelajaran dari modul CRUD Kategori, CRUD Product, User Management, Transaction Management, dan Profile & Password Management. Kita akan mengulas kembali konsep-konsep penting, pola-pola yang digunakan, dan bagaimana semua modul ini saling terhubung dalam sistem yang lebih besar.</p>
                    </div>

                    <h3>üìö Ringkasan Pembelajaran Bab 10-14</h3>
                    <p>Mari kita ulas kembali semua yang telah dipelajari dalam modul CRUD dan User Management:</p>

                    <h4>üìÇ Bab 10: Modul CRUD Kategori - Role Admin</h4>
                    <div style="background: #e3f2fd; border-left: 4px solid #2196f3; padding: 1rem; margin: 1rem 0;">
                        <p><strong>Konsep Utama:</strong> Sistem manajemen kategori dengan operasi CRUD lengkap</p>
                        <p><strong>Fitur yang Dipelajari:</strong></p>
                        <ul>
                            <li>‚úÖ <strong>Create Category</strong> - Membuat kategori baru dengan validasi</li>
                            <li>‚úÖ <strong>Get Categories</strong> - Mengambil daftar kategori dengan pagination</li>
                            <li>‚úÖ <strong>Get Category by ID</strong> - Mengambil detail kategori spesifik</li>
                            <li>‚úÖ <strong>Update Category</strong> - Mengupdate informasi kategori</li>
                            <li>‚úÖ <strong>Delete Category</strong> - Menghapus kategori dengan soft delete</li>
                        </ul>
                        <p><strong>Pola yang Digunakan:</strong> Repository Pattern, Service Layer, Handler Layer, Request/Response Validation</p>
                    </div>

                    <h4>üì¶ Bab 11: Modul CRUD Product - Role Admin</h4>
                    <div style="background: #e8f5e8; border-left: 4px solid #4caf50; padding: 1rem; margin: 1rem 0;">
                        <p><strong>Konsep Utama:</strong> Sistem manajemen produk dengan relasi ke kategori</p>
                        <p><strong>Fitur yang Dipelajari:</strong></p>
                        <ul>
                            <li>‚úÖ <strong>Create Product</strong> - Membuat produk baru dengan validasi kategori</li>
                            <li>‚úÖ <strong>Get Products</strong> - Mengambil daftar produk dengan filter dan pagination</li>
                            <li>‚úÖ <strong>Get Product by ID</strong> - Mengambil detail produk dengan relasi kategori</li>
                            <li>‚úÖ <strong>Update Product</strong> - Mengupdate informasi produk</li>
                            <li>‚úÖ <strong>Delete Product</strong> - Menghapus produk dengan soft delete</li>
                        </ul>
                        <p><strong>Pola yang Digunakan:</strong> Foreign Key Relationships, File Upload Handling, Complex Validation</p>
                    </div>

                    <h4>üë• Bab 12: Modul User Management - Role Admin</h4>
                    <div style="background: #fff3e0; border-left: 4px solid #ff9800; padding: 1rem; margin: 1rem 0;">
                        <p><strong>Konsep Utama:</strong> Sistem manajemen user dengan role-based access control</p>
                        <p><strong>Fitur yang Dipelajari:</strong></p>
                        <ul>
                            <li>‚úÖ <strong>Create User</strong> - Membuat user baru dengan role assignment</li>
                            <li>‚úÖ <strong>Get Users</strong> - Mengambil daftar user dengan filter role</li>
                            <li>‚úÖ <strong>Get User by ID</strong> - Mengambil detail user spesifik</li>
                            <li>‚úÖ <strong>Update User</strong> - Mengupdate informasi user dan role</li>
                            <li>‚úÖ <strong>Delete User</strong> - Menghapus user dengan soft delete</li>
                            <li>‚úÖ <strong>Change Password</strong> - Mengubah password user oleh admin</li>
                        </ul>
                        <p><strong>Pola yang Digunakan:</strong> Role-Based Access Control, Password Hashing, Admin Middleware</p>
                    </div>

                    <h4>üí≥ Bab 13: Modul Transaction Management - Role Admin</h4>
                    <div style="background: #f3e5f5; border-left: 4px solid #9c27b0; padding: 1rem; margin: 1rem 0;">
                        <p><strong>Konsep Utama:</strong> Sistem manajemen transaksi dengan detail produk</p>
                        <p><strong>Fitur yang Dipelajari:</strong></p>
                        <ul>
                            <li>‚úÖ <strong>Get Transactions</strong> - Mengambil daftar transaksi dengan filter status</li>
                            <li>‚úÖ <strong>Get Transaction by ID</strong> - Mengambil detail transaksi dengan produk</li>
                            <li>‚úÖ <strong>Update Transaction Status</strong> - Mengupdate status transaksi</li>
                        </ul>
                        <p><strong>Pola yang Digunakan:</strong> Complex Relationships, Transaction Details, Status Management</p>
                    </div>

                    <h4>üë§ Bab 14: Modul Profile & Password - User Management</h4>
                    <div style="background: #e0f2f1; border-left: 4px solid #009688; padding: 1rem; margin: 1rem 0;">
                        <p><strong>Konsep Utama:</strong> Sistem manajemen profil user untuk user yang sudah login</p>
                        <p><strong>Fitur yang Dipelajari:</strong></p>
                        <ul>
                            <li>‚úÖ <strong>Get Profile</strong> - Mengambil profil user yang login</li>
                            <li>‚úÖ <strong>Update Profile</strong> - Mengupdate nama dan email user</li>
                            <li>‚úÖ <strong>Change Password</strong> - Mengubah password dengan verifikasi</li>
                        </ul>
                        <p><strong>Pola yang Digunakan:</strong> User Authentication, Self-Service Management, Password Security</p>
                    </div>

                    <h3>üîó Koneksi Antar Modul</h3>
                    <p>Mari kita lihat bagaimana semua modul ini saling terhubung:</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #2c3e50; margin-bottom: 1rem;">üèóÔ∏è Arsitektur Sistem yang Terintegrasi</h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin: 1rem 0;">
                            <div style="background: #e3f2fd; padding: 1rem; border-radius: 5px; text-align: center;">
                                <h5 style="color: #1976d2; margin: 0;">üë• Users</h5>
                                <p style="margin: 0.5rem 0 0 0; font-size: 0.9rem;">Base entity untuk semua operasi</p>
                            </div>
                            <div style="background: #e8f5e8; padding: 1rem; border-radius: 5px; text-align: center;">
                                <h5 style="color: #388e3c; margin: 0;">üìÇ Categories</h5>
                                <p style="margin: 0.5rem 0 0 0; font-size: 0.9rem;">Referensi untuk produk</p>
                            </div>
                            <div style="background: #fff3e0; padding: 1rem; border-radius: 5px; text-align: center;">
                                <h5 style="color: #f57c00; margin: 0;">üì¶ Products</h5>
                                <p style="margin: 0.5rem 0 0 0; font-size: 0.9rem;">Terhubung ke kategori</p>
                            </div>
                            <div style="background: #f3e5f5; padding: 1rem; border-radius: 5px; text-align: center;">
                                <h5 style="color: #7b1fa2; margin: 0;">üí≥ Transactions</h5>
                                <p style="margin: 0.5rem 0 0 0; font-size: 0.9rem;">Terhubung ke user</p>
                            </div>
                        </div>
                    </div>

                    <h3>üéØ Pola-Pola Penting yang Dipelajari</h3>
                    <p>Berikut adalah pola-pola penting yang konsisten digunakan di semua modul:</p>

                    <h4>üìù 1. Request/Response Pattern</h4>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <p><strong>Konsistensi yang Dicapai:</strong></p>
                        <ul>
                            <li>‚úÖ <strong>Request Structs</strong> - Validasi menggunakan validator package</li>
                            <li>‚úÖ <strong>Response Structs</strong> - Format response yang konsisten</li>
                            <li>‚úÖ <strong>Error Handling</strong> - Error messages dalam bahasa Inggris</li>
                            <li>‚úÖ <strong>Success Response</strong> - Format success yang seragam</li>
                        </ul>
                    </div>

                    <h4>üóÑÔ∏è 2. Repository Pattern</h4>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <p><strong>Konsistensi yang Dicapai:</strong></p>
                        <ul>
                            <li>‚úÖ <strong>Database Operations</strong> - Menggunakan GORM untuk semua operasi</li>
                            <li>‚úÖ <strong>Error Handling</strong> - Error handling yang konsisten</li>
                            <li>‚úÖ <strong>Soft Delete</strong> - Implementasi soft delete di semua modul</li>
                            <li>‚úÖ <strong>Pagination</strong> - Pagination untuk list operations</li>
                        </ul>
                    </div>

                    <h4>‚öôÔ∏è 3. Service Layer Pattern</h4>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <p><strong>Konsistensi yang Dicapai:</strong></p>
                        <ul>
                            <li>‚úÖ <strong>Business Logic</strong> - Logika bisnis terpusat di service layer</li>
                            <li>‚úÖ <strong>Validation</strong> - Validasi request sebelum operasi database</li>
                            <li>‚úÖ <strong>Data Transformation</strong> - Konversi data untuk response</li>
                            <li>‚úÖ <strong>Error Propagation</strong> - Error handling yang konsisten</li>
                        </ul>
                    </div>

                    <h4>üéÆ 4. Handler Layer Pattern</h4>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <p><strong>Konsistensi yang Dicapai:</strong></p>
                        <ul>
                            <li>‚úÖ <strong>HTTP Handling</strong> - Penanganan HTTP request/response</li>
                            <li>‚úÖ <strong>Authentication</strong> - JWT token validation</li>
                            <li>‚úÖ <strong>Authorization</strong> - Role-based access control</li>
                            <li>‚úÖ <strong>Error Response</strong> - Format error response yang konsisten</li>
                        </ul>
                    </div>

                    <h3>üîí Keamanan yang Diimplementasikan</h3>
                    <p>Berikut adalah aspek keamanan yang konsisten diimplementasikan di semua modul:</p>

                    <div style="background: #fff3e0; border: 1px solid #ff9800; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #e65100; margin-bottom: 1rem;">üõ°Ô∏è Security Features</h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem;">
                            <div>
                                <h5 style="color: #f57c00;">üîê Authentication</h5>
                                <ul>
                                    <li>JWT Token Validation</li>
                                    <li>User ID Extraction</li>
                                    <li>Token Expiration Handling</li>
                                </ul>
                            </div>
                            <div>
                                <h5 style="color: #f57c00;">üëë Authorization</h5>
                                <ul>
                                    <li>Role-Based Access Control</li>
                                    <li>Admin-Only Endpoints</li>
                                    <li>User Self-Service</li>
                                </ul>
                            </div>
                            <div>
                                <h5 style="color: #f57c00;">üîí Data Protection</h5>
                                <ul>
                                    <li>Password Hashing (bcrypt)</li>
                                    <li>Input Validation</li>
                                    <li>SQL Injection Protection</li>
                                </ul>
                            </div>
                            <div>
                                <h5 style="color: #f57c00;">üìù Data Integrity</h5>
                                <ul>
                                    <li>Soft Delete Implementation</li>
                                    <li>Foreign Key Constraints</li>
                                    <li>Email Uniqueness</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <h3>üìä Database Schema yang Terintegrasi</h3>
                    <p>Berikut adalah relasi database yang telah dibangun:</p>

                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #2e7d32; margin-bottom: 1rem;">üóÑÔ∏è Database Relationships</h4>
                        <pre style="background: #f1f8e9; padding: 1rem; border-radius: 5px; overflow-x: auto;"><code>users (1) ‚îÄ‚îÄ‚Üí (N) transactions
users (1) ‚îÄ‚îÄ‚Üí (N) user_management (self-reference)

categories (1) ‚îÄ‚îÄ‚Üí (N) products
products (1) ‚îÄ‚îÄ‚Üí (N) transaction_details

transactions (1) ‚îÄ‚îÄ‚Üí (N) transaction_details
products (1) ‚îÄ‚îÄ‚Üí (N) transaction_details</code></pre>
                    </div>

                    <h3>üéØ Key Takeaways</h3>
                    <p>Berikut adalah poin-poin penting yang harus diingat:</p>

                    <div style="background: #e3f2fd; border: 1px solid #2196f3; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #1565c0; margin-bottom: 1rem;">üí° Learning Points</h4>
                        <ul>
                            <li>‚úÖ <strong>Consistent Architecture</strong> - Semua modul menggunakan pola yang sama</li>
                            <li>‚úÖ <strong>Separation of Concerns</strong> - Setiap layer memiliki tanggung jawab yang jelas</li>
                            <li>‚úÖ <strong>Security First</strong> - Keamanan diimplementasikan di setiap layer</li>
                            <li>‚úÖ <strong>Data Integrity</strong> - Relasi database yang solid dan konsisten</li>
                            <li>‚úÖ <strong>Error Handling</strong> - Penanganan error yang konsisten di seluruh sistem</li>
                            <li>‚úÖ <strong>Validation</strong> - Validasi input yang ketat di setiap endpoint</li>
                            <li>‚úÖ <strong>Role-Based Access</strong> - Sistem akses berdasarkan role yang jelas</li>
                            <li>‚úÖ <strong>Self-Service Features</strong> - User dapat mengelola profil mereka sendiri</li>
                        </ul>
                    </div>

                    <h3>üöÄ Persiapan untuk Modul Selanjutnya</h3>
                    <p>Dengan pengetahuan CRUD dan User Management yang solid, Anda sekarang siap untuk mempelajari modul-modul yang lebih advanced:</p>

                  
                    <h3>üßò Relaksasi dan Refleksi</h3>
                    <p>Sebelum melanjutkan ke modul selanjutnya, mari kita lakukan relaksasi sejenak:</p>

                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #2e7d32; margin-bottom: 1rem;">üå± Refleksi Pembelajaran</h4>
                        <p style="color: #388e3c; margin-bottom: 1rem;">Anda telah berhasil menguasai:</p>
                        <ul style="color: #388e3c;">
                            <li>‚úÖ <strong>5 Modul CRUD Lengkap</strong> - Kategori, Product, User, Transaction, Profile</li>
                            <li>‚úÖ <strong>Role-Based Access Control</strong> - Admin dan User permissions</li>
                            <li>‚úÖ <strong>Database Relationships</strong> - Foreign keys dan relasi antar tabel</li>
                            <li>‚úÖ <strong>Security Implementation</strong> - Authentication, authorization, data protection</li>
                            <li>‚úÖ <strong>Consistent Architecture</strong> - Pattern yang sama di semua modul</li>
                        </ul>
                        <p style="color: #2e7d32; margin-top: 1rem; font-style: italic;">"Konsistensi adalah kunci dari arsitektur yang baik. Dengan pola yang sama, kita dapat membangun sistem yang mudah dipahami, di-maintain, dan di-scale."</p>
                    </div>

                    <div style="background: #d4edda; border: 1px solid #c3e6cb; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #155724; margin-bottom: 1rem;">üéâ Selamat! Modul CRUD & User Management Selesai!</h3>
                        <p style="color: #155724; margin-bottom: 0;">Dengan penguasaan modul CRUD dan User Management yang solid, Anda sekarang memiliki fondasi yang kuat untuk membangun aplikasi web yang kompleks. Semua pola dan konsep yang dipelajari akan menjadi dasar untuk modul-modul advanced selanjutnya.</p>
                    </div>
                `
            },
            {
                id: 'chapter-16',
                title: 'Bab 16: Public Category API - Customer Endpoint',
                meta: 'Halaman 17 dari 55 ‚Ä¢ Dibaca 15 menit',
                content: `
                    <h2>üåê Bab 16: Public Category API - Customer Endpoint</h2>
                    <p>Selamat! Sekarang kita akan membuat API public untuk kategori yang dapat diakses oleh customer tanpa authentication. Di bab ini, kita akan mengimplementasikan endpoint public untuk mendapatkan daftar kategori dan detail kategori yang dapat digunakan oleh aplikasi frontend customer.</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">üéØ Apa yang Akan Kita Buat di Bab Ini?</h3>
                        <p style="color: #495057; margin-bottom: 0;">Kita akan membuat endpoint public untuk kategori yang dapat diakses tanpa authentication. Endpoint ini akan digunakan oleh customer untuk melihat daftar kategori dan detail kategori. Kita akan menggunakan pattern yang sama dengan endpoint admin, tetapi tanpa middleware authentication.</p>
                    </div>

                    <h3>üìã Prasyarat</h3>
                    <p>Sebelum memulai, pastikan Anda sudah menyelesaikan:</p>
                    <ul>
                        <li>‚úÖ Bab 10: Modul CRUD Kategori - Role Admin</li>
                        <li>‚úÖ Bab 11: Modul CRUD Product - Role Admin</li>
                        <li>‚úÖ Bab 12: Modul User Management - Role Admin</li>
                        <li>‚úÖ Bab 13: Modul Transaction Management - Role Admin</li>
                        <li>‚úÖ Bab 14: Modul Profile & Password - User Management</li>
                        <li>‚úÖ Bab 15: Review Pembelajaran CRUD & User Management</li>
                        <li>‚úÖ Handler, Service, dan Repository Category sudah ada</li>
                        <li>‚úÖ Model Category sudah ada dan berfungsi</li>
                        <li>‚úÖ Tabel categories sudah ada di database</li>
                    </ul>

                    <h3>üóÑÔ∏è Database Schema</h3>
                    <p>Kita akan menggunakan tabel categories yang sudah ada. Berikut adalah schema yang akan kita gunakan:</p>

                    <h4>üìä Tabel Categories (Sudah Ada)</h4>
                    <pre><code>CREATE TABLE categories (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255) NOT NULL,
    slug VARCHAR(255) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL
);</code></pre>

                    <h3>üèóÔ∏è Struktur Endpoint yang Akan Dibuat</h3>
                    <p>Kita akan membuat endpoint public untuk kategori dengan struktur berikut:</p>
                    <ul>
                        <li><code>GET /api/v1/public/categories</code> - Ambil semua kategori (dengan pagination)</li>
                    </ul>

                    <div style="background: #e3f2fd; border: 1px solid #2196f3; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #1565c0; margin-bottom: 1rem;">üí° Mengapa Public Endpoint?</h4>
                        <ul>
                            <li><strong>Customer Access:</strong> Customer perlu melihat kategori untuk browsing produk</li>
                            <li><strong>No Authentication:</strong> Tidak perlu login untuk melihat kategori</li>
                            <li><strong>Performance:</strong> Endpoint yang cepat tanpa overhead authentication</li>
                            <li><strong>SEO Friendly:</strong> Dapat di-crawl oleh search engine</li>
                            <li><strong>Mobile App:</strong> Mudah diakses oleh aplikasi mobile</li>
                        </ul>
                        <p style="color: #1565c0; margin-bottom: 0;"><strong>üí° Keuntungan:</strong> Public endpoint memungkinkan customer untuk mengakses informasi kategori tanpa perlu login, meningkatkan user experience dan memudahkan integrasi dengan frontend aplikasi.</p>
                    </div>

                    <h3>üîß 1. Update Main.go untuk Public Routes</h3>
                    <p>Kita akan menambahkan public routes untuk kategori di file <code>main.go</code>:</p>
                    
                    <pre><code>// Public routes (tidak perlu authentication)
api := r.Group("/api/v1")
{
    // Auth routes
    auth := api.Group("/auth")
    {
        auth.POST("/register", authHandler.Register)
        auth.POST("/login", authHandler.Login)
    }

    // Public category routes (untuk customer)
    public := api.Group("/public")
    {
        categories := public.Group("/categories")
        {
            categories.GET("", categoryHandler.GetAllCategories)
        }
    }
}</code></pre>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; border-radius: 5px; margin: 1.5rem 0;">
                        <h4 style="color: #2c3e50; margin-bottom: 1rem;">üí° Penjelasan Public Routes</h4>
                        <ul>
                            <li><strong>Public Group:</strong> Route group <code>/api/v1/public</code> untuk endpoint yang tidak perlu authentication</li>
                            <li><strong>Categories Group:</strong> Sub-group <code>/categories</code> untuk endpoint kategori</li>
                            <li><strong>Reuse Handlers:</strong> Menggunakan handler yang sama dengan admin endpoint</li>
                            <li><strong>No Middleware:</strong> Tidak menggunakan AuthMiddleware atau AdminMiddleware</li>
                        </ul>
                        <p><strong>Endpoint yang Tersedia:</strong></p>
                        <ul>
                            <li><strong>GET /api/v1/public/categories</strong> - List semua kategori dengan pagination</li>
                        </ul>
                        <p><strong>Keamanan:</strong></p>
                        <ul>
                            <li><strong>Read-Only Access:</strong> Hanya GET endpoint yang tersedia</li>
                            <li><strong>No Sensitive Data:</strong> Tidak mengembalikan data sensitif</li>
                            <li><strong>Public Information:</strong> Kategori adalah informasi publik yang aman</li>
                        </ul>
                        <p style="color: #495057; margin-bottom: 0;"><strong>üí° Keuntungan:</strong> Dengan menggunakan handler yang sama, kita memastikan konsistensi response format dan business logic, sambil memberikan akses publik yang aman untuk customer.</p>
                    </div>

                    <h3>üß™ 2. Testing dengan Postman</h3>
                    <p>Sekarang kita akan test semua endpoint public category menggunakan Postman:</p>

                    <h4>üìã Test Cases untuk Public Category API</h4>
                    <ol>
                        <li><strong>GET /api/v1/public/categories</strong> - Ambil semua kategori dengan pagination</li>
                    </ol>

                    <h4>üîì Headers yang Diperlukan:</h4>
                    <p>Endpoint public tidak memerlukan header authentication:</p>
                    <ul>
                        <li><code>Content-Type: application/json</code> (opsional untuk GET request)</li>
                    </ul>

                    <h4>üìä Contoh Response:</h4>
                    
                    <h5>Get All Categories (Public):</h5>
                    <pre><code>{
    "message": "Categories retrieved successfully",
    "data": {
        "categories": [
            {
                "id": 1,
                "name": "Electronics",
                "slug": "electronics",
                "created_at": "2024-01-01 10:00:00",
                "updated_at": "2024-01-01 10:00:00"
            },
            {
                "id": 2,
                "name": "Clothing",
                "slug": "clothing",
                "created_at": "2024-01-01 10:00:00",
                "updated_at": "2024-01-01 10:00:00"
            }
        ],
        "total": 2,
        "page": 1,
        "limit": 10
    }
}</code></pre>


                    <h3>üéØ Fitur-fitur Public Category API:</h3>
                    <ul>
                        <li>‚úÖ <strong>List Categories</strong> - Customer dapat melihat semua kategori dengan pagination</li>
                        <li>‚úÖ <strong>Pagination Support</strong> - Mendukung pagination untuk performa yang baik</li>
                        <li>‚úÖ <strong>No Authentication</strong> - Tidak perlu login untuk mengakses</li>
                        <li>‚úÖ <strong>Consistent Response</strong> - Format response yang konsisten dengan admin API</li>
                        <li>‚úÖ <strong>Error Handling</strong> - Error handling yang komprehensif</li>
                        <li>‚úÖ <strong>Public Access</strong> - Dapat diakses oleh siapa saja</li>
                    </ul>

                    <h3>üîí Security Features:</h3>
                    <ul>
                        <li>‚úÖ <strong>Read-Only Access</strong> - Hanya GET endpoint yang tersedia</li>
                        <li>‚úÖ <strong>No Sensitive Data</strong> - Tidak mengembalikan data sensitif</li>
                        <li>‚úÖ <strong>Public Information</strong> - Kategori adalah informasi publik yang aman</li>
                        <li>‚úÖ <strong>Input Validation</strong> - Validasi input ID dan parameter</li>
                        <li>‚úÖ <strong>SQL Injection Protection</strong> - Menggunakan prepared statements</li>
                    </ul>

                    <h3>üìä Database Schema yang Digunakan:</h3>
                    <ul>
                        <li>‚úÖ <strong>Categories Table</strong> - Menggunakan tabel categories yang sudah ada</li>
                        <li>‚úÖ <strong>No Additional Tables</strong> - Tidak memerlukan tabel tambahan</li>
                        <li>‚úÖ <strong>Existing Relationships</strong> - Menggunakan relasi yang sudah ada</li>
                        <li>‚úÖ <strong>Optimized Queries</strong> - Query yang sudah dioptimasi</li>
                    </ul>

                    <h3>üîÑ Perbandingan Admin vs Public API:</h3>
                    
                    <div style="background: #fff3cd; border: 1px solid #ffeaa7; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #856404; margin-bottom: 1rem;">üìä Tabel Perbandingan</h4>
                        <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                            <thead>
                                <tr style="background: #f8f9fa;">
                                    <th style="border: 1px solid #dee2e6; padding: 0.75rem; text-align: left;">Fitur</th>
                                    <th style="border: 1px solid #dee2e6; padding: 0.75rem; text-align: left;">Admin API</th>
                                    <th style="border: 1px solid #dee2e6; padding: 0.75rem; text-align: left;">Public API</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;"><strong>Authentication</strong></td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">‚úÖ Required (JWT)</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">‚ùå Not Required</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;"><strong>Authorization</strong></td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">‚úÖ Admin Role</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">‚ùå Public Access</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;"><strong>GET Categories</strong></td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">‚úÖ Available</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">‚úÖ Available</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;"><strong>GET Category Detail</strong></td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">‚úÖ Available</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">‚ùå Not Available</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;"><strong>POST Category</strong></td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">‚úÖ Available</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">‚ùå Not Available</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;"><strong>PUT Category</strong></td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">‚úÖ Available</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">‚ùå Not Available</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;"><strong>DELETE Category</strong></td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">‚úÖ Available</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">‚ùå Not Available</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;"><strong>Response Format</strong></td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">‚úÖ Consistent</td>
                                    <td style="border: 1px solid #dee2e6; padding: 0.75rem;">‚úÖ Consistent</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <h3>üöÄ Use Cases untuk Public Category API:</h3>
                    <ul>
                        <li>‚úÖ <strong>E-commerce Frontend</strong> - Menampilkan kategori di halaman utama</li>
                        <li>‚úÖ <strong>Mobile App</strong> - Aplikasi mobile customer</li>
                        <li>‚úÖ <strong>Search Engine</strong> - Dapat di-crawl oleh search engine</li>
                        <li>‚úÖ <strong>Third-party Integration</strong> - Integrasi dengan aplikasi lain</li>
                        <li>‚úÖ <strong>Public Website</strong> - Website publik tanpa login</li>
                        <li>‚úÖ <strong>API Documentation</strong> - Dokumentasi API yang dapat diakses publik</li>
                    </ul>

                    <h3>üìù 3. Update Postman Collection</h3>
                    <p>Tambahkan endpoint public category ke Postman collection untuk testing:</p>
                    
                    <h4>üìã Postman Collection Structure:</h4>
                    <pre><code>Tokogo API Collection
‚îú‚îÄ‚îÄ Authentication
‚îÇ   ‚îú‚îÄ‚îÄ Register
‚îÇ   ‚îú‚îÄ‚îÄ Login
‚îÇ   ‚îî‚îÄ‚îÄ Logout
‚îú‚îÄ‚îÄ Admin
‚îÇ   ‚îú‚îÄ‚îÄ Categories (CRUD)
‚îÇ   ‚îú‚îÄ‚îÄ Products (CRUD)
‚îÇ   ‚îú‚îÄ‚îÄ Users (CRUD)
‚îÇ   ‚îî‚îÄ‚îÄ Transactions (Read/Update)
‚îú‚îÄ‚îÄ Public
‚îÇ   ‚îî‚îÄ‚îÄ Categories (Read Only)
‚îÇ       ‚îî‚îÄ‚îÄ Get All Categories
‚îî‚îÄ‚îÄ User
    ‚îú‚îÄ‚îÄ Profile
    ‚îî‚îÄ‚îÄ Change Password</code></pre>

                    <h4>üîß Environment Variables:</h4>
                    <p>Buat environment variables untuk Postman:</p>
                    <ul>
                        <li><code>base_url</code> - http://localhost:8080</li>
                        <li><code>api_version</code> - /api/v1</li>
                        <li><code>jwt_token</code> - (akan diisi setelah login)</li>
                    </ul>

                    <h3>‚úÖ Checklist Implementasi</h3>
                    <p>Pastikan Anda telah menyelesaikan semua langkah berikut:</p>
                    <ul>
                        <li>‚úÖ Menambahkan public routes di main.go</li>
                        <li>‚úÖ Test endpoint GET /api/v1/public/categories</li>
                        <li>‚úÖ Verifikasi response format konsisten</li>
                        <li>‚úÖ Test pagination pada list categories</li>
                        <li>‚úÖ Update Postman collection</li>
                        <li>‚úÖ Dokumentasi endpoint untuk frontend team</li>
                    </ul>

                    <h3>üéØ Best Practices untuk Public API:</h3>
                    <ul>
                        <li>‚úÖ <strong>Rate Limiting</strong> - Implementasi rate limiting untuk mencegah abuse</li>
                        <li>‚úÖ <strong>Caching</strong> - Cache response untuk performa yang lebih baik</li>
                        <li>‚úÖ <strong>API Versioning</strong> - Gunakan versioning untuk backward compatibility</li>
                        <li>‚úÖ <strong>Documentation</strong> - Dokumentasi yang jelas untuk developer</li>
                        <li>‚úÖ <strong>Monitoring</strong> - Monitor usage dan performance</li>
                        <li>‚úÖ <strong>Error Handling</strong> - Error messages yang user-friendly</li>
                    </ul>

                    <div style="background: #d4edda; border: 1px solid #c3e6cb; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #155724; margin-bottom: 1rem;">üéâ Selamat! Public Category API Selesai!</h3>
                        <p style="color: #155724; margin-bottom: 0;">Dengan implementasi Public Category API, customer sekarang dapat mengakses informasi kategori tanpa perlu login. API ini menyediakan akses yang aman dan efisien untuk informasi publik, sambil mempertahankan keamanan untuk operasi yang memerlukan authentication.</p>
                    </div>

                    <h3>üöÄ Persiapan untuk Modul Selanjutnya</h3>
                    <p>Dengan pengetahuan Public API yang solid, Anda sekarang siap untuk mempelajari modul-modul yang lebih advanced:</p>
                    <ul>
                        <li>‚úÖ <strong>Public Product API</strong> - API publik untuk produk</li>
                        <li>‚úÖ <strong>Search & Filter API</strong> - API untuk pencarian dan filter</li>
                        <li>‚úÖ <strong>File Upload API</strong> - API untuk upload file</li>
                        <li>‚úÖ <strong>Email Service API</strong> - API untuk mengirim email</li>
                        <li>‚úÖ <strong>Payment Gateway Integration</strong> - Integrasi payment gateway</li>
                    </ul>

                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #2e7d32; margin-bottom: 1rem;">üå± Refleksi Pembelajaran</h4>
                        <p style="color: #388e3c; margin-bottom: 1rem;">Anda telah berhasil menguasai:</p>
                        <ul style="color: #388e3c;">
                            <li>‚úÖ <strong>Public API Design</strong> - Desain API yang aman untuk akses publik</li>
                            <li>‚úÖ <strong>Route Organization</strong> - Organisasi route yang baik</li>
                            <li>‚úÖ <strong>Security Considerations</strong> - Pertimbangan keamanan untuk public endpoint</li>
                            <li>‚úÖ <strong>Consistent Response Format</strong> - Format response yang konsisten</li>
                            <li>‚úÖ <strong>API Documentation</strong> - Dokumentasi API yang baik</li>
                        </ul>
                        <p style="color: #2e7d32; margin-top: 1rem; font-style: italic;">"Public API yang baik adalah API yang aman, cepat, dan mudah digunakan. Dengan desain yang tepat, kita dapat memberikan akses yang luas sambil mempertahankan keamanan sistem."</p>
                    </div>
                `
            },
            {
                id: 'chapter17',
                title: 'Bab 17: Public Product API - Akses Data Produk untuk Customer',
                meta: 'Halaman 18 dari 55 ‚Ä¢ Dibaca 15 menit',
                content: `
                    <h2>üõçÔ∏è Bab 17: Public Product API - Akses Data Produk untuk Customer</h2>
                    <p>Selamat! Sekarang kita akan membuat Public Product API yang memungkinkan customer untuk mengakses data produk tanpa perlu authentication. Di bab ini, kita akan mengimplementasikan endpoint public untuk melihat daftar produk, detail produk, dan produk berdasarkan kategori.</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">üéØ Apa yang Akan Kita Buat di Bab Ini?</h3>
                        <p style="color: #495057; margin-bottom: 0;">Kita akan membuat Public Product API yang aman dengan fitur melihat daftar produk, detail produk, dan produk berdasarkan kategori. API ini tidak memerlukan authentication dan tidak menampilkan informasi sensitif seperti harga beli (purchase_price).</p>
                    </div>

                    <h3>üìã Prasyarat</h3>
                    <p>Sebelum memulai, pastikan Anda sudah menyelesaikan:</p>
                    <ul>
                        <li>‚úÖ Bab 6-8: Modul Authentication (Register, Login, Logout)</li>
                        <li>‚úÖ Bab 10: Modul CRUD Kategori - Role Admin</li>
                        <li>‚úÖ Bab 11: Modul CRUD Product - Role Admin</li>
                        <li>‚úÖ Tabel products dan categories sudah ada di database</li>
                        <li>‚úÖ Ada data produk yang sudah dibuat</li>
                    </ul>

                    <h3>üîí Keamanan Public API</h3>
                    <p>Public API memiliki pertimbangan keamanan khusus:</p>
                    <ul>
                        <li>‚úÖ <strong>Tidak menampilkan informasi sensitif</strong> - Harga beli (purchase_price) disembunyikan</li>
                        <li>‚úÖ <strong>Read-only access</strong> - Hanya GET operations yang diizinkan</li>
                        <li>‚úÖ <strong>No authentication required</strong> - Customer dapat mengakses tanpa login</li>
                        <li>‚úÖ <strong>Rate limiting ready</strong> - Siap untuk implementasi rate limiting</li>
                    </ul>

                    <h3>üèóÔ∏è Struktur Endpoint yang Akan Dibuat</h3>
                    <p>Kita akan membuat endpoint-endpoint berikut:</p>
                    <ul>
                        <li><code>GET /api/v1/public/products</code> - Mendapatkan daftar semua produk</li>
                        <li><code>GET /api/v1/public/products/{id}</code> - Mendapatkan detail produk berdasarkan ID</li>
                        <li><code>GET /api/v1/public/products/categories/{category_id}</code> - Mendapatkan produk berdasarkan kategori</li>
                    </ul>

                    <h3>üìù 1. Menambahkan Public Routes ke main.go</h3>
                    <p>Pertama, kita tambahkan public routes untuk produk di file <code>main.go</code>:</p>
                    
                    <pre><code>// Public routes (untuk customer)
public := api.Group("/public")
{
    categories := public.Group("/categories")
    {
        categories.GET("", categoryHandler.GetAllCategories)
    }
    
    products := public.Group("/products")
    {
        products.GET("", productHandler.GetAllProductsPublic)
        products.GET("/:id", productHandler.GetProductByIDPublic)
        products.GET("/categories/:category_id", productHandler.GetProductsByCategoryPublic)
    }
}</code></pre>

                    <div style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 1rem; margin: 2rem 0;">
                        <strong>üí° Penjelasan:</strong> Public routes ditempatkan di luar middleware authentication, sehingga customer dapat mengakses tanpa perlu login.
                    </div>

                    <h3>üìù 2. Membuat Public Product Response</h3>
                    <p>Kita buat response struct khusus untuk public API di file <code>responses/product_response.go</code>:</p>
                    
                    <pre><code>// PublicProductResponse untuk response public (tanpa purchase_price)
type PublicProductResponse struct {
    ID           uint    \`json:"id"\`
    Name         string  \`json:"name"\`
    Description  string  \`json:"description"\`
    SellingPrice float64 \`json:"selling_price"\`
    Stock        int     \`json:"stock"\`
    CategoryID   uint    \`json:"category_id"\`
    CategoryName string  \`json:"category_name"\`
    ImagePath    string  \`json:"image_url"\`
    CreatedAt    string  \`json:"created_at"\`
    UpdatedAt    string  \`json:"updated_at"\`
}

type PublicProductListResponse struct {
    Products []PublicProductResponse \`json:"products"\`
    Total    int64                   \`json:"total"\`
    Page     int                     \`json:"page"\`
    Limit    int                     \`json:"limit"\`
}

func ConvertProductToPublicResponse(product models.Product) PublicProductResponse {
    return PublicProductResponse{
        ID:           product.ID,
        Name:         product.Name,
        Description:  product.Description,
        SellingPrice: product.SellingPrice,
        Stock:        product.Stock,
        CategoryID:   product.CategoryID,
        CategoryName: product.Category.Name,
        ImagePath:    product.ImageURL,
        CreatedAt:    product.CreatedAt.Format("2006-01-02 15:04:05"),
        UpdatedAt:    product.UpdatedAt.Format("2006-01-02 15:04:05"),
    }
}

func ConvertProductsToPublicResponse(products []models.Product) []PublicProductResponse {
    var responses []PublicProductResponse
    for _, product := range products {
        responses = append(responses, ConvertProductToPublicResponse(product))
    }
    return responses
}</code></pre>

                    <div style="background: #d1ecf1; border-left: 4px solid #17a2b8; padding: 1rem; margin: 2rem 0;">
                        <strong>üîç Perbedaan dengan Admin Response:</strong> PublicProductResponse tidak menyertakan field <code>purchase_price</code> untuk menjaga kerahasiaan harga beli.
                    </div>

                    <h3>üìù 3. Menambahkan Public Handler Methods</h3>
                    <p>Kita tambahkan handler methods untuk public API di file <code>handlers/product_handler.go</code>:</p>
                    
                    <pre><code>// GetAllProductsPublic godoc
// @Summary Get all products (Public)
// @Description Get all products with pagination (Public access - no authentication required)
// @Tags Public Products
// @Produce json
// @Param page query int false "Page number" default(1)
// @Param limit query int false "Items per page" default(10)
// @Success 200 {object} responses.PublicProductListResponse
// @Router /api/v1/public/products [get]
func (h *ProductHandler) GetAllProductsPublic(c *gin.Context) {
    page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
    limit, _ := strconv.Atoi(c.DefaultQuery("limit", "10"))

    products, err := h.productService.GetAllProductsPublic(page, limit)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusOK, products)
}

// GetProductByIDPublic godoc
// @Summary Get product by ID (Public)
// @Description Get a specific product by ID (Public access - no authentication required)
// @Tags Public Products
// @Produce json
// @Param id path int true "Product ID"
// @Success 200 {object} responses.PublicProductResponse
// @Failure 400 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /api/v1/public/products/{id} [get]
func (h *ProductHandler) GetProductByIDPublic(c *gin.Context) {
    id, err := strconv.ParseUint(c.Param("id"), 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid product ID"})
        return
    }

    product, err := h.productService.GetProductByIDPublic(uint(id))
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": "Product not found"})
        return
    }

    c.JSON(http.StatusOK, product)
}

// GetProductsByCategoryPublic godoc
// @Summary Get products by category (Public)
// @Description Get products by category ID with pagination (Public access - no authentication required)
// @Tags Public Products
// @Produce json
// @Param category_id path int true "Category ID"
// @Param page query int false "Page number" default(1)
// @Param limit query int false "Items per page" default(10)
// @Success 200 {object} responses.PublicProductListResponse
// @Failure 400 {object} map[string]string
// @Router /api/v1/public/products/categories/{category_id} [get]
func (h *ProductHandler) GetProductsByCategoryPublic(c *gin.Context) {
    categoryID, err := strconv.ParseUint(c.Param("category_id"), 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid category ID"})
        return
    }

    page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
    limit, _ := strconv.Atoi(c.DefaultQuery("limit", "10"))

    products, err := h.productService.GetProductsByCategoryPublic(uint(categoryID), page, limit)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusOK, products)
}</code></pre>

                    <h3>üìù 4. Menambahkan Public Service Methods</h3>
                    <p>Kita tambahkan service methods untuk public API di file <code>services/product_service.go</code>:</p>
                    
                    <pre><code>// Public methods (tanpa purchase_price)
func (s *ProductService) GetAllProductsPublic(page, limit int) (*responses.PublicProductListResponse, error) {
    if page < 1 {
        page = 1
    }
    if limit < 1 {
        limit = 10
    }

    products, total, err := s.productRepo.GetAll(page, limit)
    if err != nil {
        return nil, err
    }

    productResponses := responses.ConvertProductsToPublicResponse(products)

    return &responses.PublicProductListResponse{
        Products: productResponses,
        Total:    total,
        Page:     page,
        Limit:    limit,
    }, nil
}

func (s *ProductService) GetProductByIDPublic(id uint) (*responses.PublicProductResponse, error) {
    product, err := s.productRepo.GetByID(id)
    if err != nil {
        return nil, err
    }

    response := responses.ConvertProductToPublicResponse(*product)
    return &response, nil
}

func (s *ProductService) GetProductsByCategoryPublic(categoryID uint, page, limit int) (*responses.PublicProductListResponse, error) {
    if page < 1 {
        page = 1
    }
    if limit < 1 {
        limit = 10
    }

    products, total, err := s.productRepo.GetByCategoryID(categoryID, page, limit)
    if err != nil {
        return nil, err
    }

    productResponses := responses.ConvertProductsToPublicResponse(products)

    return &responses.PublicProductListResponse{
        Products: productResponses,
        Total:    total,
        Page:     page,
        Limit:    limit,
    }, nil
}</code></pre>

                    <h3>üß™ Testing Public Product API</h3>
                    <p>Sekarang kita test API yang sudah dibuat menggunakan Postman atau curl:</p>

                    <h4>1. Test Get All Products (Public)</h4>
                    <pre><code>GET http://localhost:8080/api/v1/public/products
GET http://localhost:8080/api/v1/public/products?page=1&limit=5</code></pre>

                    <h4>2. Test Get Product by ID (Public)</h4>
                    <pre><code>GET http://localhost:8080/api/v1/public/products/1</code></pre>

                    <h4>3. Test Get Products by Category (Public)</h4>
                    <pre><code>GET http://localhost:8080/api/v1/public/products/categories/1
GET http://localhost:8080/api/v1/public/products/categories/1?page=1&limit=3</code></pre>

                    <h4>4. Expected Response Format</h4>
                    <pre><code>{
    "products": [
        {
            "id": 1,
            "name": "Laptop Gaming",
            "description": "Laptop gaming dengan performa tinggi",
            "selling_price": 15000000,
            "stock": 10,
            "category_id": 1,
            "category_name": "Electronics",
            "image_url": "/uploads/products/laptop.jpg",
            "created_at": "2024-01-15 10:30:00",
            "updated_at": "2024-01-15 10:30:00"
        }
    ],
    "total": 1,
    "page": 1,
    "limit": 10
}</code></pre>

                    <div style="background: #d4edda; border: 1px solid #c3e6cb; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #155724; margin-bottom: 1rem;">üéâ Selamat! Public Product API Selesai!</h3>
                        <p style="color: #155724; margin-bottom: 0;">Dengan Public Product API yang lengkap, customer sekarang dapat mengakses data produk tanpa perlu authentication, sambil tetap menjaga keamanan informasi sensitif!</p>
                    </div>

                    <h3>üîç Perbandingan Admin vs Public API</h3>
                    <table style="width: 100%; border-collapse: collapse; margin: 2rem 0;">
                        <thead>
                            <tr style="background: #f8f9fa;">
                                <th style="border: 1px solid #dee2e6; padding: 1rem; text-align: left;">Aspek</th>
                                <th style="border: 1px solid #dee2e6; padding: 1rem; text-align: left;">Admin API</th>
                                <th style="border: 1px solid #dee2e6; padding: 1rem; text-align: left;">Public API</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td style="border: 1px solid #dee2e6; padding: 1rem;"><strong>Authentication</strong></td>
                                <td style="border: 1px solid #dee2e6; padding: 1rem;">Required (JWT Token)</td>
                                <td style="border: 1px solid #dee2e6; padding: 1rem;">Not Required</td>
                            </tr>
                            <tr style="background: #f8f9fa;">
                                <td style="border: 1px solid #dee2e6; padding: 1rem;"><strong>Purchase Price</strong></td>
                                <td style="border: 1px solid #dee2e6; padding: 1rem;">‚úÖ Included</td>
                                <td style="border: 1px solid #dee2e6; padding: 1rem;">‚ùå Hidden</td>
                            </tr>
                            <tr>
                                <td style="border: 1px solid #dee2e6; padding: 1rem;"><strong>Operations</strong></td>
                                <td style="border: 1px solid #dee2e6; padding: 1rem;">CRUD (Create, Read, Update, Delete)</td>
                                <td style="border: 1px solid #dee2e6; padding: 1rem;">Read Only</td>
                            </tr>
                            <tr style="background: #f8f9fa;">
                                <td style="border: 1px solid #dee2e6; padding: 1rem;"><strong>Access Level</strong></td>
                                <td style="border: 1px solid #dee2e6; padding: 1rem;">Admin Only</td>
                                <td style="border: 1px solid #dee2e6; padding: 1rem;">Public</td>
                            </tr>
                        </tbody>
                    </table>

                    <h3>üöÄ Langkah Selanjutnya</h3>
                    <p>Dengan Public Product API yang sudah selesai, Anda dapat:</p>
                    <ul>
                        <li>‚úÖ <strong>Integrate dengan Frontend</strong> - Gunakan API ini untuk menampilkan produk di website customer</li>
                        <li>‚úÖ <strong>Mobile App Integration</strong> - API ini siap untuk diintegrasikan dengan aplikasi mobile</li>
                        <li>‚úÖ <strong>Third-party Integration</strong> - API ini dapat digunakan oleh partner atau affiliate</li>
                        <li>‚úÖ <strong>Add Search & Filter</strong> - Tambahkan fitur pencarian dan filter produk</li>
                        <li>‚úÖ <strong>Implement Caching</strong> - Tambahkan caching untuk meningkatkan performa</li>
                    </ul>

                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #2e7d32; margin-bottom: 1rem;">üå± Refleksi Pembelajaran</h4>
                        <p style="color: #388e3c; margin-bottom: 1rem;">Anda telah berhasil menguasai:</p>
                        <ul style="color: #388e3c;">
                            <li>‚úÖ <strong>Public API Design</strong> - Desain API yang aman untuk akses publik</li>
                            <li>‚úÖ <strong>Security Best Practices</strong> - Menyembunyikan informasi sensitif</li>
                            <li>‚úÖ <strong>Response Structure</strong> - Struktur response yang berbeda untuk admin dan public</li>
                            <li>‚úÖ <strong>Route Organization</strong> - Organisasi route yang baik</li>
                            <li>‚úÖ <strong>API Documentation</strong> - Dokumentasi API yang lengkap</li>
                        </ul>
                        <p style="color: #2e7d32; margin-top: 1rem; font-style: italic;">"Public API yang baik adalah API yang memberikan akses yang mudah sambil menjaga keamanan data sensitif. Dengan desain yang tepat, kita dapat melayani customer dengan baik tanpa mengorbankan keamanan bisnis."</p>
                    </div>
                `
            },
            {
                id: 'chapter18',
                title: 'Bab 18: Cart Management API - CRUD Keranjang Belanja untuk Customer',
                meta: 'Halaman 19 dari 55 ‚Ä¢ Dibaca 20 menit',
                content: `
                    <h2>üõí Bab 18: Cart Management API - CRUD Keranjang Belanja untuk Customer</h2>
                    <p>Selamat! Sekarang kita akan membuat Cart Management API yang memungkinkan customer untuk mengelola keranjang belanja mereka. Di bab ini, kita akan mengimplementasikan sistem keranjang belanja lengkap dengan fitur add to cart, view cart, update quantity, remove item, dan clear cart.</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">üéØ Apa yang Akan Kita Buat di Bab Ini?</h3>
                        <p style="color: #495057; margin-bottom: 0;">Kita akan membuat Cart Management API yang lengkap dengan fitur CRUD (Create, Read, Update, Delete) untuk keranjang belanja. Customer dapat menambah produk ke keranjang, melihat isi keranjang, mengupdate jumlah produk, menghapus item, dan mengosongkan keranjang. Semua operasi memerlukan authentication.</p>
                    </div>

                    <h3>üìã Prasyarat</h3>
                    <p>Sebelum memulai, pastikan Anda sudah menyelesaikan:</p>
                    <ul>
                        <li>‚úÖ Bab 6-8: Modul Authentication (Register, Login, Logout)</li>
                        <li>‚úÖ Bab 11: Modul CRUD Product - Role Admin</li>
                        <li>‚úÖ Bab 17: Public Product API</li>
                        <li>‚úÖ Tabel users dan products sudah ada di database</li>
                        <li>‚úÖ Ada data produk yang sudah dibuat</li>
                        <li>‚úÖ User sudah bisa login dan mendapat JWT token</li>
                    </ul>

                    <h3>üóÑÔ∏è Database Schema</h3>
                    <p>Sebelum memulai, kita perlu membuat tabel untuk cart. Berikut adalah schema database yang akan kita gunakan:</p>

                    <h4>üìä Tabel Carts</h4>
                    <pre><code>CREATE TABLE carts (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,
    quantity INT NOT NULL DEFAULT 1,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE,
    UNIQUE KEY unique_user_product (user_id, product_id)
);</code></pre>

                    <div style="background: #d1ecf1; border-left: 4px solid #17a2b8; padding: 1rem; margin: 2rem 0;">
                        <strong>üîç Catatan Penting:</strong> Unique constraint pada (user_id, product_id) memastikan setiap user hanya bisa memiliki satu record per produk di keranjang. Jika user menambah produk yang sama, quantity akan diupdate.
                    </div>

                    <h3>üèóÔ∏è Struktur File yang Akan Dibuat</h3>
                    <p>Kita akan membuat file-file berikut untuk modul Cart Management:</p>
                    <ul>
                        <li><code>models/cart.go</code> - Model Cart</li>
                        <li><code>requests/cart_request.go</code> - Request structs untuk cart operations</li>
                        <li><code>responses/cart_response.go</code> - Response structs untuk cart data</li>
                        <li><code>repositories/cart_repository.go</code> - Repository layer untuk cart operations</li>
                        <li><code>services/cart_service.go</code> - Service layer untuk cart business logic</li>
                        <li><code>handlers/cart_handler.go</code> - Handler layer untuk cart HTTP endpoints</li>
                    </ul>

                    <h3>üìù 1. Membuat Model Cart</h3>
                    <p>Pertama, kita buat model Cart di file <code>models/cart.go</code>:</p>
                    
                    <pre><code>package models

import "time"

type Cart struct {
    ID        uint      \`json:"id" gorm:"primaryKey"\`
    UserID    uint      \`json:"user_id" gorm:"not null"\`
    User      User      \`json:"user" gorm:"foreignKey:UserID"\`
    ProductID uint      \`json:"product_id" gorm:"not null"\`
    Product   Product   \`json:"product" gorm:"foreignKey:ProductID"\`
    Quantity  int       \`json:"quantity" gorm:"not null;default:1"\`
    CreatedAt time.Time \`json:"created_at"\`
    UpdatedAt time.Time \`json:"updated_at"\`
}

func (Cart) TableName() string {
    return "carts"
}</code></pre>

                    <div style="background: #e8f4fd; border-left: 4px solid #2196f3; padding: 1.5rem; margin: 2rem 0;">
                        <h4 style="color: #1976d2; margin-bottom: 1rem;">üîç Penjelasan Model Cart</h4>
                        <p style="color: #1565c0; margin-bottom: 1rem;"><strong>Struktur Field:</strong></p>
                        <ul style="color: #1565c0; margin-bottom: 1rem;">
                            <li><strong>ID</strong> - Primary key yang auto-increment untuk identifikasi unik setiap item cart</li>
                            <li><strong>UserID</strong> - Foreign key ke tabel users, menunjukkan siapa pemilik cart item ini</li>
                            <li><strong>User</strong> - Relasi GORM ke model User untuk mendapatkan data user lengkap</li>
                            <li><strong>ProductID</strong> - Foreign key ke tabel products, menunjukkan produk apa yang ada di cart</li>
                            <li><strong>Product</strong> - Relasi GORM ke model Product untuk mendapatkan detail produk</li>
                            <li><strong>Quantity</strong> - Jumlah produk yang ditambahkan ke cart (default: 1)</li>
                            <li><strong>CreatedAt/UpdatedAt</strong> - Timestamp untuk tracking kapan item dibuat dan diupdate</li>
                        </ul>
                        <p style="color: #1565c0; margin-bottom: 1rem;"><strong>GORM Tags:</strong></p>
                        <ul style="color: #1565c0;">
                            <li><code>gorm:"primaryKey"</code> - Menandai field sebagai primary key</li>
                            <li><code>gorm:"not null"</code> - Field wajib diisi, tidak boleh NULL</li>
                            <li><code>gorm:"default:1"</code> - Nilai default jika tidak diisi</li>
                            <li><code>gorm:"foreignKey:UserID"</code> - Menentukan foreign key untuk relasi</li>
                        </ul>
                    </div>

                    <h3>üìù 2. Membuat Request Structs</h3>
                    <p>Kita buat request structs untuk cart operations di file <code>requests/cart_request.go</code>:</p>
                    
                    <pre><code>package requests

import "errors"

type AddToCartRequest struct {
    ProductID uint \`json:"product_id" binding:"required"\`
    Quantity  int  \`json:"quantity" binding:"required,min=1"\`
}

func (r *AddToCartRequest) Validate() error {
    if r.ProductID == 0 {
        return errors.New("product_id is required")
    }
    if r.Quantity <= 0 {
        return errors.New("quantity must be greater than 0")
    }
    return nil
}

type UpdateCartItemRequest struct {
    Quantity int \`json:"quantity" binding:"required,min=1"\`
}

func (r *UpdateCartItemRequest) Validate() error {
    if r.Quantity <= 0 {
        return errors.New("quantity must be greater than 0")
    }
    return nil
}

type RemoveFromCartRequest struct {
    ProductID uint \`json:"product_id" binding:"required"\`
}

func (r *RemoveFromCartRequest) Validate() error {
    if r.ProductID == 0 {
        return errors.New("product_id is required")
    }
    return nil
}</code></pre>

                    <div style="background: #f3e5f5; border-left: 4px solid #9c27b0; padding: 1.5rem; margin: 2rem 0;">
                        <h4 style="color: #7b1fa2; margin-bottom: 1rem;">üîç Penjelasan Request Structs</h4>
                        <p style="color: #6a1b9a; margin-bottom: 1rem;"><strong>AddToCartRequest:</strong></p>
                        <ul style="color: #6a1b9a; margin-bottom: 1rem;">
                            <li><strong>ProductID</strong> - ID produk yang akan ditambahkan ke cart (wajib)</li>
                            <li><strong>Quantity</strong> - Jumlah produk yang ditambahkan (wajib, minimal 1)</li>
                            <li><code>binding:"required"</code> - Validasi Gin untuk memastikan field wajib diisi</li>
                            <li><code>binding:"min=1"</code> - Validasi untuk memastikan quantity minimal 1</li>
                        </ul>
                        <p style="color: #6a1b9a; margin-bottom: 1rem;"><strong>UpdateCartItemRequest:</strong></p>
                        <ul style="color: #6a1b9a; margin-bottom: 1rem;">
                            <li><strong>Quantity</strong> - Jumlah baru untuk item di cart</li>
                            <li>Hanya quantity yang bisa diupdate, product_id tidak bisa diubah</li>
                        </ul>
                        <p style="color: #6a1b9a; margin-bottom: 1rem;"><strong>Validation Methods:</strong></p>
                        <ul style="color: #6a1b9a;">
                            <li>Custom validation method untuk validasi bisnis logic</li>
                            <li>Memastikan ProductID tidak 0 (invalid)</li>
                            <li>Memastikan Quantity lebih dari 0</li>
                        </ul>
                    </div>

                    <h3>üìù 3. Membuat Response Structs</h3>
                    <p>Kita buat response structs untuk cart data di file <code>responses/cart_response.go</code>:</p>
                    
                    <pre><code>package responses

import "tokogo/models"

type CartItemResponse struct {
    ID           uint    \`json:"id"\`
    UserID       uint    \`json:"user_id"\`
    ProductID    uint    \`json:"product_id"\`
    ProductName  string  \`json:"product_name"\`
    ProductPrice float64 \`json:"product_price"\`
    ProductImage string  \`json:"product_image"\`
    Quantity     int     \`json:"quantity"\`
    Subtotal     float64 \`json:"subtotal"\`
    CreatedAt    string  \`json:"created_at"\`
    UpdatedAt    string  \`json:"updated_at"\`
}

type CartResponse struct {
    Items      []CartItemResponse \`json:"items"\`
    TotalItems int                \`json:"total_items"\`
    TotalPrice float64            \`json:"total_price"\`
}

func ConvertCartToResponse(cart models.Cart) CartItemResponse {
    subtotal := float64(cart.Quantity) * cart.Product.SellingPrice
    
    return CartItemResponse{
        ID:           cart.ID,
        UserID:       cart.UserID,
        ProductID:    cart.ProductID,
        ProductName:  cart.Product.Name,
        ProductPrice: cart.Product.SellingPrice,
        ProductImage: cart.Product.ImageURL,
        Quantity:     cart.Quantity,
        Subtotal:     subtotal,
        CreatedAt:    cart.CreatedAt.Format("2006-01-02 15:04:05"),
        UpdatedAt:    cart.UpdatedAt.Format("2006-01-02 15:04:05"),
    }
}

func ConvertCartsToResponse(carts []models.Cart) []CartItemResponse {
    var responses []CartItemResponse
    var totalPrice float64
    
    for _, cart := range carts {
        response := ConvertCartToResponse(cart)
        responses = append(responses, response)
        totalPrice += response.Subtotal
    }
    
    return responses
}

func CreateCartResponse(carts []models.Cart) CartResponse {
    items := ConvertCartsToResponse(carts)
    
    var totalItems int
    var totalPrice float64
    
    for _, item := range items {
        totalItems += item.Quantity
        totalPrice += item.Subtotal
    }
    
    return CartResponse{
        Items:      items,
        TotalItems: totalItems,
        TotalPrice: totalPrice,
    }
}</code></pre>

                    <div style="background: #e8f5e8; border-left: 4px solid #4caf50; padding: 1.5rem; margin: 2rem 0;">
                        <h4 style="color: #388e3c; margin-bottom: 1rem;">üîç Penjelasan Response Structs</h4>
                        <p style="color: #2e7d32; margin-bottom: 1rem;"><strong>CartItemResponse:</strong></p>
                        <ul style="color: #2e7d32; margin-bottom: 1rem;">
                            <li><strong>ID, UserID, ProductID</strong> - Data identifikasi</li>
                            <li><strong>ProductName, ProductPrice, ProductImage</strong> - Detail produk yang user-friendly</li>
                            <li><strong>Quantity</strong> - Jumlah item di cart</li>
                            <li><strong>Subtotal</strong> - Harga total untuk item ini (price √ó quantity)</li>
                            <li><strong>CreatedAt/UpdatedAt</strong> - Timestamp dalam format string yang mudah dibaca</li>
                        </ul>
                        <p style="color: #2e7d32; margin-bottom: 1rem;"><strong>CartResponse:</strong></p>
                        <ul style="color: #2e7d32; margin-bottom: 1rem;">
                            <li><strong>Items</strong> - Array semua item di cart</li>
                            <li><strong>TotalItems</strong> - Total jumlah item (sum dari semua quantity)</li>
                            <li><strong>TotalPrice</strong> - Total harga semua item di cart</li>
                        </ul>
                        <p style="color: #2e7d32; margin-bottom: 1rem;"><strong>Conversion Functions:</strong></p>
                        <ul style="color: #2e7d32;">
                            <li><strong>ConvertCartToResponse</strong> - Mengkonversi model Cart ke response format</li>
                            <li><strong>ConvertCartsToResponse</strong> - Mengkonversi array Cart ke array response</li>
                            <li><strong>CreateCartResponse</strong> - Membuat response lengkap dengan totals</li>
                        </ul>
                    </div>

                    <h3>üìù 4. Membuat Repository Layer</h3>
                    <p>Kita buat repository layer untuk cart operations di file <code>repositories/cart_repository.go</code>:</p>
                    
                    <pre><code>package repositories

import (
    "tokogo/models"

    "gorm.io/gorm"
)

type CartRepository struct {
    db *gorm.DB
}

func NewCartRepository(db *gorm.DB) *CartRepository {
    return &CartRepository{
        db: db,
    }
}

func (r *CartRepository) Create(cart *models.Cart) error {
    return r.db.Create(cart).Error
}

func (r *CartRepository) GetByUserID(userID uint) ([]models.Cart, error) {
    var carts []models.Cart
    err := r.db.Preload("Product").Preload("User").Where("user_id = ?", userID).Find(&carts).Error
    return carts, err
}

func (r *CartRepository) GetByUserIDAndProductID(userID, productID uint) (*models.Cart, error) {
    var cart models.Cart
    err := r.db.Preload("Product").Preload("User").Where("user_id = ? AND product_id = ?", userID, productID).First(&cart).Error
    if err != nil {
        return nil, err
    }
    return &cart, nil
}

func (r *CartRepository) Update(cart *models.Cart) error {
    return r.db.Save(cart).Error
}

func (r *CartRepository) Delete(cartID uint) error {
    return r.db.Delete(&models.Cart{}, cartID).Error
}

func (r *CartRepository) DeleteByUserIDAndProductID(userID, productID uint) error {
    return r.db.Where("user_id = ? AND product_id = ?", userID, productID).Delete(&models.Cart{}).Error
}

func (r *CartRepository) ClearCart(userID uint) error {
    return r.db.Where("user_id = ?", userID).Delete(&models.Cart{}).Error
}

func (r *CartRepository) GetCartItemCount(userID uint) (int64, error) {
    var count int64
    err := r.db.Model(&models.Cart{}).Where("user_id = ?", userID).Count(&count).Error
    return count, err
}</code></pre>

                    <div style="background: #fff3e0; border-left: 4px solid #ff9800; padding: 1.5rem; margin: 2rem 0;">
                        <h4 style="color: #f57c00; margin-bottom: 1rem;">üîç Penjelasan Repository Layer</h4>
                        <p style="color: #ef6c00; margin-bottom: 1rem;"><strong>Constructor:</strong></p>
                        <ul style="color: #ef6c00; margin-bottom: 1rem;">
                            <li><strong>CartRepository</strong> - Struct yang menyimpan koneksi database</li>
                            <li><strong>NewCartRepository</strong> - Constructor yang menerima koneksi GORM</li>
                            <li>Dependency injection pattern untuk testability</li>
                        </ul>
                        <p style="color: #ef6c00; margin-bottom: 1rem;"><strong>CRUD Operations:</strong></p>
                        <ul style="color: #ef6c00; margin-bottom: 1rem;">
                            <li><strong>Create</strong> - Menyimpan cart item baru ke database</li>
                            <li><strong>GetByUserID</strong> - Mengambil semua cart item user dengan Preload relasi</li>
                            <li><strong>GetByUserIDAndProductID</strong> - Cek apakah item sudah ada di cart</li>
                            <li><strong>Update</strong> - Update cart item (Save akan auto-update timestamp)</li>
                            <li><strong>Delete</strong> - Hapus cart item berdasarkan ID atau user+product</li>
                            <li><strong>ClearCart</strong> - Hapus semua item cart user</li>
                            <li><strong>GetCartItemCount</strong> - Hitung jumlah item di cart</li>
                        </ul>
                        <p style="color: #ef6c00; margin-bottom: 1rem;"><strong>GORM Features:</strong></p>
                        <ul style="color: #ef6c00;">
                            <li><strong>Preload("Product")</strong> - Eager loading untuk relasi Product</li>
                            <li><strong>Where()</strong> - Filter data berdasarkan kondisi</li>
                            <li><strong>Find()</strong> - Mengambil multiple records</li>
                            <li><strong>First()</strong> - Mengambil record pertama yang match</li>
                            <li><strong>Count()</strong> - Menghitung jumlah records</li>
                        </ul>
                    </div>

                    <h3>üìù 5. Membuat Service Layer</h3>
                    <p>Kita buat service layer untuk cart business logic di file <code>services/cart_service.go</code>:</p>
                    
                    <pre><code>package services

import (
    "errors"
    "tokogo/config"
    "tokogo/models"
    "tokogo/repositories"
    "tokogo/requests"
    "tokogo/responses"
)

type CartService struct {
    cartRepo     *repositories.CartRepository
    productRepo  *repositories.ProductRepository
}

func NewCartService() *CartService {
    return &CartService{
        cartRepo:    repositories.NewCartRepository(),
        productRepo: repositories.NewProductRepository(config.DB),
    }
}

func (s *CartService) AddToCart(userID uint, req requests.AddToCartRequest) (*responses.CartItemResponse, error) {
    // Check if product exists
    product, err := s.productRepo.GetByID(req.ProductID)
    if err != nil {
        return nil, errors.New("product not found")
    }

    // Check if product is in stock
    if product.Stock < req.Quantity {
        return nil, errors.New("insufficient stock")
    }

    // Check if item already exists in cart
    existingCart, err := s.cartRepo.GetByUserIDAndProductID(userID, req.ProductID)
    if err == nil {
        // Item exists, update quantity
        existingCart.Quantity += req.Quantity
        
        // Check stock again after adding
        if product.Stock < existingCart.Quantity {
            return nil, errors.New("insufficient stock")
        }
        
        if err := s.cartRepo.Update(existingCart); err != nil {
            return nil, errors.New("failed to update cart")
        }
        
        response := responses.ConvertCartToResponse(*existingCart)
        return &response, nil
    }

    // Create new cart item
    cart := &models.Cart{
        UserID:    userID,
        ProductID: req.ProductID,
        Quantity:  req.Quantity,
    }

    if err := s.cartRepo.Create(cart); err != nil {
        return nil, errors.New("failed to add to cart")
    }

    // Get the created cart with product details
    createdCart, err := s.cartRepo.GetByUserIDAndProductID(userID, req.ProductID)
    if err != nil {
        return nil, errors.New("failed to retrieve cart item")
    }

    response := responses.ConvertCartToResponse(*createdCart)
    return &response, nil
}

func (s *CartService) GetCart(userID uint) (*responses.CartResponse, error) {
    carts, err := s.cartRepo.GetByUserID(userID)
    if err != nil {
        return nil, errors.New("failed to get cart")
    }

    response := responses.CreateCartResponse(carts)
    return &response, nil
}

func (s *CartService) UpdateCartItem(userID uint, productID uint, req requests.UpdateCartItemRequest) (*responses.CartItemResponse, error) {
    // Check if product exists
    product, err := s.productRepo.GetByID(productID)
    if err != nil {
        return nil, errors.New("product not found")
    }

    // Check if product is in stock
    if product.Stock < req.Quantity {
        return nil, errors.New("insufficient stock")
    }

    // Get existing cart item
    cart, err := s.cartRepo.GetByUserIDAndProductID(userID, productID)
    if err != nil {
        return nil, errors.New("cart item not found")
    }

    // Update quantity
    cart.Quantity = req.Quantity

    if err := s.cartRepo.Update(cart); err != nil {
        return nil, errors.New("failed to update cart")
    }

    response := responses.ConvertCartToResponse(*cart)
    return &response, nil
}

func (s *CartService) RemoveFromCart(userID uint, productID uint) error {
    // Check if cart item exists
    _, err := s.cartRepo.GetByUserIDAndProductID(userID, productID)
    if err != nil {
        return errors.New("cart item not found")
    }

    if err := s.cartRepo.DeleteByUserIDAndProductID(userID, productID); err != nil {
        return errors.New("failed to remove from cart")
    }

    return nil
}

func (s *CartService) ClearCart(userID uint) error {
    if err := s.cartRepo.ClearCart(userID); err != nil {
        return errors.New("failed to clear cart")
    }

    return nil
}

func (s *CartService) GetCartItemCount(userID uint) (int64, error) {
    count, err := s.cartRepo.GetCartItemCount(userID)
    if err != nil {
        return 0, errors.New("failed to get cart count")
    }

    return count, nil
}</code></pre>

                    <div style="background: #fce4ec; border-left: 4px solid #e91e63; padding: 1.5rem; margin: 2rem 0;">
                        <h4 style="color: #c2185b; margin-bottom: 1rem;">üîç Penjelasan Service Layer</h4>
                        <p style="color: #ad1457; margin-bottom: 1rem;"><strong>Constructor:</strong></p>
                        <ul style="color: #ad1457; margin-bottom: 1rem;">
                            <li><strong>CartService</strong> - Business logic layer</li>
                            <li><strong>cartRepo</strong> - Repository untuk cart operations</li>
                            <li><strong>productRepo</strong> - Repository untuk product operations (validasi stock)</li>
                            <li>Dependency injection untuk testability</li>
                        </ul>
                        <p style="color: #ad1457; margin-bottom: 1rem;"><strong>AddToCart Business Logic:</strong></p>
                        <ol style="color: #ad1457; margin-bottom: 1rem;">
                            <li><strong>Validasi Produk</strong> - Cek apakah produk ada di database</li>
                            <li><strong>Validasi Stock</strong> - Cek apakah stok mencukupi</li>
                            <li><strong>Cek Item Existing</strong> - Jika item sudah ada, update quantity</li>
                            <li><strong>Validasi Stock Lagi</strong> - Cek stock setelah menambah quantity</li>
                            <li><strong>Create/Update</strong> - Buat item baru atau update yang existing</li>
                            <li><strong>Return Response</strong> - Konversi ke response format</li>
                        </ol>
                        <p style="color: #ad1457; margin-bottom: 1rem;"><strong>Business Rules:</strong></p>
                        <ul style="color: #ad1457;">
                            <li>Stock validation sebelum dan sesudah operasi</li>
                            <li>Automatic quantity update untuk existing items</li>
                            <li>Error handling yang konsisten</li>
                            <li>Data conversion ke response format</li>
                        </ul>
                    </div>

                    <h3>üìù 6. Membuat Handler Layer</h3>
                    <p>Kita buat handler layer untuk cart HTTP endpoints di file <code>handlers/cart_handler.go</code>:</p>
                    
                    <pre><code>package handlers

import (
    "net/http"
    "strconv"
    "tokogo/requests"
    "tokogo/responses"
    "tokogo/services"

    "github.com/gin-gonic/gin"
)

type CartHandler struct {
    cartService *services.CartService
}

func NewCartHandler() *CartHandler {
    return &CartHandler{
        cartService: services.NewCartService(),
    }
}

// AddToCart godoc
// @Summary Add item to cart
// @Description Add a product to user's cart
// @Tags Cart
// @Accept json
// @Produce json
// @Param cart body requests.AddToCartRequest true "Cart item data"
// @Success 201 {object} responses.CartItemResponse
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Router /api/v1/cart [post]
func (h *CartHandler) AddToCart(c *gin.Context) {
    // Get user ID from JWT token
    userIDInterface, exists := c.Get("user_id")
    if !exists {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "unauthorized",
            Message: "User ID not found",
        })
        return
    }

    userID, ok := userIDInterface.(uint)
    if !ok {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "unauthorized",
            Message: "Invalid user ID",
        })
        return
    }

    var req requests.AddToCartRequest

    // Bind and validate request
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Validate using method Validate()
    if err := req.Validate(); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Call service to add to cart
    response, err := h.cartService.AddToCart(userID, req)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "add_to_cart_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusCreated, responses.SuccessResponse{
        Message: "Item added to cart successfully",
        Data:    response,
    })
}

// GetCart godoc
// @Summary Get user's cart
// @Description Get all items in user's cart
// @Tags Cart
// @Produce json
// @Success 200 {object} responses.CartResponse
// @Failure 401 {object} map[string]string
// @Router /api/v1/cart [get]
func (h *CartHandler) GetCart(c *gin.Context) {
    // Get user ID from JWT token
    userIDInterface, exists := c.Get("user_id")
    if !exists {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "unauthorized",
            Message: "User ID not found",
        })
        return
    }

    userID, ok := userIDInterface.(uint)
    if !ok {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "unauthorized",
            Message: "Invalid user ID",
        })
        return
    }

    // Call service to get cart
    response, err := h.cartService.GetCart(userID)
    if err != nil {
        c.JSON(http.StatusInternalServerError, responses.ErrorResponse{
            Error:   "get_cart_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Cart retrieved successfully",
        Data:    response,
    })
}

// UpdateCartItem godoc
// @Summary Update cart item quantity
// @Description Update the quantity of a specific item in cart
// @Tags Cart
// @Accept json
// @Produce json
// @Param product_id path int true "Product ID"
// @Param cart body requests.UpdateCartItemRequest true "Updated quantity"
// @Success 200 {object} responses.CartItemResponse
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /api/v1/cart/{product_id} [put]
func (h *CartHandler) UpdateCartItem(c *gin.Context) {
    // Get user ID from JWT token
    userIDInterface, exists := c.Get("user_id")
    if !exists {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "unauthorized",
            Message: "User ID not found",
        })
        return
    }

    userID, ok := userIDInterface.(uint)
    if !ok {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "unauthorized",
            Message: "Invalid user ID",
        })
        return
    }

    // Get product ID from URL parameter
    productID, err := strconv.ParseUint(c.Param("product_id"), 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: "Invalid product ID",
        })
        return
    }

    var req requests.UpdateCartItemRequest

    // Bind and validate request
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Validate using method Validate()
    if err := req.Validate(); err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: err.Error(),
        })
        return
    }

    // Call service to update cart item
    response, err := h.cartService.UpdateCartItem(userID, uint(productID), req)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "update_cart_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Cart item updated successfully",
        Data:    response,
    })
}

// RemoveFromCart godoc
// @Summary Remove item from cart
// @Description Remove a specific item from user's cart
// @Tags Cart
// @Produce json
// @Param product_id path int true "Product ID"
// @Success 200 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Router /api/v1/cart/{product_id} [delete]
func (h *CartHandler) RemoveFromCart(c *gin.Context) {
    // Get user ID from JWT token
    userIDInterface, exists := c.Get("user_id")
    if !exists {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "unauthorized",
            Message: "User ID not found",
        })
        return
    }

    userID, ok := userIDInterface.(uint)
    if !ok {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "unauthorized",
            Message: "Invalid user ID",
        })
        return
    }

    // Get product ID from URL parameter
    productID, err := strconv.ParseUint(c.Param("product_id"), 10, 32)
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "validation_error",
            Message: "Invalid product ID",
        })
        return
    }

    // Call service to remove from cart
    err = h.cartService.RemoveFromCart(userID, uint(productID))
    if err != nil {
        c.JSON(http.StatusBadRequest, responses.ErrorResponse{
            Error:   "remove_from_cart_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Item removed from cart successfully",
        Data:    nil,
    })
}

// ClearCart godoc
// @Summary Clear user's cart
// @Description Remove all items from user's cart
// @Tags Cart
// @Produce json
// @Success 200 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Router /api/v1/cart/clear [delete]
func (h *CartHandler) ClearCart(c *gin.Context) {
    // Get user ID from JWT token
    userIDInterface, exists := c.Get("user_id")
    if !exists {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "unauthorized",
            Message: "User ID not found",
        })
        return
    }

    userID, ok := userIDInterface.(uint)
    if !ok {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "unauthorized",
            Message: "Invalid user ID",
        })
        return
    }

    // Call service to clear cart
    err := h.cartService.ClearCart(userID)
    if err != nil {
        c.JSON(http.StatusInternalServerError, responses.ErrorResponse{
            Error:   "clear_cart_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Cart cleared successfully",
        Data:    nil,
    })
}

// GetCartItemCount godoc
// @Summary Get cart item count
// @Description Get the total number of items in user's cart
// @Tags Cart
// @Produce json
// @Success 200 {object} map[string]int64
// @Failure 401 {object} map[string]string
// @Router /api/v1/cart/count [get]
func (h *CartHandler) GetCartItemCount(c *gin.Context) {
    // Get user ID from JWT token
    userIDInterface, exists := c.Get("user_id")
    if !exists {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "unauthorized",
            Message: "User ID not found",
        })
        return
    }

    userID, ok := userIDInterface.(uint)
    if !ok {
        c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
            Error:   "unauthorized",
            Message: "Invalid user ID",
        })
        return
    }

    // Call service to get cart count
    count, err := h.cartService.GetCartItemCount(userID)
    if err != nil {
        c.JSON(http.StatusInternalServerError, responses.ErrorResponse{
            Error:   "get_cart_count_failed",
            Message: err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, responses.SuccessResponse{
        Message: "Cart count retrieved successfully",
        Data:    gin.H{"count": count},
    })
}</code></pre>

                    <div style="background: #e3f2fd; border-left: 4px solid #2196f3; padding: 1.5rem; margin: 2rem 0;">
                        <h4 style="color: #1976d2; margin-bottom: 1rem;">üîç Penjelasan Handler Layer</h4>
                        <p style="color: #1565c0; margin-bottom: 1rem;"><strong>Constructor:</strong></p>
                        <ul style="color: #1565c0; margin-bottom: 1rem;">
                            <li><strong>CartHandler</strong> - HTTP layer untuk handle request/response</li>
                            <li><strong>cartService</strong> - Dependency ke service layer</li>
                            <li>Clean architecture pattern</li>
                        </ul>
                        <p style="color: #1565c0; margin-bottom: 1rem;"><strong>AddToCart Handler Flow:</strong></p>
                        <ol style="color: #1565c0; margin-bottom: 1rem;">
                            <li><strong>Extract User ID</strong> - Ambil user ID dari JWT token (dari middleware)</li>
                            <li><strong>Type Assertion</strong> - Pastikan user ID adalah uint</li>
                            <li><strong>Bind Request</strong> - Parse JSON request ke struct</li>
                            <li><strong>Validate Request</strong> - Jalankan custom validation</li>
                            <li><strong>Call Service</strong> - Panggil business logic</li>
                            <li><strong>Return Response</strong> - Kirim response dengan status code yang sesuai</li>
                        </ol>
                        <p style="color: #1565c0; margin-bottom: 1rem;"><strong>Handler Features:</strong></p>
                        <ul style="color: #1565c0;">
                            <li>JWT authentication integration</li>
                            <li>Request validation dan error handling</li>
                            <li>Consistent response format</li>
                            <li>Proper HTTP status codes</li>
                            <li>Swagger documentation annotations</li>
                        </ul>
                    </div>

                    <h3>üìù 7. Menambahkan Routes ke main.go</h3>
                    <p>Kita tambahkan cart routes ke file <code>main.go</code>:</p>
                    
                    <pre><code>// Initialize handlers
authHandler := handlers.NewAuthHandler()
categoryHandler := handlers.NewCategoryHandler()
productHandler := handlers.NewProductHandler()
userManagementHandler := handlers.NewUserManagementHandler()
transactionHandler := handlers.NewTransactionHandler()
profileHandler := handlers.NewProfileHandler()
cartHandler := handlers.NewCartHandler()

// Cart routes (customer only)
cart := protected.Group("/cart")
{
    cart.POST("", cartHandler.AddToCart)
    cart.GET("", cartHandler.GetCart)
    cart.PUT("/:product_id", cartHandler.UpdateCartItem)
    cart.DELETE("/:product_id", cartHandler.RemoveFromCart)
    cart.DELETE("/clear", cartHandler.ClearCart)
    cart.GET("/count", cartHandler.GetCartItemCount)
}</code></pre>

                    <div style="background: #f1f8e9; border-left: 4px solid #8bc34a; padding: 1.5rem; margin: 2rem 0;">
                        <h4 style="color: #689f38; margin-bottom: 1rem;">üîç Penjelasan Routes</h4>
                        <p style="color: #558b2f; margin-bottom: 1rem;"><strong>Route Structure:</strong></p>
                        <ul style="color: #558b2f; margin-bottom: 1rem;">
                            <li><strong>protected.Group("/cart")</strong> - Route group yang memerlukan authentication</li>
                            <li><strong>RESTful Design</strong> - Mengikuti konvensi REST API</li>
                            <li><strong>Parameter Routes</strong> - <code>:product_id</code> untuk dynamic parameter</li>
                            <li><strong>HTTP Methods</strong> - POST (create), GET (read), PUT (update), DELETE (delete)</li>
                        </ul>
                        <p style="color: #558b2f; margin-bottom: 1rem;"><strong>Available Endpoints:</strong></p>
                        <ul style="color: #558b2f;">
                            <li><code>POST /api/v1/cart</code> - Add item to cart</li>
                            <li><code>GET /api/v1/cart</code> - Get user's cart</li>
                            <li><code>PUT /api/v1/cart/{product_id}</code> - Update cart item quantity</li>
                            <li><code>DELETE /api/v1/cart/{product_id}</code> - Remove item from cart</li>
                            <li><code>DELETE /api/v1/cart/clear</code> - Clear entire cart</li>
                            <li><code>GET /api/v1/cart/count</code> - Get cart item count</li>
                        </ul>
                    </div>

                    <h3>üß™ Testing Cart API</h3>
                    <p>Sekarang kita test API yang sudah dibuat menggunakan Postman atau curl:</p>

                    <h4>1. Test Add to Cart</h4>
                    <pre><code>POST http://localhost:8080/api/v1/cart
Authorization: Bearer YOUR_JWT_TOKEN
Content-Type: application/json

{
    "product_id": 1,
    "quantity": 2
}</code></pre>

                    <h4>2. Test Get Cart</h4>
                    <pre><code>GET http://localhost:8080/api/v1/cart
Authorization: Bearer YOUR_JWT_TOKEN</code></pre>

                    <h4>3. Test Update Cart Item</h4>
                    <pre><code>PUT http://localhost:8080/api/v1/cart/1
Authorization: Bearer YOUR_JWT_TOKEN
Content-Type: application/json

{
    "quantity": 3
}</code></pre>

                    <h4>4. Test Remove from Cart</h4>
                    <pre><code>DELETE http://localhost:8080/api/v1/cart/1
Authorization: Bearer YOUR_JWT_TOKEN</code></pre>

                    <h4>5. Test Clear Cart</h4>
                    <pre><code>DELETE http://localhost:8080/api/v1/cart/clear
Authorization: Bearer YOUR_JWT_TOKEN</code></pre>

                    <h4>6. Test Get Cart Count</h4>
                    <pre><code>GET http://localhost:8080/api/v1/cart/count
Authorization: Bearer YOUR_JWT_TOKEN</code></pre>

                    <h4>7. Expected Response Format</h4>
                    <pre><code>{
    "message": "Cart retrieved successfully",
    "data": {
        "items": [
            {
                "id": 1,
                "user_id": 1,
                "product_id": 1,
                "product_name": "Laptop Gaming",
                "product_price": 15000000,
                "product_image": "/uploads/products/laptop.jpg",
                "quantity": 2,
                "subtotal": 30000000,
                "created_at": "2024-01-15 10:30:00",
                "updated_at": "2024-01-15 10:30:00"
            }
        ],
        "total_items": 2,
        "total_price": 30000000
    }
}</code></pre>

                    <div style="background: #d4edda; border: 1px solid #c3e6cb; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #155724; margin-bottom: 1rem;">üéâ Selamat! Cart Management API Selesai!</h3>
                        <p style="color: #155724; margin-bottom: 0;">Dengan Cart Management API yang lengkap, customer sekarang dapat mengelola keranjang belanja mereka dengan mudah dan aman!</p>
                    </div>

                    <h3>üîç Fitur Cart Management yang Tersedia</h3>
                    <table style="width: 100%; border-collapse: collapse; margin: 2rem 0;">
                        <thead>
                            <tr style="background: #f8f9fa;">
                                <th style="border: 1px solid #dee2e6; padding: 1rem; text-align: left;">Endpoint</th>
                                <th style="border: 1px solid #dee2e6; padding: 1rem; text-align: left;">Method</th>
                                <th style="border: 1px solid #dee2e6; padding: 1rem; text-align: left;">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td style="border: 1px solid #dee2e6; padding: 1rem;"><code>/api/v1/cart</code></td>
                                <td style="border: 1px solid #dee2e6; padding: 1rem;">POST</td>
                                <td style="border: 1px solid #dee2e6; padding: 1rem;">Add item to cart</td>
                            </tr>
                            <tr style="background: #f8f9fa;">
                                <td style="border: 1px solid #dee2e6; padding: 1rem;"><code>/api/v1/cart</code></td>
                                <td style="border: 1px solid #dee2e6; padding: 1rem;">GET</td>
                                <td style="border: 1px solid #dee2e6; padding: 1rem;">Get user's cart</td>
                            </tr>
                            <tr>
                                <td style="border: 1px solid #dee2e6; padding: 1rem;"><code>/api/v1/cart/{product_id}</code></td>
                                <td style="border: 1px solid #dee2e6; padding: 1rem;">PUT</td>
                                <td style="border: 1px solid #dee2e6; padding: 1rem;">Update cart item quantity</td>
                            </tr>
                            <tr style="background: #f8f9fa;">
                                <td style="border: 1px solid #dee2e6; padding: 1rem;"><code>/api/v1/cart/{product_id}</code></td>
                                <td style="border: 1px solid #dee2e6; padding: 1rem;">DELETE</td>
                                <td style="border: 1px solid #dee2e6; padding: 1rem;">Remove item from cart</td>
                            </tr>
                            <tr>
                                <td style="border: 1px solid #dee2e6; padding: 1rem;"><code>/api/v1/cart/clear</code></td>
                                <td style="border: 1px solid #dee2e6; padding: 1rem;">DELETE</td>
                                <td style="border: 1px solid #dee2e6; padding: 1rem;">Clear entire cart</td>
                            </tr>
                            <tr style="background: #f8f9fa;">
                                <td style="border: 1px solid #dee2e6; padding: 1rem;"><code>/api/v1/cart/count</code></td>
                                <td style="border: 1px solid #dee2e6; padding: 1rem;">GET</td>
                                <td style="border: 1px solid #dee2e6; padding: 1rem;">Get cart item count</td>
                            </tr>
                        </tbody>
                    </table>

                    <h3>üîí Keamanan Cart API</h3>
                    <ul>
                        <li>‚úÖ <strong>Authentication Required</strong> - Semua endpoint memerlukan JWT token</li>
                        <li>‚úÖ <strong>User Isolation</strong> - User hanya bisa mengakses cart mereka sendiri</li>
                        <li>‚úÖ <strong>Stock Validation</strong> - Validasi stok produk sebelum menambah ke cart</li>
                        <li>‚úÖ <strong>Input Validation</strong> - Semua input divalidasi dengan baik</li>
                        <li>‚úÖ <strong>Error Handling</strong> - Error handling yang konsisten</li>
                    </ul>

                    <h3>üöÄ Langkah Selanjutnya</h3>
                    <p>Dengan Cart Management API yang sudah selesai, Anda dapat:</p>
                    <ul>
                        <li>‚úÖ <strong>Integrate dengan Frontend</strong> - Gunakan API ini untuk fitur cart di website</li>
                        <li>‚úÖ <strong>Add Cart Persistence</strong> - Cart akan tersimpan di database</li>
                        <li>‚úÖ <strong>Implement Cart Expiry</strong> - Tambahkan fitur cart expiry setelah periode tertentu</li>
                        <li>‚úÖ <strong>Add Cart Notifications</strong> - Notifikasi ketika stok produk habis</li>
                        <li>‚úÖ <strong>Create Checkout Flow</strong> - Lanjutkan ke proses checkout dan payment</li>
                    </ul>

                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #2e7d32; margin-bottom: 1rem;">üå± Refleksi Pembelajaran</h4>
                        <p style="color: #388e3c; margin-bottom: 1rem;">Anda telah berhasil menguasai:</p>
                        <ul style="color: #388e3c;">
                            <li>‚úÖ <strong>CRUD Operations</strong> - Implementasi lengkap Create, Read, Update, Delete</li>
                            <li>‚úÖ <strong>Business Logic</strong> - Logika bisnis untuk cart management</li>
                            <li>‚úÖ <strong>Stock Management</strong> - Validasi stok produk</li>
                            <li>‚úÖ <strong>User Authentication</strong> - Integrasi dengan JWT authentication</li>
                            <li>‚úÖ <strong>Data Relationships</strong> - Relasi antara User, Product, dan Cart</li>
                            <li>‚úÖ <strong>Response Structure</strong> - Struktur response yang informatif</li>
                        </ul>
                        <p style="color: #2e7d32; margin-top: 1rem; font-style: italic;">"Cart management yang baik adalah fondasi untuk e-commerce yang sukses. Dengan sistem yang aman dan user-friendly, customer dapat berbelanja dengan nyaman dan percaya diri."</p>
                    </div>
                `
            },
            {
                id: 'chapter19',
                title: 'Bab 19: Checkout & Payment API - Proses Pembayaran untuk Customer',
                meta: 'Halaman 20 dari 55 ‚Ä¢ Dibaca 25 menit',
                content: `
                    <h2>üí≥ Bab 19: Checkout & Payment API - Proses Pembayaran untuk Customer</h2>
                    <p>Selamat! Sekarang kita akan membuat Checkout & Payment API yang memungkinkan customer untuk melakukan checkout dari keranjang belanja dan mengelola transaksi pembayaran. Di bab ini, kita akan mengimplementasikan sistem checkout lengkap dengan fitur summary, proses checkout, konfirmasi pembayaran, dan tracking transaksi.</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">üéØ Apa yang Akan Kita Buat di Bab Ini?</h3>
                        <p style="color: #495057; margin-bottom: 0;">Kita akan membuat Checkout & Payment API yang lengkap dengan fitur checkout summary, proses checkout, konfirmasi pembayaran, dan manajemen transaksi. Customer dapat melihat ringkasan checkout, memproses pembayaran, mengkonfirmasi pembayaran, dan melacak status transaksi mereka.</p>
                    </div>

                    <h3>üìã Prasyarat</h3>
                    <p>Sebelum memulai, pastikan Anda sudah menyelesaikan:</p>
                    <ul>
                        <li>‚úÖ Bab 6-8: Modul Authentication (Register, Login, Logout)</li>
                        <li>‚úÖ Bab 11: Modul CRUD Product - Role Admin</li>
                        <li>‚úÖ Bab 17: Public Product API</li>
                        <li>‚úÖ Bab 18: Cart Management API</li>
                        <li>‚úÖ Tabel users, products, carts, dan transactions sudah ada di database</li>
                        <li>‚úÖ Ada data produk dan cart items</li>
                        <li>‚úÖ User sudah bisa login dan mendapat JWT token</li>
                    </ul>

                    <h3>üóÑÔ∏è Database Schema</h3>
                    <p>Sebelum memulai, kita perlu memastikan tabel transactions dan transaction_details sudah ada. Berikut adalah schema database yang akan kita gunakan:</p>

                    <h4>üìä Tabel Transactions</h4>
                    <pre><code>CREATE TABLE transactions (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    status ENUM('pending', 'paid', 'shipped', 'delivered', 'cancelled') DEFAULT 'pending',
    total_amount DECIMAL(10,2) NOT NULL,
    shipping_address TEXT NOT NULL,
    payment_method ENUM('bank_transfer', 'credit_card', 'e_wallet', 'cod') NOT NULL,
    payment_url VARCHAR(255),
    payment_proof VARCHAR(255),
    notes TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);</code></pre>

                    <h4>üìä Tabel Transaction Details</h4>
                    <pre><code>CREATE TABLE transaction_details (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    transaction_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,
    quantity INT NOT NULL,
    price DECIMAL(10,2) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (transaction_id) REFERENCES transactions(id) ON DELETE CASCADE,
    FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE
);</code></pre>

                    <div style="background: #d1ecf1; border-left: 4px solid #17a2b8; padding: 1rem; margin: 2rem 0;">
                        <strong>üîç Catatan Penting:</strong> Tabel transactions menyimpan informasi transaksi utama, sedangkan transaction_details menyimpan detail item-item yang dibeli. Relasi one-to-many memungkinkan satu transaksi memiliki banyak detail item.
                    </div>

                    <h3>üèóÔ∏è Struktur File yang Akan Dibuat</h3>
                    <p>Kita akan membuat file-file berikut untuk modul Checkout & Payment:</p>
                    <ul>
                        <li><code>requests/checkout_request.go</code> - Request structs untuk checkout operations</li>
                        <li><code>responses/checkout_response.go</code> - Response structs untuk checkout data</li>
                        <li><code>services/checkout_service.go</code> - Service layer untuk checkout business logic</li>
                        <li><code>handlers/checkout_handler.go</code> - Handler layer untuk checkout HTTP endpoints</li>
                    </ul>

                    <h3>üìù 1. Membuat Request Structs</h3>
                    <p>Pertama, kita buat request structs untuk checkout operations di file <code>requests/checkout_request.go</code>:</p>
                    
                    <pre><code>package requests

import "errors"

type CheckoutRequest struct {
	ShippingAddress string \`json:"shipping_address" binding:"required"\`
	PaymentMethod   string \`json:"payment_method" binding:"required"\`
	Notes           string \`json:"notes"\`
}

func (r *CheckoutRequest) Validate() error {
	if r.ShippingAddress == "" {
		return errors.New("shipping_address is required")
	}
	if r.PaymentMethod == "" {
		return errors.New("payment_method is required")
	}

	// Validate payment method
	validPaymentMethods := []string{"bank_transfer", "credit_card", "e_wallet", "cod"}
	isValid := false
	for _, method := range validPaymentMethods {
		if r.PaymentMethod == method {
			isValid = true
			break
		}
	}
	if !isValid {
		return errors.New("invalid payment method")
	}

	return nil
}

type ConfirmPaymentRequest struct {
	PaymentProof string \`json:"payment_proof" binding:"required"\`
	Notes        string \`json:"notes"\`
}

func (r *ConfirmPaymentRequest) Validate() error {
	if r.PaymentProof == "" {
		return errors.New("payment_proof is required")
	}
	return nil
}</code></pre>

                    <div style="background: #e8f4fd; border-left: 4px solid #2196f3; padding: 1.5rem; margin: 2rem 0;">
                        <h4 style="color: #1976d2; margin-bottom: 1rem;">üîç Penjelasan Request Structs</h4>
                        <p style="color: #1565c0; margin-bottom: 1rem;"><strong>CheckoutRequest:</strong></p>
                        <ul style="color: #1565c0; margin-bottom: 1rem;">
                            <li><strong>ShippingAddress</strong> - Alamat pengiriman (required)</li>
                            <li><strong>PaymentMethod</strong> - Metode pembayaran (required, harus valid)</li>
                            <li><strong>Notes</strong> - Catatan tambahan (optional)</li>
                        </ul>
                        <p style="color: #1565c0; margin-bottom: 1rem;"><strong>ConfirmPaymentRequest:</strong></p>
                        <ul style="color: #1565c0;">
                            <li><strong>PaymentProof</strong> - Bukti pembayaran (required)</li>
                            <li><strong>Notes</strong> - Catatan tambahan (optional)</li>
                        </ul>
                    </div>

                    <h3>üìù 2. Membuat Response Structs</h3>
                    <p>Kita buat response structs untuk checkout data di file <code>responses/checkout_response.go</code>:</p>
                    
                    <pre><code>package responses

import "tokogo/models"

type CheckoutResponse struct {
	TransactionID   uint                   \`json:"transaction_id"\`
	UserID          uint                   \`json:"user_id"\`
	Status          string                 \`json:"status"\`
	TotalAmount     float64                \`json:"total_amount"\`
	ShippingAddress string                 \`json:"shipping_address"\`
	PaymentMethod   string                 \`json:"payment_method"\`
	PaymentURL      string                 \`json:"payment_url,omitempty"\`
	Items           []CheckoutItemResponse \`json:"items"\`
	CreatedAt       string                 \`json:"created_at"\`
	UpdatedAt       string                 \`json:"updated_at"\`
}

type CheckoutItemResponse struct {
	ProductID    uint    \`json:"product_id"\`
	ProductName  string  \`json:"product_name"\`
	ProductPrice float64 \`json:"product_price"\`
	Quantity     int     \`json:"quantity"\`
	Subtotal     float64 \`json:"subtotal"\`
}

type CheckoutSummaryResponse struct {
	TotalItems      int     \`json:"total_items"\`
	TotalAmount     float64 \`json:"total_amount"\`
	ShippingCost    float64 \`json:"shipping_cost"\`
	GrandTotal      float64 \`json:"grand_total"\`
	PaymentMethod   string  \`json:"payment_method"\`
	ShippingAddress string  \`json:"shipping_address"\`
}</code></pre>

                    <div style="background: #e8f4fd; border-left: 4px solid #2196f3; padding: 1.5rem; margin: 2rem 0;">
                        <h4 style="color: #1976d2; margin-bottom: 1rem;">üîç Penjelasan Response Structs</h4>
                        <p style="color: #1565c0; margin-bottom: 1rem;"><strong>CheckoutResponse:</strong> Response lengkap untuk transaksi checkout</p>
                        <p style="color: #1565c0; margin-bottom: 1rem;"><strong>CheckoutItemResponse:</strong> Detail item dalam transaksi</p>
                        <p style="color: #1565c0; margin-bottom: 1rem;"><strong>CheckoutSummaryResponse:</strong> Ringkasan checkout sebelum proses pembayaran</p>
                    </div>

                    <h3>üìù 3. Membuat Service Layer</h3>
                    <p>Kita buat service layer untuk checkout business logic di file <code>services/checkout_service.go</code>:</p>
                    
                    <pre><code>package services

import (
	"errors"
	"fmt"
	"tokogo/config"
	"tokogo/models"
	"tokogo/repositories"
	"tokogo/requests"
	"tokogo/responses"
)

type CheckoutService struct {
	cartRepo        *repositories.CartRepository
	productRepo     *repositories.ProductRepository
	transactionRepo *repositories.TransactionRepository
}

func NewCheckoutService() *CheckoutService {
	return &CheckoutService{
		cartRepo:        repositories.NewCartRepository(config.DB),
		productRepo:     repositories.NewProductRepository(config.DB),
		transactionRepo: repositories.NewTransactionRepository(config.DB),
	}
}</code></pre>

                    <h4>üîß Method GetCheckoutSummary</h4>
                    <pre><code>func (s *CheckoutService) GetCheckoutSummary(userID uint, req requests.CheckoutRequest) (*responses.CheckoutSummaryResponse, error) {
	// Get user's cart
	carts, err := s.cartRepo.GetByUserID(userID)
	if err != nil {
		return nil, errors.New("failed to get cart")
	}

	if len(carts) == 0 {
		return nil, errors.New("cart is empty")
	}

	// Calculate shipping cost
	shippingCost := s.calculateShippingCost(carts)

	// Create checkout summary
	summary := responses.CreateCheckoutSummaryResponse(carts, shippingCost, req.PaymentMethod, req.ShippingAddress)

	return &summary, nil
}</code></pre>

                    <h4>üîß Method ProcessCheckout</h4>
                    <pre><code>func (s *CheckoutService) ProcessCheckout(userID uint, req requests.CheckoutRequest) (*responses.CheckoutResponse, error) {
	// Get user's cart
	carts, err := s.cartRepo.GetByUserID(userID)
	if err != nil {
		return nil, errors.New("failed to get cart")
	}

	if len(carts) == 0 {
		return nil, errors.New("cart is empty")
	}

	// Validate stock for all items
	for _, cart := range carts {
		product, err := s.productRepo.GetByID(cart.ProductID)
		if err != nil {
			return nil, fmt.Errorf("product with ID %d not found", cart.ProductID)
		}

		if product.Stock < cart.Quantity {
			return nil, fmt.Errorf("insufficient stock for product %s (available: %d, requested: %d)",
				product.Name, product.Stock, cart.Quantity)
		}
	}

	// Calculate total amount
	var totalAmount float64
	for _, cart := range carts {
		totalAmount += float64(cart.Quantity) * cart.Product.SellingPrice
	}

	// Add shipping cost
	shippingCost := s.calculateShippingCost(carts)
	totalAmount += shippingCost

	// Create transaction
	transaction := &models.Transaction{
		UserID:          userID,
		Status:          "pending",
		TotalAmount:     totalAmount,
		ShippingAddress: req.ShippingAddress,
		PaymentMethod:   req.PaymentMethod,
		Notes:           req.Notes,
	}

	// Save transaction
	if err := s.transactionRepo.Create(transaction); err != nil {
		return nil, errors.New("failed to create transaction")
	}

	// Create transaction details and update stock
	for _, cart := range carts {
		detail := &models.TransactionDetail{
			TransactionID: transaction.ID,
			ProductID:     cart.ProductID,
			Quantity:      cart.Quantity,
			Price:         cart.Product.SellingPrice,
		}

		if err := s.transactionRepo.CreateTransactionDetail(detail); err != nil {
			return nil, errors.New("failed to create transaction detail")
		}

		// Update product stock
		product, _ := s.productRepo.GetByID(cart.ProductID)
		product.Stock -= cart.Quantity
		if err := s.productRepo.Update(product); err != nil {
			return nil, errors.New("failed to update product stock")
		}
	}

	// Generate payment URL
	paymentURL := s.generatePaymentURL(transaction.ID, req.PaymentMethod)
	transaction.PaymentURL = paymentURL

	if err := s.transactionRepo.Update(transaction); err != nil {
		return nil, errors.New("failed to update payment URL")
	}

	// Clear user's cart
	if err := s.cartRepo.ClearCart(userID); err != nil {
		fmt.Printf("Warning: Failed to clear cart for user %d: %v\n", userID, err)
	}

	// Get transaction with details for response
	createdTransaction, err := s.transactionRepo.GetByID(transaction.ID)
	if err != nil {
		return nil, errors.New("failed to retrieve transaction")
	}

	response := responses.ConvertTransactionToCheckoutResponse(*createdTransaction)
	return &response, nil
}</code></pre>

                    <div style="background: #e8f4fd; border-left: 4px solid #2196f3; padding: 1.5rem; margin: 2rem 0;">
                        <h4 style="color: #1976d2; margin-bottom: 1rem;">üîç Penjelasan Business Logic</h4>
                        <p style="color: #1565c0; margin-bottom: 1rem;"><strong>GetCheckoutSummary:</strong></p>
                        <ul style="color: #1565c0; margin-bottom: 1rem;">
                            <li>Mengambil data cart user</li>
                            <li>Menghitung biaya pengiriman</li>
                            <li>Membuat ringkasan checkout</li>
                        </ul>
                        <p style="color: #1565c0; margin-bottom: 1rem;"><strong>ProcessCheckout:</strong></p>
                        <ul style="color: #1565c0;">
                            <li>Validasi stok produk</li>
                            <li>Membuat transaksi baru</li>
                            <li>Membuat detail transaksi</li>
                            <li>Update stok produk</li>
                            <li>Generate payment URL</li>
                            <li>Kosongkan cart</li>
                        </ul>
                    </div>

                    <h3>üìù 4. Membuat Handler Layer</h3>
                    <p>Kita buat handler layer untuk checkout HTTP endpoints di file <code>handlers/checkout_handler.go</code>:</p>
                    
                    <pre><code>package handlers

import (
	"net/http"
	"strconv"
	"tokogo/requests"
	"tokogo/responses"
	"tokogo/services"

	"github.com/gin-gonic/gin"
)

type CheckoutHandler struct {
	checkoutService *services.CheckoutService
}

func NewCheckoutHandler() *CheckoutHandler {
	return &CheckoutHandler{
		checkoutService: services.NewCheckoutService(),
	}
}</code></pre>

                    <h4>üîß Endpoint GetCheckoutSummary</h4>
                    <pre><code>// GetCheckoutSummary godoc
// @Summary Get checkout summary
// @Description Get checkout summary with shipping cost calculation
// @Tags Checkout
// @Accept json
// @Produce json
// @Param checkout body requests.CheckoutRequest true "Checkout data"
// @Success 200 {object} responses.CheckoutSummaryResponse
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Router /api/v1/checkout/summary [post]
func (h *CheckoutHandler) GetCheckoutSummary(c *gin.Context) {
	// Get user ID from JWT token
	userIDInterface, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
			Error:   "unauthorized",
			Message: "User ID not found",
		})
		return
	}

	userID, ok := userIDInterface.(uint)
	if !ok {
		c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
			Error:   "unauthorized",
			Message: "Invalid user ID",
		})
		return
	}

	var req requests.CheckoutRequest

	// Bind and validate request
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, responses.ErrorResponse{
			Error:   "validation_error",
			Message: err.Error(),
		})
		return
	}

	// Validate using method Validate()
	if err := req.Validate(); err != nil {
		c.JSON(http.StatusBadRequest, responses.ErrorResponse{
			Error:   "validation_error",
			Message: err.Error(),
		})
		return
	}

	// Call service to get checkout summary
	response, err := h.checkoutService.GetCheckoutSummary(userID, req)
	if err != nil {
		c.JSON(http.StatusBadRequest, responses.ErrorResponse{
			Error:   "get_checkout_summary_failed",
			Message: err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, responses.SuccessResponse{
		Message: "Checkout summary retrieved successfully",
		Data:    response,
	})
}</code></pre>

                    <h4>üîß Endpoint ProcessCheckout</h4>
                    <pre><code>// ProcessCheckout godoc
// @Summary Process checkout
// @Description Process checkout from cart to transaction
// @Tags Checkout
// @Accept json
// @Produce json
// @Param checkout body requests.CheckoutRequest true "Checkout data"
// @Success 201 {object} responses.CheckoutResponse
// @Failure 400 {object} map[string]string
// @Failure 401 {object} map[string]string
// @Router /api/v1/checkout [post]
func (h *CheckoutHandler) ProcessCheckout(c *gin.Context) {
	// Get user ID from JWT token
	userIDInterface, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
			Error:   "unauthorized",
			Message: "User ID not found",
		})
		return
	}

	userID, ok := userIDInterface.(uint)
	if !ok {
		c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
			Error:   "unauthorized",
			Message: "Invalid user ID",
		})
		return
	}

	var req requests.CheckoutRequest

	// Bind and validate request
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, responses.ErrorResponse{
			Error:   "validation_error",
			Message: err.Error(),
		})
		return
	}

	// Validate using method Validate()
	if err := req.Validate(); err != nil {
		c.JSON(http.StatusBadRequest, responses.ErrorResponse{
			Error:   "validation_error",
			Message: err.Error(),
		})
		return
	}

	// Call service to process checkout
	response, err := h.checkoutService.ProcessCheckout(userID, req)
	if err != nil {
		c.JSON(http.StatusBadRequest, responses.ErrorResponse{
			Error:   "checkout_failed",
			Message: err.Error(),
		})
		return
	}

	c.JSON(http.StatusCreated, responses.SuccessResponse{
		Message: "Checkout processed successfully",
		Data:    response,
	})
}</code></pre>

                    <h3>üìù 5. Menambahkan Routes di main.go</h3>
                    <p>Kita perlu menambahkan routes untuk checkout di file <code>main.go</code>:</p>
                    
                    <pre><code>// Initialize handlers
checkoutHandler := handlers.NewCheckoutHandler()

// Checkout routes (customer only)
checkout := protected.Group("/checkout")
{
	checkout.POST("/summary", checkoutHandler.GetCheckoutSummary)
	checkout.POST("", checkoutHandler.ProcessCheckout)
	checkout.POST("/:transaction_id/confirm", checkoutHandler.ConfirmPayment)
	checkout.GET("/transactions", checkoutHandler.GetUserTransactions)
	checkout.GET("/transactions/:transaction_id", checkoutHandler.GetTransactionByID)
}</code></pre>

                    <h3>üß™ Testing API</h3>
                    <p>Sekarang kita akan test API checkout yang sudah dibuat. Pastikan server sudah berjalan:</p>
                    
                    <h4>1. Test Get Checkout Summary</h4>
                    <pre><code>POST /api/v1/checkout/summary
Authorization: Bearer YOUR_JWT_TOKEN
Content-Type: application/json

{
    "shipping_address": "Jl. Sudirman No. 123, Jakarta",
    "payment_method": "bank_transfer",
    "notes": "Please deliver in the morning"
}</code></pre>

                    <h4>2. Test Process Checkout</h4>
                    <pre><code>POST /api/v1/checkout
Authorization: Bearer YOUR_JWT_TOKEN
Content-Type: application/json

{
    "shipping_address": "Jl. Sudirman No. 123, Jakarta",
    "payment_method": "bank_transfer",
    "notes": "Please deliver in the morning"
}</code></pre>

                    <h4>3. Test Confirm Payment</h4>
                    <pre><code>POST /api/v1/checkout/1/confirm
Authorization: Bearer YOUR_JWT_TOKEN
Content-Type: application/json

{
    "payment_proof": "payment_receipt_123.jpg",
    "notes": "Payment completed via bank transfer"
}</code></pre>

                    <h4>4. Test Get User Transactions</h4>
                    <pre><code>GET /api/v1/checkout/transactions
Authorization: Bearer YOUR_JWT_TOKEN</code></pre>

                    <h3>üìä Response Examples</h3>
                    
                    <h4>Checkout Summary Response</h4>
                    <pre><code>{
    "message": "Checkout summary retrieved successfully",
    "data": {
        "total_items": 3,
        "total_amount": 150000,
        "shipping_cost": 15000,
        "grand_total": 165000,
        "payment_method": "bank_transfer",
        "shipping_address": "Jl. Sudirman No. 123, Jakarta"
    }
}</code></pre>

                    <h4>Process Checkout Response</h4>
                    <pre><code>{
    "message": "Checkout processed successfully",
    "data": {
        "transaction_id": 1,
        "user_id": 1,
        "status": "pending",
        "total_amount": 165000,
        "shipping_address": "Jl. Sudirman No. 123, Jakarta",
        "payment_method": "bank_transfer",
        "payment_url": "https://payment.example.com/bank-transfer?transaction_id=1",
        "items": [
            {
                "product_id": 1,
                "product_name": "Laptop Gaming",
                "product_price": 100000,
                "quantity": 1,
                "subtotal": 100000
            },
            {
                "product_id": 2,
                "product_name": "Mouse Wireless",
                "product_price": 50000,
                "quantity": 1,
                "subtotal": 50000
            }
        ],
        "created_at": "2024-01-15 10:30:00",
        "updated_at": "2024-01-15 10:30:00"
    }
}</code></pre>

                    <h3>üîß Fitur Tambahan</h3>
                    <p>Berikut adalah beberapa fitur tambahan yang bisa dikembangkan:</p>
                    
                    <h4>1. Shipping Cost Calculation</h4>
                    <pre><code>func (s *CheckoutService) calculateShippingCost(carts []models.Cart) float64 {
	var totalWeight float64
	for _, cart := range carts {
		totalWeight += float64(cart.Quantity)
	}

	// Shipping cost: 5000 per kg, minimum 10000
	shippingCost := totalWeight * 5000
	if shippingCost < 10000 {
		shippingCost = 10000
	}

	return shippingCost
}</code></pre>

                    <h4>2. Payment URL Generation</h4>
                    <pre><code>func (s *CheckoutService) generatePaymentURL(transactionID uint, paymentMethod string) string {
	baseURL := "https://payment.example.com"

	switch paymentMethod {
	case "bank_transfer":
		return fmt.Sprintf("%s/bank-transfer?transaction_id=%d", baseURL, transactionID)
	case "credit_card":
		return fmt.Sprintf("%s/credit-card?transaction_id=%d", baseURL, transactionID)
	case "e_wallet":
		return fmt.Sprintf("%s/e-wallet?transaction_id=%d", baseURL, transactionID)
	case "cod":
		return "" // COD doesn't need payment URL
	default:
		return fmt.Sprintf("%s/payment?transaction_id=%d", baseURL, transactionID)
	}
}</code></pre>

                    <h3>üéØ Kesimpulan</h3>
                    <p>Selamat! Anda telah berhasil membuat Checkout & Payment API yang lengkap. Berikut adalah ringkasan apa yang telah kita buat:</p>
                    
                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #2e7d32; margin-bottom: 1rem;">‚úÖ Fitur yang Telah Dibuat</h4>
                        <ul style="color: #388e3c;">
                            <li>‚úÖ <strong>Checkout Summary</strong> - Ringkasan checkout dengan perhitungan biaya</li>
                            <li>‚úÖ <strong>Process Checkout</strong> - Proses checkout dari cart ke transaksi</li>
                            <li>‚úÖ <strong>Stock Validation</strong> - Validasi stok produk sebelum checkout</li>
                            <li>‚úÖ <strong>Transaction Creation</strong> - Pembuatan transaksi dan detail transaksi</li>
                            <li>‚úÖ <strong>Payment URL Generation</strong> - Generate URL pembayaran</li>
                            <li>‚úÖ <strong>Cart Clearing</strong> - Mengosongkan cart setelah checkout</li>
                            <li>‚úÖ <strong>Payment Confirmation</strong> - Konfirmasi pembayaran</li>
                            <li>‚úÖ <strong>Transaction Tracking</strong> - Melacak status transaksi</li>
                        </ul>
                    </div>

                    <div style="background: #fff3cd; border: 1px solid #ffc107; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #856404; margin-bottom: 1rem;">üöÄ Pengembangan Selanjutnya</h4>
                        <ul style="color: #856404;">
                            <li>‚úÖ <strong>Payment Gateway Integration</strong> - Integrasi dengan payment gateway nyata</li>
                            <li>‚úÖ <strong>Order Status Management</strong> - Manajemen status pesanan (shipped, delivered)</li>
                            <li>‚úÖ <strong>Email Notifications</strong> - Notifikasi email untuk transaksi</li>
                            <li>‚úÖ <strong>Invoice Generation</strong> - Generate invoice PDF</li>
                            <li>‚úÖ <strong>Refund System</strong> - Sistem refund dan cancel order</li>
                            <li>‚úÖ <strong>Shipping Tracking</strong> - Tracking pengiriman</li>
                        </ul>
                    </div>

                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #2e7d32; margin-bottom: 1rem;">üå± Refleksi Pembelajaran</h4>
                        <p style="color: #388e3c; margin-bottom: 1rem;">Anda telah berhasil menguasai:</p>
                        <ul style="color: #388e3c;">
                            <li>‚úÖ <strong>Complex Business Logic</strong> - Logika bisnis yang kompleks untuk checkout</li>
                            <li>‚úÖ <strong>Transaction Management</strong> - Manajemen transaksi dan detail transaksi</li>
                            <li>‚úÖ <strong>Stock Management</strong> - Validasi dan update stok produk</li>
                            <li>‚úÖ <strong>Payment Processing</strong> - Proses pembayaran dan konfirmasi</li>
                            <li>‚úÖ <strong>Data Relationships</strong> - Relasi kompleks antara User, Cart, Product, dan Transaction</li>
                            <li>‚úÖ <strong>Error Handling</strong> - Penanganan error yang komprehensif</li>
                        </ul>
                        <p style="color: #2e7d32; margin-top: 1rem; font-style: italic;">"Checkout yang aman dan user-friendly adalah kunci sukses e-commerce. Dengan sistem yang terintegrasi, customer dapat melakukan pembelian dengan percaya diri dan transparan."</p>
                    </div>
                `
            },
            {
                id: 'chapter20',
                title: 'Bab 20: Security Best Practices & Production Readiness - Keamanan Aplikasi Go',
                meta: 'Halaman 21 dari 55 ‚Ä¢ Dibaca 30 menit',
                content: `
                    <h2>üîí Bab 20: Security Best Practices & Production Readiness - Keamanan Aplikasi Go</h2>
                    <p>Selamat! Setelah berhasil membangun API toko online yang lengkap, sekarang saatnya kita mempelajari aspek keamanan yang sangat penting untuk aplikasi production. Di bab ini, kita akan menganalisis kelemahan keamanan yang ada di project TokoGo dan memperbaikinya dengan best practices yang sesuai dengan standar industri.</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">üéØ Apa yang Akan Kita Pelajari di Bab Ini?</h3>
                        <p style="color: #495057; margin-bottom: 0;">Kita akan menganalisis kelemahan keamanan yang ada di project TokoGo, memperbaikinya dengan implementasi security best practices, dan mempersiapkan aplikasi untuk production deployment yang aman dan reliable.</p>
                    </div>

                    <h3>üîç Analisis Kelemahan Keamanan di Project TokoGo</h3>
                    <p>Mari kita mulai dengan menganalisis kelemahan keamanan yang ada di project TokoGo kita:</p>

                    <h4>1. üî¥ CRITICAL - JWT Secret Hardcoded</h4>
                    <p><strong>Masalah:</strong> JWT secret di-hardcode di file <code>helpers/jwt.go</code></p>
                    
                    <div style="background: #ffebee; border: 1px solid #f44336; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #c62828; margin-bottom: 1rem;">‚ùå Kode yang Bermasalah:</h5>
                        <pre><code>// helpers/jwt.go - BARIS 12
var jwtSecret = []byte("your-secret-key") // Gunakan dari environment variable</code></pre>
                        <p style="color: #d32f2f; margin-bottom: 0;"><strong>Risiko:</strong> JWT secret yang sama di semua environment, mudah ditebak, dan tidak aman untuk production.</p>
                    </div>

                    <h4>2. üî¥ CRITICAL - CORS Terlalu Permissive</h4>
                    <p><strong>Masalah:</strong> CORS mengizinkan semua domain (<code>*</code>)</p>
                    
                    <div style="background: #ffebee; border: 1px solid #f44336; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #c62828; margin-bottom: 1rem;">‚ùå Kode yang Bermasalah:</h5>
                        <pre><code>// main.go - BARIS 28
AllowOrigins: []string{"*"},</code></pre>
                        <p style="color: #d32f2f; margin-bottom: 0;"><strong>Risiko:</strong> Memungkinkan request dari domain manapun, berpotensi untuk CSRF attacks.</p>
                    </div>

                    <h4>3. üü° MEDIUM - Tidak Ada Rate Limiting</h4>
                    <p><strong>Masalah:</strong> Tidak ada protection terhadap brute force attacks</p>
                    
                    <div style="background: #fff3e0; border: 1px solid #ff9800; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #e65100; margin-bottom: 1rem;">‚ö†Ô∏è Risiko:</h5>
                        <ul style="color: #e65100;">
                            <li>Brute force attack pada endpoint login</li>
                            <li>DDoS attacks</li>
                            <li>Resource exhaustion</li>
                        </ul>
                    </div>

                    <h4>4. üü° MEDIUM - Tidak Ada Security Headers</h4>
                    <p><strong>Masalah:</strong> Tidak ada security headers untuk melindungi dari berbagai serangan</p>

                    <h4>5. üü° MEDIUM - Tidak Ada Input Sanitization</h4>
                    <p><strong>Masalah:</strong> Tidak ada sanitization untuk XSS protection</p>

                    <h3>üõ†Ô∏è Implementasi Security Improvements</h3>
                    <p>Sekarang mari kita perbaiki kelemahan-kelemahan tersebut satu per satu:</p>

                    <h4>1. ‚úÖ Perbaikan JWT Secret Configuration</h4>
                    <p>Pertama, mari kita buat file <code>.env.example</code> untuk dokumentasi environment variables:</p>
                    
                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #2e7d32; margin-bottom: 1rem;">üìÑ File: .env.example</h5>
                        <pre><code># Database Configuration
DB_HOST=localhost
DB_PORT=5432
DB_USER=postgres
DB_PASSWORD=your_password
DB_NAME=tokogo_db

# JWT Configuration
JWT_SECRET=your-super-secret-jwt-key-here-make-it-long-and-random

# Server Configuration
SERVER_PORT=8080

# CORS Configuration
ALLOWED_ORIGINS=http://localhost:3000,http://localhost:8080

# Security Configuration
RATE_LIMIT_REQUESTS=100
RATE_LIMIT_WINDOW=60</code></pre>
                    </div>

                    <p>Sekarang mari kita update file <code>helpers/jwt.go</code>:</p>
                    
                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #2e7d32; margin-bottom: 1rem;">‚úÖ Kode yang Diperbaiki:</h5>
                        <pre><code>package helpers

import (
	"errors"
	"time"
	"tokogo/config"
	"tokogo/models"

	"github.com/golang-jwt/jwt"
)

// JWT secret dari environment variable
var jwtSecret = []byte(config.GetEnv("JWT_SECRET", "fallback-secret-key"))

// Claims struct untuk JWT claims
type Claims struct {
	UserID uint   \`json:"user_id"\`
	Email  string \`json:"email"\`
	Role   string \`json:"role"\`
	jwt.StandardClaims
}

// GenerateToken menghasilkan JWT token untuk user
func GenerateToken(user models.User) (string, error) {
	expirationTime := time.Now().Add(24 * time.Hour) // Token berlaku 24 jam

	claims := &Claims{
		UserID: user.ID,
		Email:  user.Email,
		Role:   user.Role,
		StandardClaims: jwt.StandardClaims{
			ExpiresAt: expirationTime.Unix(),
			IssuedAt:  time.Now().Unix(),
		},
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString(jwtSecret)

	if err != nil {
		return "", err
	}

	return tokenString, nil
}

func ValidateToken(tokenString string) (*Claims, error) {
	claims := &Claims{}

	token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
		return jwtSecret, nil
	})

	if err != nil {
		return nil, err
	}

	if !token.Valid {
		return nil, errors.New("invalid token")
	}

	return claims, nil
}</code></pre>
                    </div>

                    <h4>2. ‚úÖ Perbaikan CORS Configuration</h4>
                    <p>Mari kita update file <code>main.go</code> untuk menggunakan environment variable:</p>
                    
                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #2e7d32; margin-bottom: 1rem;">‚úÖ Kode yang Diperbaiki:</h5>
                        <pre><code>// CORS middleware
allowedOrigins := config.GetEnv("ALLOWED_ORIGINS", "http://localhost:3000")
origins := strings.Split(allowedOrigins, ",")

r.Use(cors.New(cors.Config{
	AllowOrigins:     origins,
	AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
	AllowHeaders:     []string{"Origin", "Content-Type", "Accept", "Authorization"},
	ExposeHeaders:    []string{"Content-Length"},
	AllowCredentials: true,
	MaxAge:           12 * time.Hour,
}))</code></pre>
                    </div>

                    <h4>3. ‚úÖ Implementasi Rate Limiting</h4>
                    <p>Mari kita buat middleware untuk rate limiting:</p>
                    
                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #2e7d32; margin-bottom: 1rem;">üìÑ File: middlewares/rate_limit.go</h5>
                        <pre><code>package middlewares

import (
	"net/http"
	"strconv"
	"sync"
	"time"
	"tokogo/config"
	"tokogo/responses"

	"github.com/gin-gonic/gin"
)

// RateLimiter struct untuk menyimpan rate limit data
type RateLimiter struct {
	requests map[string][]time.Time
	mutex    sync.RWMutex
}

// NewRateLimiter membuat instance baru RateLimiter
func NewRateLimiter() *RateLimiter {
	return &RateLimiter{
		requests: make(map[string][]time.Time),
	}
}

// Global rate limiter instance
var rateLimiter = NewRateLimiter()

// RateLimitMiddleware middleware untuk rate limiting
func RateLimitMiddleware() gin.HandlerFunc {
	maxRequests, _ := strconv.Atoi(config.GetEnv("RATE_LIMIT_REQUESTS", "100"))
	windowMinutes, _ := strconv.Atoi(config.GetEnv("RATE_LIMIT_WINDOW", "60"))
	window := time.Duration(windowMinutes) * time.Minute

	return func(c *gin.Context) {
		clientIP := c.ClientIP()
		now := time.Now()

		rateLimiter.mutex.Lock()
		defer rateLimiter.mutex.Unlock()

		// Clean old requests
		if requests, exists := rateLimiter.requests[clientIP]; exists {
			var validRequests []time.Time
			for _, reqTime := range requests {
				if now.Sub(reqTime) < window {
					validRequests = append(validRequests, reqTime)
				}
			}
			rateLimiter.requests[clientIP] = validRequests
		}

		// Check if limit exceeded
		if len(rateLimiter.requests[clientIP]) >= maxRequests {
			c.JSON(http.StatusTooManyRequests, responses.ErrorResponse{
				Error:   "rate_limit_exceeded",
				Message: "Too many requests. Please try again later.",
			})
			c.Abort()
			return
		}

		// Add current request
		rateLimiter.requests[clientIP] = append(rateLimiter.requests[clientIP], now)
		c.Next()
	}
}</code></pre>
                    </div>

                    <h4>4. ‚úÖ Implementasi Security Headers</h4>
                    <p>Mari kita buat middleware untuk security headers:</p>
                    
                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #2e7d32; margin-bottom: 1rem;">üìÑ File: middlewares/security.go</h5>
                        <pre><code>package middlewares

import (
	"github.com/gin-gonic/gin"
)

// SecurityHeadersMiddleware middleware untuk menambahkan security headers
func SecurityHeadersMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		// Prevent MIME type sniffing
		c.Header("X-Content-Type-Options", "nosniff")
		
		// Prevent clickjacking
		c.Header("X-Frame-Options", "DENY")
		
		// XSS Protection
		c.Header("X-XSS-Protection", "1; mode=block")
		
		// Strict Transport Security (HTTPS only)
		c.Header("Strict-Transport-Security", "max-age=31536000; includeSubDomains")
		
		// Content Security Policy
		c.Header("Content-Security-Policy", "default-src 'self'")
		
		// Referrer Policy
		c.Header("Referrer-Policy", "strict-origin-when-cross-origin")
		
		c.Next()
	}
}</code></pre>
                    </div>

                    <h4>5. ‚úÖ Implementasi Input Sanitization</h4>
                    <p>Mari kita buat helper untuk input sanitization:</p>
                    
                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #2e7d32; margin-bottom: 1rem;">üìÑ File: helpers/sanitizer.go</h5>
                        <pre><code>package helpers

import (
	"html"
	"regexp"
	"strings"
)

// SanitizeInput membersihkan input dari karakter berbahaya
func SanitizeInput(input string) string {
	// Escape HTML characters
	sanitized := html.EscapeString(input)
	
	// Remove extra whitespace
	sanitized = strings.TrimSpace(sanitized)
	
	// Remove multiple spaces
	spaceRegex := regexp.MustCompile(\`\\s+\`)
	sanitized = spaceRegex.ReplaceAllString(sanitized, " ")
	
	return sanitized
}

// SanitizeEmail membersihkan email input
func SanitizeEmail(email string) string {
	// Convert to lowercase
	email = strings.ToLower(strings.TrimSpace(email))
	
	// Basic email validation regex
	emailRegex := regexp.MustCompile(\`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\`)
	if !emailRegex.MatchString(email) {
		return ""
	}
	
	return email
}

// SanitizePassword memvalidasi password
func SanitizePassword(password string) (string, error) {
	if len(password) < 8 {
		return "", errors.New("password must be at least 8 characters long")
	}
	
	// Check for at least one uppercase letter
	upperRegex := regexp.MustCompile(\`[A-Z]\`)
	if !upperRegex.MatchString(password) {
		return "", errors.New("password must contain at least one uppercase letter")
	}
	
	// Check for at least one lowercase letter
	lowerRegex := regexp.MustCompile(\`[a-z]\`)
	if !lowerRegex.MatchString(password) {
		return "", errors.New("password must contain at least one lowercase letter")
	}
	
	// Check for at least one number
	numberRegex := regexp.MustCompile(\`[0-9]\`)
	if !numberRegex.MatchString(password) {
		return "", errors.New("password must contain at least one number")
	}
	
	return password, nil
}</code></pre>
                    </div>

                    <h4>6. ‚úÖ Environment Variables Validation</h4>
                    <p>Mari kita update file <code>config/env.go</code> untuk menambahkan validation:</p>
                    
                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #2e7d32; margin-bottom: 1rem;">‚úÖ Kode yang Diperbaiki:</h5>
                        <pre><code>package config

import (
	"fmt"
	"os"
)

func GetEnv(key, defaultVal string) string {
	if value, exists := os.LookupEnv(key); exists && value != "" {
		return value
	}
	return defaultVal
}

// ValidateEnvironment memvalidasi environment variables yang diperlukan
func ValidateEnvironment() error {
	required := []string{
		"JWT_SECRET",
		"DB_HOST", 
		"DB_USER",
		"DB_PASSWORD",
		"DB_NAME",
	}
	
	for _, key := range required {
		if os.Getenv(key) == "" {
			return fmt.Errorf("required environment variable %s is not set", key)
		}
	}
	
	// Validasi JWT secret minimal 32 karakter
	jwtSecret := os.Getenv("JWT_SECRET")
	if len(jwtSecret) < 32 {
		return fmt.Errorf("JWT_SECRET must be at least 32 characters long")
	}
	
	return nil
}</code></pre>
                    </div>

                    <h3>üîß Update main.go dengan Security Improvements</h3>
                    <p>Sekarang mari kita update file <code>main.go</code> untuk menggunakan semua security improvements:</p>
                    
                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #2e7d32; margin-bottom: 1rem;">‚úÖ Kode yang Diperbaiki:</h5>
                        <pre><code>package main

import (
	"log"
	"strings"
	"time"
	"tokogo/config"
	"tokogo/handlers"
	"tokogo/middlewares"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
	"github.com/joho/godotenv"
)

func main() {
	// Load environment variables
	if err := godotenv.Load(); err != nil {
		log.Println("No .env file found, using system environment variables")
	}

	// Validate environment variables
	if err := config.ValidateEnvironment(); err != nil {
		log.Fatalf("Environment validation failed: %v", err)
	}

	// Initialize database
	config.InitDB()

	// Setup Gin router
	r := gin.Default()

	// Security headers middleware
	r.Use(middlewares.SecurityHeadersMiddleware())

	// Rate limiting middleware
	r.Use(middlewares.RateLimitMiddleware())

	// CORS middleware dengan konfigurasi yang aman
	allowedOrigins := config.GetEnv("ALLOWED_ORIGINS", "http://localhost:3000")
	origins := strings.Split(allowedOrigins, ",")

	r.Use(cors.New(cors.Config{
		AllowOrigins:     origins,
		AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowHeaders:     []string{"Origin", "Content-Type", "Accept", "Authorization"},
		ExposeHeaders:    []string{"Content-Length"},
		AllowCredentials: true,
		MaxAge:           12 * time.Hour,
	}))

	// Static file serving untuk uploaded images
	r.Static("/uploads", "./uploads")

	// Health check endpoint
	r.GET("/health", func(c *gin.Context) {
		c.JSON(200, gin.H{
			"status":    "healthy",
			"timestamp": time.Now().Unix(),
		})
	})

	// Initialize handlers
	authHandler := handlers.NewAuthHandler()
	categoryHandler := handlers.NewCategoryHandler()
	productHandler := handlers.NewProductHandler()
	userManagementHandler := handlers.NewUserManagementHandler()
	transactionHandler := handlers.NewTransactionHandler()
	profileHandler := handlers.NewProfileHandler()
	cartHandler := handlers.NewCartHandler()
	checkoutHandler := handlers.NewCheckoutHandler()

	// Public routes (tidak perlu authentication)
	api := r.Group("/api/v1")
	{
		// Auth routes
		auth := api.Group("/auth")
		{
			auth.POST("/register", authHandler.Register)
			auth.POST("/login", authHandler.Login)
		}

		// Public routes (untuk customer)
		public := api.Group("/public")
		{
			categories := public.Group("/categories")
			{
				categories.GET("", categoryHandler.GetAllCategories)
			}

			products := public.Group("/products")
			{
				products.GET("", productHandler.GetAllProductsPublic)
				products.GET("/:id", productHandler.GetProductByIDPublic)
				products.GET("/categories/:category_id", productHandler.GetProductsByCategoryPublic)
			}
		}
	}

	// Protected routes (perlu authentication)
	protected := r.Group("/api/v1")
	protected.Use(middlewares.AuthMiddleware())
	{
		// Auth protected routes
		auth := protected.Group("/auth")
		{
			auth.POST("/logout", authHandler.Logout)
			auth.GET("/profile", authHandler.GetProfile)
			auth.GET("/profile", profileHandler.GetProfile)
			auth.PUT("/profile", profileHandler.UpdateProfile)
			auth.PUT("/change-password", profileHandler.ChangeUserPassword)
		}

		// Cart routes (customer only)
		cart := protected.Group("/cart")
		{
			cart.POST("", cartHandler.AddToCart)
			cart.GET("", cartHandler.GetCart)
			cart.PUT("/:product_id", cartHandler.UpdateCartItem)
			cart.DELETE("/:product_id", cartHandler.RemoveFromCart)
			cart.DELETE("/clear", cartHandler.ClearCart)
			cart.GET("/count", cartHandler.GetCartItemCount)
		}

		// Checkout routes (customer only)
		checkout := protected.Group("/checkout")
		{
			checkout.POST("/summary", checkoutHandler.GetCheckoutSummary)
			checkout.POST("", checkoutHandler.ProcessCheckout)
			checkout.POST("/:transaction_id/confirm", checkoutHandler.ConfirmPayment)
			checkout.GET("/transactions", checkoutHandler.GetUserTransactions)
			checkout.GET("/transactions/:transaction_id", checkoutHandler.GetTransactionByID)
		}

		// Admin routes (perlu admin role)
		admin := protected.Group("/admin")
		admin.Use(middlewares.AdminMiddleware())
		{
			admin.GET("/dashboard", func(c *gin.Context) {
				c.JSON(200, gin.H{
					"message": "Welcome to admin dashboard",
					"user_id": c.GetUint("user_id"),
				})
			})

			categories := admin.Group("/categories")
			{
				categories.POST("", categoryHandler.CreateCategory)
				categories.GET("", categoryHandler.GetAllCategories)
				categories.GET("/:id", categoryHandler.GetCategoryByID)
				categories.PUT("/:id", categoryHandler.UpdateCategory)
				categories.DELETE("/:id", categoryHandler.DeleteCategory)
			}

			products := admin.Group("/products")
			{
				products.POST("", productHandler.CreateProduct)
				products.GET("", productHandler.GetAllProducts)
				products.GET("/:id", productHandler.GetProductByID)
				products.PUT("/:id", productHandler.UpdateProduct)
				products.DELETE("/:id", productHandler.DeleteProduct)
				products.GET("/categories/:category_id", productHandler.GetProductsByCategory)
			}

			userManagement := admin.Group("/user-management")
			{
				userManagement.POST("", userManagementHandler.CreateUser)
				userManagement.GET("", userManagementHandler.GetAllUsers)
				userManagement.GET("/:id", userManagementHandler.GetUserByID)
				userManagement.PUT("/:id", userManagementHandler.UpdateUser)
				userManagement.DELETE("/:id", userManagementHandler.DeleteUser)
			}

			transactions := admin.Group("/transactions")
			{
				transactions.GET("", transactionHandler.GetAllTransactions)
				transactions.GET("/:id", transactionHandler.GetTransactionByID)
				transactions.PUT("/:id/status", transactionHandler.UpdateTransactionStatus)
			}
		}
	}

	// Start server
	port := config.GetEnv("SERVER_PORT", "8080")
	log.Printf("üöÄ Server starting on port %s with security improvements", port)
	r.Run(":" + port)
}</code></pre>
                    </div>

                    <h3>üìä Security Monitoring & Logging</h3>
                    <p>Mari kita tambahkan security logging untuk monitoring:</p>
                    
                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #2e7d32; margin-bottom: 1rem;">üìÑ File: helpers/security_logger.go</h5>
                        <pre><code>package helpers

import (
	"log"
	"time"
)

// SecurityEvent struct untuk logging security events
type SecurityEvent struct {
	Event     string                 \`json:"event"\`
	IP        string                 \`json:"ip"\`
	UserAgent string                 \`json:"user_agent"\`
	Details   map[string]interface{} \`json:"details"\`
	Timestamp time.Time              \`json:"timestamp"\`
}

// LogSecurityEvent mencatat security event
func LogSecurityEvent(event string, ip, userAgent string, details map[string]interface{}) {
	securityEvent := SecurityEvent{
		Event:     event,
		IP:        ip,
		UserAgent: userAgent,
		Details:   details,
		Timestamp: time.Now(),
	}
	
	log.Printf("SECURITY_EVENT: %+v", securityEvent)
}

// LogFailedLogin mencatat failed login attempt
func LogFailedLogin(email, ip, userAgent string) {
	LogSecurityEvent("failed_login", ip, userAgent, map[string]interface{}{
		"email": email,
	})
}

// LogSuccessfulLogin mencatat successful login
func LogSuccessfulLogin(userID uint, email, ip, userAgent string) {
	LogSecurityEvent("successful_login", ip, userAgent, map[string]interface{}{
		"user_id": userID,
		"email":   email,
	})
}

// LogRateLimitExceeded mencatat rate limit exceeded
func LogRateLimitExceeded(ip, userAgent string) {
	LogSecurityEvent("rate_limit_exceeded", ip, userAgent, map[string]interface{}{
		"limit": "exceeded",
	})
}</code></pre>
                    </div>

                    <h3>üê≥ Docker Configuration untuk Production</h3>
                    <p>Mari kita buat Docker configuration untuk production deployment:</p>
                    
                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #2e7d32; margin-bottom: 1rem;">üìÑ File: Dockerfile</h5>
                        <pre><code># Build stage
FROM golang:1.21-alpine AS builder

# Set working directory
WORKDIR /app

# Install dependencies
RUN apk add --no-cache git

# Copy go mod files
COPY go.mod go.sum ./

# Download dependencies
RUN go mod download

# Copy source code
COPY . .

# Build the application
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .

# Final stage
FROM alpine:latest

# Install ca-certificates for HTTPS
RUN apk --no-cache add ca-certificates

# Create non-root user
RUN adduser -D -s /bin/sh appuser

# Set working directory
WORKDIR /root/

# Copy the binary from builder stage
COPY --from=builder /app/main .

# Copy uploads directory
COPY --from=builder /app/uploads ./uploads

# Change ownership to non-root user
RUN chown -R appuser:appuser /root/

# Switch to non-root user
USER appuser

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\
  CMD wget --no-verbose --tries=1 --spider http://localhost:8080/health || exit 1

# Run the application
CMD ["./main"]</code></pre>
                    </div>

                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #2e7d32; margin-bottom: 1rem;">üìÑ File: docker-compose.yml</h5>
                        <pre><code>version: '3.8'

services:
  app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - DB_HOST=postgres
      - DB_PORT=5432
      - DB_USER=postgres
      - DB_PASSWORD=your_password
      - DB_NAME=tokogo_db
      - JWT_SECRET=your-super-secret-jwt-key-here-make-it-long-and-random
      - ALLOWED_ORIGINS=http://localhost:3000,https://yourdomain.com
      - RATE_LIMIT_REQUESTS=100
      - RATE_LIMIT_WINDOW=60
    depends_on:
      - postgres
    restart: unless-stopped

  postgres:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=tokogo_db
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=your_password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    restart: unless-stopped

volumes:
  postgres_data:</code></pre>
                    </div>

                    <h3>üéØ Kesimpulan Security Improvements</h3>
                    <p>Selamat! Anda telah berhasil mengimplementasikan security best practices untuk aplikasi TokoGo. Berikut adalah ringkasan perbaikan yang telah dilakukan:</p>
                    
                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #2e7d32; margin-bottom: 1rem;">‚úÖ Security Improvements yang Telah Diimplementasikan</h4>
                        <ul style="color: #388e3c;">
                            <li>‚úÖ <strong>JWT Secret Configuration</strong> - Menggunakan environment variable</li>
                            <li>‚úÖ <strong>CORS Security</strong> - Konfigurasi CORS yang aman</li>
                            <li>‚úÖ <strong>Rate Limiting</strong> - Protection terhadap brute force attacks</li>
                            <li>‚úÖ <strong>Security Headers</strong> - Headers untuk melindungi dari berbagai serangan</li>
                            <li>‚úÖ <strong>Input Sanitization</strong> - Sanitization untuk XSS protection</li>
                            <li>‚úÖ <strong>Environment Validation</strong> - Validasi environment variables</li>
                            <li>‚úÖ <strong>Security Logging</strong> - Logging untuk monitoring security events</li>
                            <li>‚úÖ <strong>Docker Configuration</strong> - Production-ready container setup</li>
                        </ul>
                    </div>

                    <div style="background: #fff3cd; border: 1px solid #ffc107; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #856404; margin-bottom: 1rem;">üöÄ Pengembangan Security Selanjutnya</h4>
                        <ul style="color: #856404;">
                            <li>‚úÖ <strong>Two-Factor Authentication (2FA)</strong> - Tambahan layer keamanan</li>
                            <li>‚úÖ <strong>Password Reset System</strong> - Sistem reset password yang aman</li>
                            <li>‚úÖ <strong>Email Verification</strong> - Verifikasi email untuk registrasi</li>
                            <li>‚úÖ <strong>API Key Management</strong> - Manajemen API keys untuk external access</li>
                            <li>‚úÖ <strong>Audit Logging</strong> - Logging untuk compliance dan monitoring</li>
                            <li>‚úÖ <strong>Encryption at Rest</strong> - Enkripsi data sensitif di database</li>
                        </ul>
                    </div>

                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #2e7d32; margin-bottom: 1rem;">üå± Refleksi Pembelajaran Security</h4>
                        <p style="color: #388e3c; margin-bottom: 1rem;">Anda telah berhasil menguasai:</p>
                        <ul style="color: #388e3c;">
                            <li>‚úÖ <strong>Security Best Practices</strong> - Implementasi security yang sesuai standar industri</li>
                            <li>‚úÖ <strong>Environment Configuration</strong> - Manajemen konfigurasi yang aman</li>
                            <li>‚úÖ <strong>Middleware Development</strong> - Pembuatan middleware untuk security</li>
                            <li>‚úÖ <strong>Input Validation & Sanitization</strong> - Validasi dan sanitasi input</li>
                            <li>‚úÖ <strong>Rate Limiting</strong> - Protection terhadap abuse dan attacks</li>
                            <li>‚úÖ <strong>Security Headers</strong> - Headers untuk melindungi aplikasi</li>
                            <li>‚úÖ <strong>Production Deployment</strong> - Persiapan aplikasi untuk production</li>
                            <li>‚úÖ <strong>Security Monitoring</strong> - Logging dan monitoring security events</li>
                        </ul>
                        <p style="color: #2e7d32; margin-top: 1rem; font-style: italic;">"Security bukanlah fitur yang ditambahkan di akhir, tetapi fondasi yang harus dibangun dari awal. Dengan implementasi yang tepat, aplikasi kita menjadi aman, reliable, dan siap untuk production."</p>
                    </div>

                    <h3>üìö Referensi Security</h3>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #2c3e50; margin-bottom: 1rem;">üîó Sumber Belajar Tambahan</h4>
                        <ul style="color: #495057;">
                            <li><strong>OWASP Top 10</strong> - https://owasp.org/www-project-top-ten/</li>
                            <li><strong>Go Security Best Practices</strong> - https://golang.org/doc/security</li>
                            <li><strong>JWT Security Guidelines</strong> - https://tools.ietf.org/html/rfc7519</li>
                            <li><strong>CORS Security</strong> - https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS</li>
                            <li><strong>Docker Security</strong> - https://docs.docker.com/engine/security/</li>
                        </ul>
                    </div>
                `
            },
            {
                id: 'chapter21',
                title: 'Bab 21: UAT & VPS Deployment - Testing & Production Deployment',
                meta: 'Halaman 22 dari 55 ‚Ä¢ Dibaca 25 menit',
                content: `
                    <h2>üöÄ Bab 21: UAT & VPS Deployment - Testing & Production Deployment</h2>
                    <p>Selamat! Setelah berhasil membangun API toko online yang lengkap dan aman, sekarang saatnya kita melakukan User Acceptance Testing (UAT) dan deployment ke VPS untuk production. Di bab ini, kita akan mempelajari cara melakukan testing yang komprehensif dan deployment yang professional.</p>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">üéØ Apa yang Akan Kita Pelajari di Bab Ini?</h3>
                        <p style="color: #495057; margin-bottom: 0;">Kita akan melakukan User Acceptance Testing (UAT) yang komprehensif, mempersiapkan aplikasi untuk production, dan melakukan deployment ke VPS dengan konfigurasi yang optimal untuk performa dan keamanan.</p>
                    </div>

                    <h3>üß™ User Acceptance Testing (UAT)</h3>
                    <p>User Acceptance Testing (UAT) adalah fase testing terakhir sebelum aplikasi di-deploy ke production. Tujuannya adalah memastikan aplikasi memenuhi requirement dan siap digunakan oleh end user. UAT dilakukan untuk memvalidasi bahwa aplikasi berfungsi sesuai dengan kebutuhan bisnis dan user experience yang diharapkan.</p>

                    <div style="background: #e3f2fd; border: 1px solid #2196f3; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h4 style="color: #1565c0; margin-bottom: 1rem;">üéØ Tujuan UAT</h4>
                        <ul style="color: #1565c0;">
                            <li>‚úÖ Memvalidasi fungsionalitas aplikasi sesuai requirement</li>
                            <li>‚úÖ Memastikan user experience yang baik</li>
                            <li>‚úÖ Mengidentifikasi bug atau issue sebelum production</li>
                            <li>‚úÖ Memverifikasi integrasi antar komponen</li>
                            <li>‚úÖ Memastikan performa aplikasi sesuai ekspektasi</li>
                        </ul>
                    </div>

                    <h4>üè† Local Testing Environment Setup</h4>
                    <p>Sebelum melakukan UAT, pastikan aplikasi berjalan dengan baik di local environment. Mari kita setup testing environment yang proper:</p>

                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #2e7d32; margin-bottom: 1rem;">üìÑ File: .env.test</h5>
                        <pre><code># Test Environment Configuration
DB_HOST=localhost
DB_PORT=5432
DB_USER=postgres
DB_PASSWORD=test_password
DB_NAME=tokogo_test_db
JWT_SECRET=test-jwt-secret-key-for-testing-only
SERVER_PORT=8081
ALLOWED_ORIGINS=http://localhost:3000,http://localhost:8081
RATE_LIMIT_REQUESTS=1000
RATE_LIMIT_WINDOW=60
GIN_MODE=test</code></pre>
                    </div>

                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #2e7d32; margin-bottom: 1rem;">üìÑ File: test/setup_test_db.sh</h5>
                        <pre><code>#!/bin/bash

# Setup Test Database
echo "üóÑÔ∏è Setting up test database..."

# Create test database
sudo -u postgres psql -c "DROP DATABASE IF EXISTS tokogo_test_db;"
sudo -u postgres psql -c "CREATE DATABASE tokogo_test_db;"
sudo -u postgres psql -c "GRANT ALL PRIVILEGES ON DATABASE tokogo_test_db TO postgres;"

echo "‚úÖ Test database created successfully!"

# Run migrations
echo "üîÑ Running database migrations..."
go run main.go migrate

echo "‚úÖ Test environment setup completed!"</code></pre>
                    </div>

                    <h4>üìã Manual Testing Guide - Local Environment</h4>
                    <p>Mari kita lakukan testing manual step-by-step di local environment. Pastikan aplikasi sudah running di <code>http://localhost:8080</code>:</p>

                    <div style="background: #fff3e0; border: 1px solid #ff9800; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #e65100; margin-bottom: 1rem;">üöÄ Step 1: Start Application</h5>
                        <pre><code># Terminal 1: Start the application
go run main.go

# Expected output:
# [GIN-debug] Listening and serving HTTP on :8080
# Database connected successfully!</code></pre>
                    </div>

                    <div style="background: #e3f2fd; border: 1px solid #2196f3; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #1565c0; margin-bottom: 1rem;">üîç Step 2: Health Check Test</h5>
                        <p style="color: #1565c0; margin-bottom: 1rem;">Test endpoint kesehatan aplikasi:</p>
                        <pre><code># Test dengan curl atau browser
curl http://localhost:8080/api/health

# Expected response:
# {"status": "OK", "message": "TokoGo API is running"}</code></pre>
                    </div>

                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #2e7d32; margin-bottom: 1rem;">üë§ Step 3: User Registration Test</h5>
                        <p style="color: #2e7d32; margin-bottom: 1rem;">Test registrasi user baru:</p>
                        <pre><code># Test registration
curl -X POST http://localhost:8080/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Test User",
    "email": "test@example.com",
    "password": "password123",
    "role": "customer"
  }'

# Expected response:
# {"message": "User registered successfully", "user": {...}}</code></pre>
                    </div>

                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #2e7d32; margin-bottom: 1rem;">üîê Step 4: User Login Test</h5>
                        <p style="color: #2e7d32; margin-bottom: 1rem;">Test login dan dapatkan JWT token:</p>
                        <pre><code># Test login
curl -X POST http://localhost:8080/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "password": "password123"
  }'

# Expected response:
# {"message": "Login successful", "token": "eyJhbGciOiJIUzI1NiIs...", "user": {...}}

# Simpan token untuk testing selanjutnya
export JWT_TOKEN="eyJhbGciOiJIUzI1NiIs..."</code></pre>
                    </div>

                    <div style="background: #f3e5f5; border: 1px solid #9c27b0; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #6a1b9a; margin-bottom: 1rem;">üõçÔ∏è Step 5: Product Management Test</h5>
                        <p style="color: #6a1b9a; margin-bottom: 1rem;">Test CRUD operations untuk products:</p>
                        <pre><code># 1. Get all products (public endpoint)
curl http://localhost:8080/api/products

# 2. Create new product (admin only)
curl -X POST http://localhost:8080/api/products \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $JWT_TOKEN" \
  -d '{
    "name": "Test Product",
    "description": "This is a test product",
    "price": 100000,
    "stock": 50,
    "category_id": 1
  }'

# 3. Get product by ID
curl http://localhost:8080/api/products/1

# 4. Update product
curl -X PUT http://localhost:8080/api/products/1 \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $JWT_TOKEN" \
  -d '{
    "name": "Updated Test Product",
    "price": 150000
  }'</code></pre>
                    </div>

                    <div style="background: #ffebee; border: 1px solid #f44336; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #c62828; margin-bottom: 1rem;">üõí Step 6: Shopping Cart Test</h5>
                        <p style="color: #c62828; margin-bottom: 1rem;">Test shopping cart functionality:</p>
                        <pre><code># 1. Add item to cart
curl -X POST http://localhost:8080/api/cart/add \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $JWT_TOKEN" \
  -d '{
    "product_id": 1,
    "quantity": 2
  }'

# 2. Get cart items
curl http://localhost:8080/api/cart \
  -H "Authorization: Bearer $JWT_TOKEN"

# 3. Update cart item quantity
curl -X PUT http://localhost:8080/api/cart/update \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $JWT_TOKEN" \
  -d '{
    "product_id": 1,
    "quantity": 3
  }'

# 4. Remove item from cart
curl -X DELETE http://localhost:8080/api/cart/remove/1 \
  -H "Authorization: Bearer $JWT_TOKEN"</code></pre>
                    </div>

                    <div style="background: #e0f2f1; border: 1px solid #00695c; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #004d40; margin-bottom: 1rem;">üí≥ Step 7: Checkout Process Test</h5>
                        <p style="color: #004d40; margin-bottom: 1rem;">Test complete checkout process:</p>
                        <pre><code># 1. Create checkout
curl -X POST http://localhost:8080/api/checkout \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $JWT_TOKEN" \
  -d '{
    "shipping_address": "123 Test Street, Test City",
    "payment_method": "credit_card",
    "notes": "Please deliver carefully"
  }'

# 2. Get transaction history
curl http://localhost:8080/api/transactions \
  -H "Authorization: Bearer $JWT_TOKEN"

# 3. Get transaction by ID
curl http://localhost:8080/api/transactions/1 \
  -H "Authorization: Bearer $JWT_TOKEN"</code></pre>
                    </div>

                    <h4>üìã UAT Checklist - Manual Testing</h4>
                    <div style="background: #e3f2fd; border: 1px solid #2196f3; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #1565c0; margin-bottom: 1rem;">‚úÖ Functional Testing Checklist</h5>
                        <ul style="color: #1565c0;">
                            <li>‚úÖ <strong>Health Check</strong> - API responds with status OK</li>
                            <li>‚úÖ <strong>User Registration</strong> - New user can register successfully</li>
                            <li>‚úÖ <strong>User Login</strong> - User can login and receive JWT token</li>
                            <li>‚úÖ <strong>Product Listing</strong> - Products can be retrieved (public)</li>
                            <li>‚úÖ <strong>Product CRUD</strong> - Admin can create, read, update, delete products</li>
                            <li>‚úÖ <strong>Category Management</strong> - Categories can be managed by admin</li>
                            <li>‚úÖ <strong>Shopping Cart</strong> - Add, update, remove items from cart</li>
                            <li>‚úÖ <strong>Checkout Process</strong> - Complete order creation</li>
                            <li>‚úÖ <strong>Transaction History</strong> - User can view order history</li>
                            <li>‚úÖ <strong>User Management</strong> - Admin can manage users</li>
                        </ul>
                    </div>

                    <h4>üõ†Ô∏è Testing dengan Postman</h4>
                    <p>Untuk testing yang lebih mudah dan terorganisir, kita bisa menggunakan Postman. File collection sudah tersedia di project:</p>

                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #2e7d32; margin-bottom: 1rem;">üìÑ Import Postman Collection</h5>
                        <pre><code># File: postman_collection.json sudah tersedia di project
# Import ke Postman dengan cara:
# 1. Buka Postman
# 2. Click Import
# 3. Select file postman_collection.json
# 4. Collection "TokoGo API" akan muncul</code></pre>
                    </div>

                    <div style="background: #e3f2fd; border: 1px solid #2196f3; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #1565c0; margin-bottom: 1rem;">üîß Postman Environment Setup</h5>
                        <p style="color: #1565c0; margin-bottom: 1rem;">Buat environment untuk testing:</p>
                        <pre><code># Environment Variables:
# base_url: http://localhost:8080
# jwt_token: (akan di-set otomatis setelah login)
# user_id: (akan di-set otomatis setelah login)</code></pre>
                    </div>

                    <div style="background: #f3e5f5; border: 1px solid #9c27b0; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #6a1b9a; margin-bottom: 1rem;">üìã Postman Testing Workflow</h5>
                        <ol style="color: #6a1b9a;">
                            <li><strong>Health Check</strong> - Test API connectivity</li>
                            <li><strong>Register User</strong> - Create test user account</li>
                            <li><strong>Login User</strong> - Get JWT token (auto-saved to environment)</li>
                            <li><strong>Create Category</strong> - Setup product categories</li>
                            <li><strong>Create Products</strong> - Add test products</li>
                            <li><strong>Add to Cart</strong> - Test shopping cart</li>
                            <li><strong>Checkout</strong> - Complete order process</li>
                            <li><strong>View Transactions</strong> - Check order history</li>
                        </ol>
                    </div>

                    <h4>üîí Security Testing</h4>
                    <div style="background: #fff3e0; border: 1px solid #ff9800; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #e65100; margin-bottom: 1rem;">üõ°Ô∏è Security Test Cases - Manual Testing</h5>
                        
                        <div style="background: #ffebee; border: 1px solid #f44336; padding: 1rem; border-radius: 5px; margin: 1rem 0;">
                            <h6 style="color: #c62828; margin-bottom: 0.5rem;">üîê Test 1: JWT Token Validation</h6>
                            <pre><code># Test dengan token yang invalid
curl -H "Authorization: Bearer invalid_token" http://localhost:8080/api/products

# Expected: 401 Unauthorized</code></pre>
                        </div>

                        <div style="background: #ffebee; border: 1px solid #f44336; padding: 1rem; border-radius: 5px; margin: 1rem 0;">
                            <h6 style="color: #c62828; margin-bottom: 0.5rem;">üîê Test 2: Access Control</h6>
                            <pre><code># Test customer trying to access admin endpoint
curl -H "Authorization: Bearer $CUSTOMER_TOKEN" \
  -X POST http://localhost:8080/api/products \
  -H "Content-Type: application/json" \
  -d '{"name": "Test Product"}'

# Expected: 403 Forbidden</code></pre>
                        </div>

                        <div style="background: #ffebee; border: 1px solid #f44336; padding: 1rem; border-radius: 5px; margin: 1rem 0;">
                            <h6 style="color: #c62828; margin-bottom: 0.5rem;">üîê Test 3: Input Validation</h6>
                            <pre><code># Test dengan input yang tidak valid
curl -X POST http://localhost:8080/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "name": "",
    "email": "invalid-email",
    "password": "123"
  }'

# Expected: 400 Bad Request dengan error message</code></pre>
                        </div>

                        <div style="background: #ffebee; border: 1px solid #f44336; padding: 1rem; border-radius: 5px; margin: 1rem 0;">
                            <h6 style="color: #c62828; margin-bottom: 0.5rem;">üîê Test 4: Rate Limiting</h6>
                            <pre><code># Test rate limiting dengan multiple requests
for i in {1..10}; do
  curl -X POST http://localhost:8080/api/auth/login \
    -H "Content-Type: application/json" \
    -d '{"email": "test@example.com", "password": "wrong"}'
done

# Expected: 429 Too Many Requests setelah limit</code></pre>
                        </div>
                    </div>

                    <h4>üåê Testing dengan Browser</h4>
                    <p>Untuk testing yang lebih visual, kita bisa menggunakan browser untuk test beberapa endpoint:</p>

                    <div style="background: #e3f2fd; border: 1px solid #2196f3; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #1565c0; margin-bottom: 1rem;">üîç Browser Testing URLs</h5>
                        <ul style="color: #1565c0;">
                            <li><strong>Health Check:</strong> <code>http://localhost:8080/api/health</code></li>
                            <li><strong>Products List:</strong> <code>http://localhost:8080/api/products</code></li>
                            <li><strong>Categories List:</strong> <code>http://localhost:8080/api/categories</code></li>
                        </ul>
                        <p style="color: #1565c0; margin-top: 1rem;">Buka URL tersebut di browser dan pastikan response JSON muncul dengan benar.</p>
                    </div>

                    <h4>üì± Testing dengan Tools Lainnya</h4>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #2c3e50; margin-bottom: 1rem;">üõ†Ô∏è Alternative Testing Tools</h5>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                            <div>
                                <h6 style="color: #495057;">Insomnia</h6>
                                <p style="color: #6c757d; font-size: 0.9rem;">GUI-based API testing tool, alternatif Postman</p>
                            </div>
                            <div>
                                <h6 style="color: #495057;">Thunder Client</h6>
                                <p style="color: #6c757d; font-size: 0.9rem;">VS Code extension untuk API testing</p>
                            </div>
                            <div>
                                <h6 style="color: #495057;">HTTPie</h6>
                                <p style="color: #6c757d; font-size: 0.9rem;">Command-line HTTP client yang user-friendly</p>
                            </div>
                            <div>
                                <h6 style="color: #495057;">REST Client</h6>
                                <p style="color: #6c757d; font-size: 0.9rem;">VS Code extension untuk HTTP requests</p>
                            </div>
                        </div>
                    </div>

                    <h4>üìä Performance Testing</h4>
                    <p>Mari kita buat script untuk performance testing menggunakan Apache Bench (ab):</p>
                    
                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #2e7d32; margin-bottom: 1rem;">üìÑ File: test/performance_test.sh</h5>
                        <pre><code>#!/bin/bash

# Performance Testing Script untuk TokoGo API
echo "üöÄ Starting Performance Testing for TokoGo API..."

# Test 1: Health Check
echo "üìä Testing Health Check Endpoint..."
ab -n 1000 -c 10 http://localhost:8080/api/health

# Test 2: Product List (Public)
echo "üìä Testing Product List Endpoint..."
ab -n 500 -c 5 http://localhost:8080/api/products

# Test 3: Login Endpoint
echo "üìä Testing Login Endpoint..."
ab -n 200 -c 5 -p login_data.json -T application/json http://localhost:8080/api/auth/login

# Test 4: Protected Endpoint (with token)
echo "üìä Testing Protected Endpoint..."
ab -n 300 -c 5 -H "Authorization: Bearer YOUR_JWT_TOKEN" http://localhost:8080/api/products

echo "‚úÖ Performance testing completed!"</code></pre>
                    </div>

                    <h4>üîß Troubleshooting Common Issues</h4>
                    <div style="background: #fff3e0; border: 1px solid #ff9800; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #e65100; margin-bottom: 1rem;">‚ö†Ô∏è Common Testing Issues & Solutions</h5>
                        
                        <div style="background: #ffebee; border: 1px solid #f44336; padding: 1rem; border-radius: 5px; margin: 1rem 0;">
                            <h6 style="color: #c62828; margin-bottom: 0.5rem;">‚ùå Issue: Connection Refused</h6>
                            <p style="color: #c62828; margin-bottom: 0.5rem;"><strong>Error:</strong> <code>curl: (7) Failed to connect to localhost port 8080: Connection refused</code></p>
                            <p style="color: #c62828; margin-bottom: 0;"><strong>Solution:</strong> Pastikan aplikasi sudah running dengan <code>go run main.go</code></p>
                        </div>

                        <div style="background: #ffebee; border: 1px solid #f44336; padding: 1rem; border-radius: 5px; margin: 1rem 0;">
                            <h6 style="color: #c62828; margin-bottom: 0.5rem;">‚ùå Issue: Database Connection Error</h6>
                            <p style="color: #c62828; margin-bottom: 0.5rem;"><strong>Error:</strong> <code>failed to connect to database</code></p>
                            <p style="color: #c62828; margin-bottom: 0;"><strong>Solution:</strong> Pastikan PostgreSQL running dan konfigurasi database benar di .env</p>
                        </div>

                        <div style="background: #ffebee; border: 1px solid #f44336; padding: 1rem; border-radius: 5px; margin: 1rem 0;">
                            <h6 style="color: #c62828; margin-bottom: 0.5rem;">‚ùå Issue: 401 Unauthorized</h6>
                            <p style="color: #c62828; margin-bottom: 0.5rem;"><strong>Error:</strong> <code>{"error": "Unauthorized"}</code></p>
                            <p style="color: #c62828; margin-bottom: 0;"><strong>Solution:</strong> Pastikan JWT token valid dan tidak expired</p>
                        </div>

                        <div style="background: #ffebee; border: 1px solid #f44336; padding: 1rem; border-radius: 5px; margin: 1rem 0;">
                            <h6 style="color: #c62828; margin-bottom: 0.5rem;">‚ùå Issue: 403 Forbidden</h6>
                            <p style="color: #c62828; margin-bottom: 0.5rem;"><strong>Error:</strong> <code>{"error": "Access denied"}</code></p>
                            <p style="color: #c62828; margin-bottom: 0;"><strong>Solution:</strong> Pastikan user memiliki role yang tepat (admin untuk admin endpoints)</p>
                        </div>
                    </div>

                    <h4>üí° Tips untuk Testing yang Efektif</h4>
                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #2e7d32; margin-bottom: 1rem;">üéØ Best Practices untuk Local Testing</h5>
                        <ul style="color: #2e7d32;">
                            <li>‚úÖ <strong>Gunakan Test Database</strong> - Jangan test di production database</li>
                            <li>‚úÖ <strong>Clean State</strong> - Reset database sebelum setiap test session</li>
                            <li>‚úÖ <strong>Test Data</strong> - Gunakan data test yang konsisten</li>
                            <li>‚úÖ <strong>Logging</strong> - Monitor application logs saat testing</li>
                            <li>‚úÖ <strong>Environment Variables</strong> - Pastikan .env file sudah benar</li>
                            <li>‚úÖ <strong>Dependencies</strong> - Pastikan semua dependencies terinstall</li>
                        </ul>
                    </div>

                    <h4>üß™ Automated Testing</h4>
                    <p>Mari kita buat comprehensive test suite:</p>
                    
                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #2e7d32; margin-bottom: 1rem;">üìÑ File: test/integration_test.go</h5>
                        <pre><code>package test

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"testing"
	"tokogo/config"
	"tokogo/models"
	"tokogo/routes"

	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
)

func TestMain(m *testing.M) {
	// Setup test environment
	config.LoadEnv(".env.test")
	gin.SetMode(gin.TestMode)
	
	// Run tests
	code := m.Run()
	
	// Cleanup
	// Add cleanup code here if needed
	
	// Exit
	os.Exit(code)
}

func TestHealthCheck(t *testing.T) {
	router := routes.SetupRoutes()
	
	w := httptest.NewRecorder()
	req, _ := http.NewRequest("GET", "/api/health", nil)
	router.ServeHTTP(w, req)
	
	assert.Equal(t, 200, w.Code)
	assert.Contains(t, w.Body.String(), "OK")
}

func TestUserRegistration(t *testing.T) {
	router := routes.SetupRoutes()
	
	userData := map[string]string{
		"name":     "Test User",
		"email":    "test@example.com",
		"password": "password123",
		"role":     "customer",
	}
	
	jsonData, _ := json.Marshal(userData)
	
	w := httptest.NewRecorder()
	req, _ := http.NewRequest("POST", "/api/auth/register", bytes.NewBuffer(jsonData))
	req.Header.Set("Content-Type", "application/json")
	
	router.ServeHTTP(w, req)
	
	assert.Equal(t, 201, w.Code)
	
	var response map[string]interface{}
	json.Unmarshal(w.Body.Bytes(), &response)
	assert.Equal(t, "User registered successfully", response["message"])
}

func TestUserLogin(t *testing.T) {
	router := routes.SetupRoutes()
	
	loginData := map[string]string{
		"email":    "test@example.com",
		"password": "password123",
	}
	
	jsonData, _ := json.Marshal(loginData)
	
	w := httptest.NewRecorder()
	req, _ := http.NewRequest("POST", "/api/auth/login", bytes.NewBuffer(jsonData))
	req.Header.Set("Content-Type", "application/json")
	
	router.ServeHTTP(w, req)
	
	assert.Equal(t, 200, w.Code)
	
	var response map[string]interface{}
	json.Unmarshal(w.Body.Bytes(), &response)
	assert.NotEmpty(t, response["token"])
}

func TestProtectedEndpoint(t *testing.T) {
	// First login to get token
	token := getAuthToken(t)
	
	router := routes.SetupRoutes()
	
	w := httptest.NewRecorder()
	req, _ := http.NewRequest("GET", "/api/products", nil)
	req.Header.Set("Authorization", "Bearer "+token)
	
	router.ServeHTTP(w, req)
	
	assert.Equal(t, 200, w.Code)
}

func getAuthToken(t *testing.T) string {
	router := routes.SetupRoutes()
	
	loginData := map[string]string{
		"email":    "test@example.com",
		"password": "password123",
	}
	
	jsonData, _ := json.Marshal(loginData)
	
	w := httptest.NewRecorder()
	req, _ := http.NewRequest("POST", "/api/auth/login", bytes.NewBuffer(jsonData))
	req.Header.Set("Content-Type", "application/json")
	
	router.ServeHTTP(w, req)
	
	var response map[string]interface{}
	json.Unmarshal(w.Body.Bytes(), &response)
	
	return response["token"].(string)
}</code></pre>
                    </div>

                    <h4>üìù UAT Testing Checklist</h4>
                    <div style="background: #d4edda; border: 1px solid #c3e6cb; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h5 style="color: #155724; margin-bottom: 1rem;">‚úÖ Complete UAT Checklist</h5>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                            <div>
                                <h6 style="color: #155724;">üîß Environment Setup</h6>
                                <ul style="color: #155724; font-size: 0.9rem;">
                                    <li>‚ñ° Application running on localhost:8080</li>
                                    <li>‚ñ° Database connected successfully</li>
                                    <li>‚ñ° Environment variables configured</li>
                                    <li>‚ñ° Test database created</li>
                                    <li>‚ñ° Dependencies installed</li>
                                </ul>
                            </div>
                            <div>
                                <h6 style="color: #155724;">üîê Authentication</h6>
                                <ul style="color: #155724; font-size: 0.9rem;">
                                    <li>‚ñ° User registration works</li>
                                    <li>‚ñ° User login returns JWT token</li>
                                    <li>‚ñ° JWT token validation works</li>
                                    <li>‚ñ° Logout functionality works</li>
                                    <li>‚ñ° Password hashing secure</li>
                                </ul>
                            </div>
                            <div>
                                <h6 style="color: #155724;">üõçÔ∏è Product Management</h6>
                                <ul style="color: #155724; font-size: 0.9rem;">
                                    <li>‚ñ° Create product (admin)</li>
                                    <li>‚ñ° Read products (public)</li>
                                    <li>‚ñ° Update product (admin)</li>
                                    <li>‚ñ° Delete product (admin)</li>
                                    <li>‚ñ° Category management works</li>
                                </ul>
                            </div>
                            <div>
                                <h6 style="color: #155724;">üõí Shopping Cart</h6>
                                <ul style="color: #155724; font-size: 0.9rem;">
                                    <li>‚ñ° Add item to cart</li>
                                    <li>‚ñ° Update cart quantity</li>
                                    <li>‚ñ° Remove item from cart</li>
                                    <li>‚ñ° View cart contents</li>
                                    <li>‚ñ° Cart persists per user</li>
                                </ul>
                            </div>
                            <div>
                                <h6 style="color: #155724;">üí≥ Checkout Process</h6>
                                <ul style="color: #155724; font-size: 0.9rem;">
                                    <li>‚ñ° Create order from cart</li>
                                    <li>‚ñ° Transaction record created</li>
                                    <li>‚ñ° Cart cleared after checkout</li>
                                    <li>‚ñ° Order history accessible</li>
                                    <li>‚ñ° Order status tracking</li>
                                </ul>
                            </div>
                            <div>
                                <h6 style="color: #155724;">üîí Security</h6>
                                <ul style="color: #155724; font-size: 0.9rem;">
                                    <li>‚ñ° Unauthorized access blocked</li>
                                    <li>‚ñ° Role-based access works</li>
                                    <li>‚ñ° Input validation active</li>
                                    <li>‚ñ° Rate limiting functional</li>
                                    <li>‚ñ° CORS configured properly</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #2e7d32; margin-bottom: 1rem;">üéØ UAT Success Criteria</h4>
                        <p style="color: #388e3c; margin-bottom: 1rem;">Aplikasi dianggap siap untuk production jika:</p>
                        <ul style="color: #388e3c;">
                            <li>‚úÖ Semua functional tests pass (100%)</li>
                            <li>‚úÖ Security tests menunjukkan tidak ada vulnerability</li>
                            <li>‚úÖ Performance tests menunjukkan response time < 500ms</li>
                            <li>‚úÖ Error handling bekerja dengan baik</li>
                            <li>‚úÖ Database operations stable</li>
                            <li>‚úÖ API responses consistent</li>
                        </ul>
                    </div>

                    <h3>üåê VPS Deployment</h3>
                    <p>Sekarang mari kita deploy aplikasi ke VPS. Kita akan menggunakan Ubuntu server dengan Nginx sebagai reverse proxy.</p>

                    <h4>1. üñ•Ô∏è VPS Setup</h4>
                    <div style="background: #f3e5f5; border: 1px solid #9c27b0; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #6a1b9a; margin-bottom: 1rem;">üìã VPS Requirements</h5>
                        <ul style="color: #6a1b9a;">
                            <li>‚úÖ Ubuntu 20.04 LTS atau lebih baru</li>
                            <li>‚úÖ Minimum 1GB RAM</li>
                            <li>‚úÖ Minimum 20GB Storage</li>
                            <li>‚úÖ Root access atau sudo privileges</li>
                        </ul>
                    </div>

                    <h4>2. üîß Server Preparation</h4>
                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #2e7d32; margin-bottom: 1rem;">üìÑ Server Setup Commands</h5>
                        <pre><code># Update system
sudo apt update && sudo apt upgrade -y

# Install Go
wget https://go.dev/dl/go1.21.0.linux-amd64.tar.gz
sudo tar -C /usr/local -xzf go1.21.0.linux-amd64.tar.gz
echo 'export PATH=$PATH:/usr/local/go/bin' >> ~/.bashrc
source ~/.bashrc

# Install PostgreSQL
sudo apt install postgresql postgresql-contrib -y
sudo systemctl start postgresql
sudo systemctl enable postgresql

# Install Nginx
sudo apt install nginx -y
sudo systemctl start nginx
sudo systemctl enable nginx

# Install Git
sudo apt install git -y

# Install PM2 for process management
sudo npm install -g pm2</code></pre>
                    </div>

                    <h4>3. üóÑÔ∏è Database Setup</h4>
                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #2e7d32; margin-bottom: 1rem;">üìÑ Database Configuration</h5>
                        <pre><code># Switch to postgres user
sudo -u postgres psql

# Create database and user
CREATE DATABASE tokogo_db;
CREATE USER tokogo_user WITH PASSWORD 'your_secure_password';
GRANT ALL PRIVILEGES ON DATABASE tokogo_db TO tokogo_user;
\q

# Configure PostgreSQL for remote connections
sudo nano /etc/postgresql/12/main/postgresql.conf
# Uncomment and modify: listen_addresses = 'localhost'

sudo nano /etc/postgresql/12/main/pg_hba.conf
# Add: local   tokogo_db   tokogo_user   md5

# Restart PostgreSQL
sudo systemctl restart postgresql</code></pre>
                    </div>

                    <h4>4. üì¶ Application Deployment</h4>
                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #2e7d32; margin-bottom: 1rem;">üìÑ Deployment Script</h5>
                        <pre><code>#!/bin/bash
# deploy.sh

# Create application directory
sudo mkdir -p /var/www/tokogo
sudo chown $USER:$USER /var/www/tokogo
cd /var/www/tokogo

# Clone repository
git clone https://github.com/yourusername/tokogo.git .

# Install dependencies
go mod download

# Build application
go build -o tokogo main.go

# Create environment file
cat > .env << EOF
DB_HOST=localhost
DB_PORT=5432
DB_USER=tokogo_user
DB_PASSWORD=your_secure_password
DB_NAME=tokogo_db
JWT_SECRET=your-super-secret-jwt-key-here
SERVER_PORT=8080
ALLOWED_ORIGINS=https://yourdomain.com
RATE_LIMIT_REQUESTS=100
RATE_LIMIT_WINDOW=60
EOF

# Run database migrations
./tokogo migrate

# Start application with PM2
pm2 start ./tokogo --name "tokogo-api"
pm2 save
pm2 startup</code></pre>
                    </div>

                    <h4>5. üåê Nginx Configuration</h4>
                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #2e7d32; margin-bottom: 1rem;">üìÑ Nginx Config: /etc/nginx/sites-available/tokogo</h5>
                        <pre><code>server {
    listen 80;
    server_name yourdomain.com www.yourdomain.com;

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "no-referrer-when-downgrade" always;
    add_header Content-Security-Policy "default-src 'self' http: https: data: blob: 'unsafe-inline'" always;

    # Rate limiting
    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
    limit_req zone=api burst=20 nodelay;

    location / {
        proxy_pass http://localhost:8080;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }

    # Health check endpoint
    location /health {
        proxy_pass http://localhost:8080/api/health;
        access_log off;
    }
}</code></pre>
                    </div>

                    <h4>6. üîí SSL Certificate (Let's Encrypt)</h4>
                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #2e7d32; margin-bottom: 1rem;">üìÑ SSL Setup</h5>
                        <pre><code># Install Certbot
sudo apt install certbot python3-certbot-nginx -y

# Enable site
sudo ln -s /etc/nginx/sites-available/tokogo /etc/nginx/sites-enabled/
sudo nginx -t
sudo systemctl reload nginx

# Get SSL certificate
sudo certbot --nginx -d yourdomain.com -d www.yourdomain.com

# Test auto-renewal
sudo certbot renew --dry-run</code></pre>
                    </div>

                    <h4>7. üìä Monitoring & Logging</h4>
                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 1.5rem; border-radius: 5px; margin: 1rem 0;">
                        <h5 style="color: #2e7d32; margin-bottom: 1rem;">üìÑ Monitoring Setup</h5>
                        <pre><code># PM2 Monitoring
pm2 monit

# Log management
pm2 logs tokogo-api

# Setup log rotation
pm2 install pm2-logrotate

# Health check script
cat > /var/www/tokogo/health_check.sh << EOF
#!/bin/bash
response=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/api/health)
if [ $response != "200" ]; then
    echo "Health check failed. Restarting application..."
    pm2 restart tokogo-api
fi
EOF

chmod +x /var/www/tokogo/health_check.sh

# Add to crontab for every 5 minutes
(crontab -l 2>/dev/null; echo "*/5 * * * * /var/www/tokogo/health_check.sh") | crontab -</code></pre>
                    </div>

                    <h3>üöÄ Deployment Checklist</h3>
                    <div style="background: #d4edda; border: 1px solid #c3e6cb; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #155724; margin-bottom: 1rem;">‚úÖ Pre-Deployment Checklist</h4>
                        <ul style="color: #155724;">
                            <li>‚úÖ Environment variables configured</li>
                            <li>‚úÖ Database migrations ready</li>
                            <li>‚úÖ SSL certificate installed</li>
                            <li>‚úÖ Firewall configured (UFW)</li>
                            <li>‚úÖ Backup strategy implemented</li>
                            <li>‚úÖ Monitoring setup</li>
                            <li>‚úÖ Log rotation configured</li>
                        </ul>
                    </div>

                    <div style="background: #d4edda; border: 1px solid #c3e6cb; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #155724; margin-bottom: 1rem;">‚úÖ Post-Deployment Checklist</h4>
                        <ul style="color: #155724;">
                            <li>‚úÖ Application accessible via HTTPS</li>
                            <li>‚úÖ All API endpoints working</li>
                            <li>‚úÖ Database connections stable</li>
                            <li>‚úÖ Performance metrics normal</li>
                            <li>‚úÖ Error logs clean</li>
                            <li>‚úÖ Backup system tested</li>
                            <li>‚úÖ Monitoring alerts configured</li>
                        </ul>
                    </div>

                    <h3>üéØ Best Practices untuk Production</h3>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #2c3e50; margin-bottom: 1rem;">üîß Production Best Practices</h4>
                        <ul style="color: #495057;">
                            <li>‚úÖ <strong>Environment Separation</strong> - Gunakan environment yang berbeda untuk dev, staging, dan production</li>
                            <li>‚úÖ <strong>Configuration Management</strong> - Gunakan environment variables untuk semua konfigurasi</li>
                            <li>‚úÖ <strong>Database Backups</strong> - Implementasikan automated backup dengan retention policy</li>
                            <li>‚úÖ <strong>Logging Strategy</strong> - Centralized logging dengan proper log levels</li>
                            <li>‚úÖ <strong>Monitoring & Alerting</strong> - Setup monitoring untuk performance dan errors</li>
                            <li>‚úÖ <strong>Security Updates</strong> - Regular security updates untuk OS dan dependencies</li>
                            <li>‚úÖ <strong>Disaster Recovery</strong> - Plan untuk disaster recovery dan business continuity</li>
                        </ul>
                    </div>

                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #2e7d32; margin-bottom: 1rem;">üå± Refleksi Pembelajaran UAT & Deployment</h4>
                        <p style="color: #388e3c; margin-bottom: 1rem;">Anda telah berhasil menguasai:</p>
                        <ul style="color: #388e3c;">
                            <li>‚úÖ <strong>User Acceptance Testing</strong> - Comprehensive testing strategy</li>
                            <li>‚úÖ <strong>Performance Testing</strong> - Load testing dan optimization</li>
                            <li>‚úÖ <strong>VPS Deployment</strong> - Production deployment ke VPS</li>
                            <li>‚úÖ <strong>Server Configuration</strong> - Nginx, SSL, dan security setup</li>
                            <li>‚úÖ <strong>Process Management</strong> - PM2 untuk application management</li>
                            <li>‚úÖ <strong>Monitoring & Logging</strong> - Production monitoring setup</li>
                            <li>‚úÖ <strong>Security Hardening</strong> - Production security best practices</li>
                            <li>‚úÖ <strong>Backup & Recovery</strong> - Data protection strategies</li>
                        </ul>
                        <p style="color: #2e7d32; margin-top: 1rem; font-style: italic;">"Deployment yang sukses bukan hanya tentang menjalankan aplikasi, tetapi tentang memastikan aplikasi berjalan dengan aman, stabil, dan dapat diandalkan dalam environment production."</p>
                    </div>

                    <h3>üìö Referensi Deployment</h3>
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #2c3e50; margin-bottom: 1rem;">üîó Sumber Belajar Tambahan</h4>
                        <ul style="color: #495057;">
                            <li><strong>Go Deployment Guide</strong> - https://golang.org/doc/deploy</li>
                            <li><strong>Nginx Configuration</strong> - https://nginx.org/en/docs/</li>
                            <li><strong>Let's Encrypt</strong> - https://letsencrypt.org/docs/</li>
                            <li><strong>PM2 Documentation</strong> - https://pm2.keymetrics.io/docs/</li>
                            <li><strong>PostgreSQL Production</strong> - https://www.postgresql.org/docs/current/runtime-config.html</li>
                        </ul>
                    </div>
                `
            },
            {
                id: 'chapter22',
                title: 'Bab 22: Penutup - Perjalanan Menjadi Go Developer',
                meta: 'Halaman 23 dari 55 ‚Ä¢ Dibaca 5 menit',
                content: `
                    <h2>üéâ Bab 22: Penutup</h2>
                    <p>Selamat! Anda telah menyelesaikan perjalanan pembelajaran Go programming yang luar biasa. Dari dasar-dasar Go hingga membangun aplikasi API toko online yang lengkap dan production-ready.</p>

                    <div style="background: #d4edda; border: 1px solid #c3e6cb; padding: 2rem; border-radius: 5px; margin: 2rem 0; text-align: center;">
                        <h3 style="color: #155724; margin-bottom: 1rem;">üåü Congratulations!</h3>
                        <p style="color: #155724; margin-bottom: 1rem;">Anda sekarang memiliki fondasi yang kuat dalam Go development. Anda telah belajar:</p>
                        <ul style="color: #155724; text-align: left; display: inline-block;">
                            <li>‚úÖ Go programming fundamentals</li>
                            <li>‚úÖ REST API development dengan Gin</li>
                            <li>‚úÖ Database integration dengan GORM</li>
                            <li>‚úÖ Authentication & authorization</li>
                            <li>‚úÖ E-commerce application development</li>
                            <li>‚úÖ Security best practices</li>
                            <li>‚úÖ Testing & deployment</li>
                        </ul>
                    </div>

                    <div style="background: #e3f2fd; border: 1px solid #2196f3; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #1565c0; margin-bottom: 1rem;">üöÄ Langkah Selanjutnya</h4>
                        <p style="color: #1565c0; margin-bottom: 1rem;">Perjalanan sebagai Go developer baru dimulai. Teruslah belajar dan eksplorasi:</p>
                        <ul style="color: #1565c0;">
                            <li>‚Ä¢ Pelajari advanced Go concepts (goroutines, channels)</li>
                            <li>‚Ä¢ Eksplorasi microservices architecture</li>
                            <li>‚Ä¢ Belajar Docker & Kubernetes</li>
                            <li>‚Ä¢ Bangun project-project baru</li>
                            <li>‚Ä¢ Bergabung dengan komunitas Go developer</li>
                        </ul>
                    </div>

                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; padding: 2rem; border-radius: 5px; margin: 2rem 0; text-align: center;">
                        <h3 style="color: #2c3e50; margin-bottom: 1rem;">üíª Keep Coding!</h3>
                        <p style="color: #495057; margin-bottom: 0; font-style: italic;">"The best way to learn programming is by programming. Keep coding, keep learning, and keep building amazing things!"</p>
                    </div>

                    <div style="background: #e8f5e8; border: 1px solid #4caf50; padding: 2rem; border-radius: 5px; margin: 2rem 0;">
                        <h4 style="color: #2e7d32; margin-bottom: 1rem;">üìö Resources untuk Belajar Lebih Lanjut</h4>
                        <ul style="color: #388e3c;">
                            <li><strong>Go by Example</strong> - gobyexample.com</li>
                            <li><strong>Go Playground</strong> - play.golang.org</li>
                            <li><strong>Go Blog</strong> - blog.golang.org</li>
                            <li><strong>Awesome Go</strong> - awesome-go.com</li>
                        </ul>
                    </div>

                    <div style="background: #fff3e0; border: 1px solid #ff9800; padding: 2rem; border-radius: 5px; margin: 2rem 0; text-align: center;">
                        <h3 style="color: #e65100; margin-bottom: 1rem;">üéØ Terima Kasih!</h3>
                        <p style="color: #e65100; margin-bottom: 0;">Terima kasih telah mengikuti ebook ini sampai selesai. Semoga perjalanan Anda sebagai Go developer penuh dengan kesuksesan dan inovasi!</p>
                    </div>
                `
            }
        ];

        // Current chapter index
        let currentChapterIndex = 0;

        // Font size control
        let currentFontSize = 16;
        const fontSizeDisplay = document.getElementById('fontSize');

        function increaseFont() {
            currentFontSize = Math.min(currentFontSize + 2, 24);
            const contentBody = document.getElementById('contentBody');
            if (contentBody) {
                contentBody.style.fontSize = currentFontSize + 'px';
            }
            fontSizeDisplay.textContent = currentFontSize + 'px';
        }

        function decreaseFont() {
            currentFontSize = Math.max(currentFontSize - 2, 12);
            const contentBody = document.getElementById('contentBody');
            if (contentBody) {
                contentBody.style.fontSize = currentFontSize + 'px';
            }
            fontSizeDisplay.textContent = currentFontSize + 'px';
        }

        // Chapter management functions
        function renderChapterList() {
            const chapterList = document.getElementById('chapterList');
            chapterList.innerHTML = '';
            
            chapters.forEach((chapter, index) => {
                const li = document.createElement('li');
                li.className = 'chapter-item';
                
                const a = document.createElement('a');
                a.href = `#${chapter.id}`;
                a.className = 'chapter-link';
                a.textContent = chapter.title;
                a.onclick = (e) => {
                    e.preventDefault();
                    showChapter(index);
                };
                
                li.appendChild(a);
                chapterList.appendChild(li);
            });
        }

        function renderChapter(index) {
            const chapter = chapters[index];
            const contentArea = document.getElementById('contentArea');
            
            contentArea.innerHTML = `
                <div class="content-header">
                    <h1 class="chapter-title">${chapter.title}</h1>
                    <div class="chapter-meta">${chapter.meta}</div>
                </div>
                <div class="content-body" id="contentBody">
                    ${chapter.content}
                </div>
                <div class="navigation">
                    <button class="nav-btn" ${index === 0 ? 'disabled' : ''} onclick="showChapter(${index - 1})">‚Üê Sebelumnya</button>
                    <button class="nav-btn" ${index === chapters.length - 1 ? 'disabled' : ''} onclick="showChapter(${index + 1})">Selanjutnya ‚Üí</button>
                </div>
            `;
            
            // Apply font size to new content
            const contentBody = document.getElementById('contentBody');
            if (contentBody) {
                contentBody.style.fontSize = currentFontSize + 'px';
            }
        }

        function showChapter(index) {
            if (index >= 0 && index < chapters.length) {
                currentChapterIndex = index;
                renderChapter(index);
                updateActiveChapter();
                
                // Scroll to top
                window.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });
            }
        }

        function updateActiveChapter() {
            document.querySelectorAll('.chapter-link').forEach((link, index) => {
                link.classList.toggle('active', index === currentChapterIndex);
            });
        }

        // Function to add new chapter easily
        function addChapter(title, meta, content) {
            const newChapter = {
                id: `chapter${chapters.length + 1}`,
                title: title,
                meta: meta,
                content: content
            };
            chapters.push(newChapter);
            renderChapterList();
            return newChapter;
        }

        // Example of how to add a new chapter:
        // addChapter(
        //     'Bab 3: Struktur Project',
        //     'Halaman 3 dari 51 ‚Ä¢ Dibaca 10 menit',
        //     '<h2>Struktur Project yang Baik</h2><p>Konten bab 3...</p>'
        // );

        // Dark mode toggle
        function toggleDarkMode() {
            const body = document.body;
            const header = document.getElementById('header');
            const logo = document.getElementById('logo');
            const logoSubtitle = document.getElementById('logoSubtitle');
            const themeIcon = document.getElementById('themeIcon');
            const themeText = document.getElementById('themeText');
            const themeToggle = document.getElementById('themeToggle');
            
            body.classList.toggle('dark-mode');
            header.classList.toggle('dark');
            logo.classList.toggle('dark');
            logoSubtitle.classList.toggle('dark');
            themeToggle.classList.toggle('dark');
            
            if (body.classList.contains('dark-mode')) {
                themeIcon.textContent = '‚òÄÔ∏è';
                themeText.textContent = 'Light';
            } else {
                themeIcon.textContent = 'üåô';
                themeText.textContent = 'Dark';
            }
            
            // Save theme preference to localStorage
            localStorage.setItem('darkMode', body.classList.contains('dark-mode'));
        }

        // Load theme preference from localStorage
        function loadThemePreference() {
            const savedTheme = localStorage.getItem('darkMode');
            if (savedTheme === 'true') {
                toggleDarkMode();
            }
        }

        // Sidebar toggle
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('show');
        }

        // Progress bar
        function updateProgress() {
            const scrollTop = window.pageYOffset;
            const docHeight = document.body.scrollHeight - window.innerHeight;
            const scrollPercent = (scrollTop / docHeight) * 100;
            document.getElementById('progressBar').style.width = scrollPercent + '%';
        }

        // Event listeners
        window.addEventListener('scroll', function() {
            updateProgress();
        });
        
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize the ebook
            renderChapterList();
            showChapter(0); // Start with first chapter
            updateProgress();
            loadThemePreference(); // Load saved theme preference
        });

        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', function(e) {
            const sidebar = document.getElementById('sidebar');
            const sidebarToggle = document.querySelector('.sidebar-toggle');
            
            if (window.innerWidth <= 768 && 
                sidebar && 
                !sidebar.contains(e.target) && 
                !sidebarToggle.contains(e.target) && 
                sidebar.classList.contains('show')) {
                sidebar.classList.remove('show');
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case '=':
                    case '+':
                        e.preventDefault();
                        increaseFont();
                        break;
                    case '-':
                        e.preventDefault();
                        decreaseFont();
                        break;
                }
            }
        });
    </script>
</body>
</html>
